# 🚀 条件網羅（Condition Coverage）- 上級演習・実務レベル

## 🎯 上級演習の目的
- 実務レベルの複雑な複合条件での条件網羅適用
- パフォーマンスとテスト品質のバランス調整
- 実際のプロジェクトシナリオでの問題解決手法習得

---

## 💪 上級演習 1：認証・認可システムの条件網羅

### 📝 問題：多層セキュリティシステム
以下の企業向けセキュリティシステムで**効率的な条件網羅**を達成してください。

```java
public class EnterpriseSecurityManager {
    
    public AccessResult evaluateAccess(User user, Resource resource, 
                                     AccessContext context, SecurityPolicy policy) {
        // 基本認証チェック
        if (!user.isAuthenticated() || user.isLocked() || user.isExpired()) {
            return AccessResult.deny("Authentication failed", "AUTH_001");
        }
        
        // 多要素認証チェック（機密リソースの場合）
        boolean requiresMFA = resource.getClassification().equals("CONFIDENTIAL") || 
                             resource.getClassification().equals("TOP_SECRET");
        
        if (requiresMFA && (!user.hasMFAToken() || !user.getMFAToken().isValid())) {
            return AccessResult.deny("MFA required", "AUTH_002");
        }
        
        // 役割ベースアクセス制御
        boolean hasRequiredRole = user.getRoles().contains(resource.getRequiredRole()) ||
                                 user.getRoles().contains("ADMIN") ||
                                 (user.getRoles().contains("MANAGER") && 
                                  resource.getCategory().equals("BUSINESS"));
        
        if (!hasRequiredRole) {
            return AccessResult.deny("Insufficient privileges", "AUTHZ_001");
        }
        
        // 時間・場所制限チェック
        boolean timeRestricted = policy.hasTimeRestrictions() && 
                               (context.getCurrentTime().isBefore(policy.getStartTime()) ||
                                context.getCurrentTime().isAfter(policy.getEndTime()));
        
        boolean locationRestricted = policy.hasLocationRestrictions() &&
                                   !policy.getAllowedLocations().contains(context.getLocation()) &&
                                   !context.isVPNConnection();
        
        if (timeRestricted || locationRestricted) {
            return AccessResult.deny("Access restrictions violated", "POLICY_001");
        }
        
        // リスクベース評価
        int riskScore = calculateRiskScore(user, resource, context);
        boolean highRisk = riskScore > 80;
        boolean mediumRisk = riskScore > 50 && riskScore <= 80;
        
        if (highRisk && !user.hasAdditionalVerification()) {
            return AccessResult.deny("High risk access blocked", "RISK_001");
        }
        
        if (mediumRisk && resource.isHighValue() && 
            !context.isFromTrustedDevice()) {
            return AccessResult.deny("Medium risk from untrusted device", "RISK_002");
        }
        
        // 同時接続制限
        if (policy.hasConnectionLimits() && 
            user.getCurrentConnections() >= policy.getMaxConnections() &&
            !user.getRoles().contains("ADMIN")) {
            return AccessResult.deny("Connection limit exceeded", "CONN_001");
        }
        
        // 最終承認
        if (requiresApproval(user, resource, context)) {
            return AccessResult.pendingApproval("Approval required", "APPROVAL_001");
        }
        
        return AccessResult.allow("Access granted");
    }
    
    private int calculateRiskScore(User user, Resource resource, AccessContext context) {
        // リスクスコア計算ロジック（簡略化）
        int score = 0;
        if (!context.isFromCorporateNetwork()) score += 30;
        if (context.getTimeOfDay().isAfter(LocalTime.of(22, 0))) score += 20;
        if (resource.isHighValue()) score += 25;
        if (!user.hasRecentActivity()) score += 25;
        return score;
    }
    
    private boolean requiresApproval(User user, Resource resource, AccessContext context) {
        return resource.isHighValue() && 
               context.isAfterHours() && 
               !user.getRoles().contains("ADMIN");
    }
}
```

### 🤔 分析手順

#### ステップ1: 複合条件の構造分析
この複雑なシステムには**21個の個別条件**が含まれています：

**基本認証（3個）**:
1. `!user.isAuthenticated()`
2. `user.isLocked()`  
3. `user.isExpired()`

**MFA認証（4個）**:
4. `resource.getClassification().equals("CONFIDENTIAL")`
5. `resource.getClassification().equals("TOP_SECRET")`
6. `!user.hasMFAToken()`
7. `!user.getMFAToken().isValid()`

**役割ベースアクセス（4個）**:
8. `user.getRoles().contains(resource.getRequiredRole())`
9. `user.getRoles().contains("ADMIN")`
10. `user.getRoles().contains("MANAGER")`
11. `resource.getCategory().equals("BUSINESS")`

**時間・場所制限（7個）**:
12. `policy.hasTimeRestrictions()`
13. `context.getCurrentTime().isBefore(policy.getStartTime())`
14. `context.getCurrentTime().isAfter(policy.getEndTime())`
15. `policy.hasLocationRestrictions()`
16. `!policy.getAllowedLocations().contains(context.getLocation())`
17. `!context.isVPNConnection()`

**リスク評価（3個）**:
18. `user.hasAdditionalVerification()` (highRisk条件内)
19. `resource.isHighValue()` (mediumRisk条件内)
20. `context.isFromTrustedDevice()` (mediumRisk条件内)
21. `user.getRoles().contains("ADMIN")` (connection limit条件内)

### ✅ 解答：実務レベルの効率的条件網羅テスト

```java
@Test
public void testEnterpriseSecurityManager_AdvancedConditionCoverage() {
    EnterpriseSecurityManager securityManager = new EnterpriseSecurityManager();
    
    // === 戦略的テストデータセットアップ ===
    
    // 基本ユーザータイプ
    User authenticatedUser = createUser(true, false, false, Set.of("USER"), true, true);
    User lockedUser = createUser(true, true, false, Set.of("USER"), false, false);
    User expiredUser = createUser(true, false, true, Set.of("USER"), false, false);
    User adminUser = createUser(true, false, false, Set.of("ADMIN"), true, true);
    User managerUser = createUser(true, false, false, Set.of("MANAGER"), true, true);
    
    // リソースタイプ
    Resource publicResource = createResource("PUBLIC", "GENERAL", "USER");
    Resource confidentialResource = createResource("CONFIDENTIAL", "BUSINESS", "MANAGER");
    Resource topSecretResource = createResource("TOP_SECRET", "SECURITY", "ADMIN");
    Resource highValueResource = createResource("CONFIDENTIAL", "FINANCIAL", "USER", true);
    
    // コンテキスト
    AccessContext trustedContext = createContext(true, true, "CORPORATE_HQ", LocalTime.of(10, 0));
    AccessContext untrustedContext = createContext(false, false, "UNKNOWN", LocalTime.of(23, 0));
    AccessContext vpnContext = createContext(false, true, "HOME", LocalTime.of(14, 0));
    
    // ポリシー
    SecurityPolicy strictPolicy = createPolicy(true, true, LocalTime.of(8, 0), LocalTime.of(18, 0), 
                                               Set.of("CORPORATE_HQ"), 3);
    SecurityPolicy lenientPolicy = createPolicy(false, false, null, null, null, 10);
    
    // === 系統的条件網羅テスト ===
    
    // TC1: 基本認証条件の網羅
    assertAccessDenied(securityManager.evaluateAccess(
        createUser(false, false, false, Set.of("USER"), false, false), // !authenticated: T
        publicResource, trustedContext, lenientPolicy
    ), "AUTH_001");
    
    assertAccessDenied(securityManager.evaluateAccess(
        lockedUser,           // isLocked: T  
        publicResource, trustedContext, lenientPolicy
    ), "AUTH_001");
    
    assertAccessDenied(securityManager.evaluateAccess(
        expiredUser,          // isExpired: T
        publicResource, trustedContext, lenientPolicy
    ), "AUTH_001");
    
    // TC2: MFA条件の網羅
    // CONFIDENTIAL分類でMFA要求
    assertAccessDenied(securityManager.evaluateAccess(
        createUser(true, false, false, Set.of("MANAGER"), false, false), // !hasMFAToken: T
        confidentialResource, trustedContext, lenientPolicy
    ), "AUTH_002");
    
    // TOP_SECRET分類でMFA要求  
    assertAccessDenied(securityManager.evaluateAccess(
        createUser(true, false, false, Set.of("ADMIN"), true, false), // !isValid: T
        topSecretResource, trustedContext, lenientPolicy
    ), "AUTH_002");
    
    // PUBLIC分類でMFA不要（分類条件のFalse）
    assertAccessAllowed(securityManager.evaluateAccess(
        createUser(true, false, false, Set.of("USER"), false, false),
        publicResource, trustedContext, lenientPolicy
    ));
    
    // TC3: 役割ベースアクセス条件の網羅
    // 必要な役割を持つ場合
    assertAccessAllowed(securityManager.evaluateAccess(
        createUser(true, false, false, Set.of("MANAGER"), true, true), // hasRequiredRole: T
        confidentialResource, trustedContext, lenientPolicy
    ));
    
    // ADMIN役割での全アクセス
    assertAccessAllowed(securityManager.evaluateAccess(
        adminUser,            // isAdmin: T
        topSecretResource, trustedContext, lenientPolicy
    ));
    
    // MANAGERでBUSINESSカテゴリアクセス
    assertAccessAllowed(securityManager.evaluateAccess(
        managerUser,          // isManager: T, category=BUSINESS: T
        confidentialResource, trustedContext, lenientPolicy
    ));
    
    // 権限不足
    assertAccessDenied(securityManager.evaluateAccess(
        authenticatedUser,    // 必要な役割なし
        confidentialResource, trustedContext, lenientPolicy
    ), "AUTHZ_001");
    
    // TC4: 時間・場所制限条件の網羅
    // 時間制限違反（開始前）
    assertAccessDenied(securityManager.evaluateAccess(
        adminUser, publicResource,
        createContext(true, true, "CORPORATE_HQ", LocalTime.of(6, 0)), // before start: T
        strictPolicy
    ), "POLICY_001");
    
    // 時間制限違反（終了後）
    assertAccessDenied(securityManager.evaluateAccess(
        adminUser, publicResource,
        createContext(true, true, "CORPORATE_HQ", LocalTime.of(20, 0)), // after end: T
        strictPolicy
    ), "POLICY_001");
    
    // 場所制限違反（VPNなし）
    assertAccessDenied(securityManager.evaluateAccess(
        adminUser, publicResource,
        createContext(true, false, "UNAUTHORIZED", LocalTime.of(10, 0)), // !vpn: T, !allowed: T
        strictPolicy
    ), "POLICY_001");
    
    // VPN経由でのアクセス許可
    assertAccessAllowed(securityManager.evaluateAccess(
        adminUser, publicResource, vpnContext, strictPolicy
    ));
    
    // 制限なしポリシー
    assertAccessAllowed(securityManager.evaluateAccess(
        adminUser, publicResource, untrustedContext, lenientPolicy
    ));
    
    // TC5: リスク評価条件の網羅
    // 高リスクでの追加認証なし
    User highRiskUser = createUser(true, false, false, Set.of("USER"), true, true);
    highRiskUser.setAdditionalVerification(false);  // !hasAdditionalVerification: T
    
    assertAccessDenied(securityManager.evaluateAccess(
        highRiskUser, publicResource,
        createContext(false, false, "UNKNOWN", LocalTime.of(23, 30)), // 高リスクコンテキスト
        lenientPolicy
    ), "RISK_001");
    
    // 中リスク + 高価値リソース + 信頼できないデバイス
    User mediumRiskUser = createUser(true, false, false, Set.of("USER"), true, true);
    assertAccessDenied(securityManager.evaluateAccess(
        mediumRiskUser, highValueResource,  // isHighValue: T
        createContext(false, false, "OFFICE", LocalTime.of(15, 0)), // !trustedDevice: T
        lenientPolicy
    ), "RISK_002");
    
    // TC6: 同時接続制限条件の網羅
    User limitedUser = createUser(true, false, false, Set.of("USER"), true, true);
    limitedUser.setCurrentConnections(5); // 制限超過
    
    assertAccessDenied(securityManager.evaluateAccess(
        limitedUser, publicResource, trustedContext, strictPolicy // maxConnections=3
    ), "CONN_001");
    
    // ADMIN除外
    adminUser.setCurrentConnections(10);
    assertAccessAllowed(securityManager.evaluateAccess(
        adminUser, publicResource, trustedContext, strictPolicy
    ));
    
    // TC7: 承認要求条件の網羅
    // 高価値リソース + 時間外 + 非ADMIN
    assertPendingApproval(securityManager.evaluateAccess(
        authenticatedUser, highValueResource,
        createContext(true, true, "CORPORATE_HQ", LocalTime.of(22, 30)), // afterHours: T
        lenientPolicy
    ), "APPROVAL_001");
}

// === ヘルパーメソッド（効率的なテストデータ作成）===

private User createUser(boolean authenticated, boolean locked, boolean expired, 
                       Set<String> roles, boolean hasMFA, boolean validMFA) {
    User user = new User();
    user.setAuthenticated(authenticated);
    user.setLocked(locked);
    user.setExpired(expired);
    user.setRoles(roles);
    user.setHasMFAToken(hasMFA);
    if (hasMFA) {
        user.setMFAToken(createMFAToken(validMFA));
    }
    user.setAdditionalVerification(true); // デフォルトtrue
    user.setCurrentConnections(1);
    return user;
}

private Resource createResource(String classification, String category, 
                              String requiredRole, boolean highValue) {
    Resource resource = new Resource();
    resource.setClassification(classification);
    resource.setCategory(category);
    resource.setRequiredRole(requiredRole);
    resource.setHighValue(highValue);
    return resource;
}

private Resource createResource(String classification, String category, String requiredRole) {
    return createResource(classification, category, requiredRole, false);
}

private AccessContext createContext(boolean trustedDevice, boolean vpn, 
                                  String location, LocalTime time) {
    AccessContext context = new AccessContext();
    context.setFromTrustedDevice(trustedDevice);
    context.setVPNConnection(vpn);
    context.setLocation(location);
    context.setCurrentTime(time);
    context.setFromCorporateNetwork(trustedDevice);
    context.setAfterHours(time.isAfter(LocalTime.of(18, 0)) || time.isBefore(LocalTime.of(8, 0)));
    return context;
}

private SecurityPolicy createPolicy(boolean timeRestrictions, boolean locationRestrictions,
                                  LocalTime startTime, LocalTime endTime,
                                  Set<String> allowedLocations, int maxConnections) {
    SecurityPolicy policy = new SecurityPolicy();
    policy.setHasTimeRestrictions(timeRestrictions);
    policy.setHasLocationRestrictions(locationRestrictions);
    policy.setStartTime(startTime);
    policy.setEndTime(endTime);
    policy.setAllowedLocations(allowedLocations);
    policy.setHasConnectionLimits(true);
    policy.setMaxConnections(maxConnections);
    return policy;
}

// アサーションヘルパー
private void assertAccessDenied(AccessResult result, String expectedCode) {
    assertEquals("DENY", result.getStatus());
    assertEquals(expectedCode, result.getErrorCode());
}

private void assertAccessAllowed(AccessResult result) {
    assertEquals("ALLOW", result.getStatus());
}

private void assertPendingApproval(AccessResult result, String expectedCode) {
    assertEquals("PENDING", result.getStatus());
    assertEquals(expectedCode, result.getErrorCode());
}
```

### 📊 実務での条件網羅最適化ポイント

#### 💡 1. リスクベース優先順位付け
```java
// 高リスク条件の重点網羅
@Test
public void testHighRiskConditions_PrioritizedCoverage() {
    // セキュリティクリティカルな条件を優先的にテスト
    
    // Priority 1: 認証・認可条件（セキュリティの基盤）
    testAuthenticationConditions();
    testAuthorizationConditions();
    
    // Priority 2: アクセス制御条件（不正アクセス防止）
    testAccessControlConditions();
    
    // Priority 3: 監査・ログ条件（証跡確保）
    testAuditConditions();
}
```

#### 💡 2. テストデータファクトリーパターン
```java
public class SecurityTestDataFactory {
    
    public static User createBasicUser() {
        return createUser(true, false, false, Set.of("USER"), false, false);
    }
    
    public static User createAdminUser() {
        return createUser(true, false, false, Set.of("ADMIN"), true, true);
    }
    
    public static User createHighRiskUser() {
        User user = createBasicUser();
        user.setRecentActivity(false);
        user.setFromUnknownLocation(true);
        return user;
    }
    
    // 条件網羅のための特化データ作成
    public static TestDataSet createConditionCoverageDataSet() {
        return TestDataSet.builder()
            .withUsers(createAllUserTypes())
            .withResources(createAllResourceTypes())
            .withContexts(createAllContextTypes())
            .withPolicies(createAllPolicyTypes())
            .build();
    }
}
```

---

## 💪 上級演習 2：複雑な業務ルールエンジン

### 📝 問題：保険料計算の高度ルールエンジン
以下の保険料計算システムで**効率的かつ実用的な条件網羅**を達成してください。

```java
public class InsurancePremiumEngine {
    
    public PremiumCalculationResult calculatePremium(Policy policy, Applicant applicant, 
                                                   CalculationContext context) {
        
        PremiumCalculation calc = new PremiumCalculation();
        calc.setBasePremium(policy.getBasePremium());
        
        // === 年齢係数 ===
        if (applicant.getAge() < 18 || applicant.getAge() > 85) {
            return PremiumCalculationResult.rejected("Age out of acceptable range");
        }
        
        double ageFactor = 1.0;
        if (applicant.getAge() >= 65) {
            ageFactor = 2.0;  // 高齢者割増
        } else if (applicant.getAge() >= 50) {
            ageFactor = 1.5;  // 中高年割増
        } else if (applicant.getAge() >= 35) {
            ageFactor = 1.2;  // 中年割増
        } else if (applicant.getAge() >= 25) {
            ageFactor = 1.0;  // 標準
        } else {
            ageFactor = 0.9;  // 若年割引
        }
        
        // === 健康状態評価 ===
        boolean hasHealthIssues = applicant.hasSmoking() || 
                                 applicant.hasChronicDisease() || 
                                 applicant.hasHazardousJob();
        
        double healthFactor = 1.0;
        if (hasHealthIssues) {
            int riskLevel = 0;
            if (applicant.hasSmoking()) riskLevel += 2;
            if (applicant.hasChronicDisease()) riskLevel += 3;
            if (applicant.hasHazardousJob()) riskLevel += 2;
            
            if (riskLevel >= 5) {
                healthFactor = 2.5;  // 高リスク
            } else if (riskLevel >= 3) {
                healthFactor = 1.8;  // 中リスク
            } else {
                healthFactor = 1.3;  // 低リスク
            }
        } else if (applicant.hasHealthCertificate() && 
                  applicant.getLastMedicalCheckup().isAfter(context.getCurrentDate().minusYears(1))) {
            healthFactor = 0.9;  // 健康割引
        }
        
        // === 地域・環境要因 ===
        String region = applicant.getAddress().getRegion();
        boolean highRiskRegion = region.equals("DISASTER_PRONE") || 
                               region.equals("HIGH_CRIME") ||
                               (region.equals("URBAN") && applicant.getAddress().getCrimeRate() > 0.05);
        
        double regionFactor = 1.0;
        if (highRiskRegion) {
            regionFactor = 1.4;
        } else if (region.equals("RURAL") && applicant.getAddress().hasNearbyMedicalFacility()) {
            regionFactor = 0.95;
        }
        
        // === 保険期間・支払い方法 ===
        int termYears = policy.getTermYears();
        boolean longTerm = termYears >= 20;
        boolean mediumTerm = termYears >= 10 && termYears < 20;
        
        double termFactor = 1.0;
        if (longTerm && applicant.getAge() <= 40) {
            termFactor = 0.85;  // 若年長期割引
        } else if (longTerm) {
            termFactor = 0.95;  // 長期割引
        } else if (mediumTerm) {
            termFactor = 0.98;  // 中期割引
        }
        
        boolean annualPayment = policy.getPaymentFrequency().equals("ANNUAL");
        boolean hasAutoDebit = policy.hasAutoDebit();
        
        double paymentFactor = 1.0;
        if (annualPayment && hasAutoDebit) {
            paymentFactor = 0.92;  // 年払い自動引落し割引
        } else if (annualPayment) {
            paymentFactor = 0.95;  // 年払い割引
        } else if (hasAutoDebit) {
            paymentFactor = 0.97;  // 自動引落し割引
        }
        
        // === 家族・既契約者割引 ===
        boolean familyDiscount = (applicant.getFamilySize() >= 3 && 
                                 applicant.hasSpouseInsured()) ||
                                (applicant.getFamilySize() >= 4);
        
        boolean existingCustomerDiscount = applicant.isExistingCustomer() && 
                                         applicant.getCustomerYears() >= 5 &&
                                         !applicant.hasClaimHistory();
        
        double loyaltyFactor = 1.0;
        if (familyDiscount && existingCustomerDiscount) {
            loyaltyFactor = 0.85;  // 両方割引
        } else if (familyDiscount) {
            loyaltyFactor = 0.92;  // 家族割引
        } else if (existingCustomerDiscount) {
            loyaltyFactor = 0.90;  // 既契約者割引
        }
        
        // === 特別条件・免責事項 ===
        boolean hasSpecialConditions = applicant.hasPreExistingCondition() ||
                                     applicant.hasHighRiskHobby() ||
                                     applicant.getOccupation().isHighRisk();
        
        if (hasSpecialConditions && !policy.acceptsSpecialConditions()) {
            return PremiumCalculationResult.rejected("Special conditions not accepted");
        }
        
        double specialConditionFactor = 1.0;
        if (hasSpecialConditions) {
            specialConditionFactor = 1.6;
        }
        
        // === 最終計算 ===
        double finalPremium = calc.getBasePremium() * 
                             ageFactor * 
                             healthFactor * 
                             regionFactor * 
                             termFactor * 
                             paymentFactor * 
                             loyaltyFactor * 
                             specialConditionFactor;
        
        // 最低・最高保険料チェック
        double minPremium = policy.getMinPremium();
        double maxPremium = policy.getMaxPremium();
        
        if (finalPremium < minPremium) {
            finalPremium = minPremium;
            calc.addNote("Minimum premium applied");
        } else if (finalPremium > maxPremium) {
            if (context.isManualReviewAllowed()) {
                calc.addNote("Manual review required for high premium");
                calc.setRequiresManualReview(true);
            } else {
                return PremiumCalculationResult.rejected("Premium exceeds maximum allowed");
            }
        }
        
        calc.setFinalPremium(finalPremium);
        calc.setFactors(ageFactor, healthFactor, regionFactor, termFactor, 
                       paymentFactor, loyaltyFactor, specialConditionFactor);
        
        return PremiumCalculationResult.approved(calc);
    }
}
```

### ✅ 解答：実用性重視の条件網羅戦略

この複雑な業務ルールエンジンには**35個以上の個別条件**が含まれます。実務では全条件の完全網羅は非効率的なため、**リスクベース・段階的アプローチ**を採用します。

```java
@Test
public class InsurancePremiumEngine_StrategicConditionCoverage {
    
    // === Phase 1: 高リスク条件の重点網羅 ===
    
    @Test
    public void testCriticalBusinessRules_ConditionCoverage() {
        InsurancePremiumEngine engine = new InsurancePremiumEngine();
        
        // 1. 年齢制限（ビジネスクリティカル）
        // 条件: age < 18, age > 85
        assertRejected(engine.calculatePremium(
            standardPolicy, createApplicant(17), standardContext  // age < 18: T
        ), "Age out of acceptable range");
        
        assertRejected(engine.calculatePremium(
            standardPolicy, createApplicant(86), standardContext  // age > 85: T
        ), "Age out of acceptable range");
        
        assertApproved(engine.calculatePremium(
            standardPolicy, createApplicant(30), standardContext  // age valid: age < 18: F, age > 85: F
        ));
        
        // 2. 特別条件受入れ（契約可否に直結）
        // 条件: hasSpecialConditions && !policy.acceptsSpecialConditions()
        assertRejected(engine.calculatePremium(
            restrictivePolicy,                    // acceptsSpecialConditions: F
            createHighRiskApplicant(),           // hasSpecialConditions: T
            standardContext
        ), "Special conditions not accepted");
        
        assertApproved(engine.calculatePremium(
            permissivePolicy,                    // acceptsSpecialConditions: T
            createHighRiskApplicant(),           // hasSpecialConditions: T  
            standardContext
        ));
        
        assertApproved(engine.calculatePremium(
            restrictivePolicy,                   // acceptsSpecialConditions: F
            createStandardApplicant(),           // hasSpecialConditions: F
            standardContext
        ));
        
        // 3. 最大保険料制限（手動審査フラグ）
        // 条件: finalPremium > maxPremium
        PremiumCalculationResult result = engine.calculatePremium(
            lowLimitPolicy,                      // maxPremium設定
            createHighRiskApplicant(),           // 高保険料となる申請者
            createContext(true)                  // manualReviewAllowed: T
        );
        assertApproved(result);
        assertTrue(result.getCalculation().requiresManualReview());
        
        assertRejected(engine.calculatePremium(
            lowLimitPolicy,                      // maxPremium設定
            createHighRiskApplicant(),           // 高保険料となる申請者  
            createContext(false)                 // manualReviewAllowed: F
        ), "Premium exceeds maximum allowed");
    }
    
    // === Phase 2: 保険料計算ロジックの条件網羅 ===
    
    @Test
    public void testPremiumFactors_ConditionCoverage() {
        InsurancePremiumEngine engine = new InsurancePremiumEngine();
        
        // 年齢係数の全分岐テスト
        testAgeFactor_AllBranches(engine);
        
        // 健康状態評価の条件網羅
        testHealthFactor_ConditionCoverage(engine);
        
        // 地域要因の条件網羅
        testRegionFactor_ConditionCoverage(engine);
        
        // 支払い条件の条件網羅
        testPaymentFactor_ConditionCoverage(engine);
        
        // 割引条件の条件網羅
        testDiscountFactor_ConditionCoverage(engine);
    }
    
    private void testHealthFactor_ConditionCoverage(InsurancePremiumEngine engine) {
        // 健康リスク条件の組み合わせテスト
        // 個別条件: hasSmoking, hasChronicDisease, hasHazardousJob
        
        // 全リスクなし
        PremiumCalculationResult noRisk = engine.calculatePremium(
            standardPolicy,
            createApplicant(30).setSmoking(false).setChronicDisease(false).setHazardousJob(false),
            standardContext
        );
        assertEquals(1.0, getHealthFactor(noRisk), 0.01);
        
        // 喫煙のみ（riskLevel = 2）
        PremiumCalculationResult smokingOnly = engine.calculatePremium(
            standardPolicy,
            createApplicant(30).setSmoking(true).setChronicDisease(false).setHazardousJob(false),
            standardContext
        );
        assertEquals(1.3, getHealthFactor(smokingOnly), 0.01); // 低リスク
        
        // 慢性疾患のみ（riskLevel = 3）  
        PremiumCalculationResult diseaseOnly = engine.calculatePremium(
            standardPolicy,
            createApplicant(30).setSmoking(false).setChronicDisease(true).setHazardousJob(false),
            standardContext
        );
        assertEquals(1.8, getHealthFactor(diseaseOnly), 0.01); // 中リスク
        
        // 全リスク要因（riskLevel = 7）
        PremiumCalculationResult allRisks = engine.calculatePremium(
            standardPolicy,
            createApplicant(30).setSmoking(true).setChronicDisease(true).setHazardousJob(true),
            standardContext
        );
        assertEquals(2.5, getHealthFactor(allRisks), 0.01); // 高リスク
        
        // 健康割引条件
        // 条件: hasHealthCertificate && lastMedicalCheckup.isAfter(currentDate - 1year)
        PremiumCalculationResult healthDiscount = engine.calculatePremium(
            standardPolicy,
            createApplicant(30)
                .setSmoking(false).setChronicDisease(false).setHazardousJob(false)
                .setHealthCertificate(true).setLastMedicalCheckup(LocalDate.now().minusMonths(6)),
            standardContext
        );
        assertEquals(0.9, getHealthFactor(healthDiscount), 0.01);
        
        // 健康証明書期限切れ
        PremiumCalculationResult expiredHealth = engine.calculatePremium(
            standardPolicy,
            createApplicant(30)
                .setSmoking(false).setChronicDisease(false).setHazardousJob(false)
                .setHealthCertificate(true).setLastMedicalCheckup(LocalDate.now().minusYears(2)),
            standardContext
        );
        assertEquals(1.0, getHealthFactor(expiredHealth), 0.01); // 割引なし
    }
    
    private void testRegionFactor_ConditionCoverage(InsurancePremiumEngine engine) {
        // 地域リスク条件の網羅
        // 個別条件: region.equals("DISASTER_PRONE"), region.equals("HIGH_CRIME"), 
        //          region.equals("URBAN") && crimeRate > 0.05
        
        // 災害多発地域
        testRegionCondition(engine, "DISASTER_PRONE", 0.02, 1.4);
        
        // 高犯罪地域
        testRegionCondition(engine, "HIGH_CRIME", 0.02, 1.4);
        
        // 都市部高犯罪率
        testRegionCondition(engine, "URBAN", 0.06, 1.4);  // crimeRate > 0.05: T
        
        // 都市部低犯罪率
        testRegionCondition(engine, "URBAN", 0.04, 1.0);  // crimeRate > 0.05: F
        
        // 農村部医療施設あり
        PremiumCalculationResult ruralWithMedical = engine.calculatePremium(
            standardPolicy,
            createApplicant(30).setAddress(createAddress("RURAL", 0.01, true)), // hasNearbyMedicalFacility: T
            standardContext
        );
        assertEquals(0.95, getRegionFactor(ruralWithMedical), 0.01);
        
        // 農村部医療施設なし
        PremiumCalculationResult ruralWithoutMedical = engine.calculatePremium(
            standardPolicy,
            createApplicant(30).setAddress(createAddress("RURAL", 0.01, false)), // hasNearbyMedicalFacility: F
            standardContext
        );
        assertEquals(1.0, getRegionFactor(ruralWithoutMedical), 0.01);
    }
    
    // === Phase 3: 複合割引条件の効率的テスト ===
    
    @Test
    public void testComplexDiscountConditions_OptimizedCoverage() {
        InsurancePremiumEngine engine = new InsurancePremiumEngine();
        
        // 家族割引の複合条件
        // (familySize >= 3 && hasSpouseInsured) || (familySize >= 4)
        
        // 条件1: familySize >= 3 && hasSpouseInsured
        assertDiscountApplied(engine, 
            createApplicant(30).setFamilySize(3).setSpouseInsured(true),  // familySize >= 3: T, hasSpouseInsured: T
            "family discount case 1"
        );
        
        // 条件2: familySize >= 4
        assertDiscountApplied(engine,
            createApplicant(30).setFamilySize(4).setSpouseInsured(false), // familySize >= 4: T, hasSpouseInsured: F
            "family discount case 2"
        );
        
        // 両条件False
        assertNoDiscount(engine,
            createApplicant(30).setFamilySize(2).setSpouseInsured(false), // familySize < 3, familySize < 4
            "no family discount"
        );
        
        // 既契約者割引の複合条件
        // isExistingCustomer && customerYears >= 5 && !hasClaimHistory
        
        // 全条件True
        assertLoyaltyDiscount(engine,
            createApplicant(30)
                .setExistingCustomer(true).setCustomerYears(7).setClaimHistory(false),
            "existing customer discount"
        );
        
        // claimHistory条件のFalse
        assertNoLoyaltyDiscount(engine,
            createApplicant(30)
                .setExistingCustomer(true).setCustomerYears(7).setClaimHistory(true), // hasClaimHistory: T
            "existing customer with claims"
        );
        
        // 複合割引（家族 + 既契約者）
        PremiumCalculationResult combinedDiscount = engine.calculatePremium(
            standardPolicy,
            createApplicant(30)
                .setFamilySize(4).setSpouseInsured(true)          // 家族割引条件
                .setExistingCustomer(true).setCustomerYears(6).setClaimHistory(false), // 既契約者割引条件
            standardContext
        );
        assertEquals(0.85, getLoyaltyFactor(combinedDiscount), 0.01); // 両方割引
    }
    
    // === ヘルパーメソッド（テスト効率化）===
    
    private ApplicantBuilder createApplicant(int age) {
        return new ApplicantBuilder().setAge(age);
    }
    
    private void testRegionCondition(InsurancePremiumEngine engine, String region, 
                                   double crimeRate, double expectedFactor) {
        PremiumCalculationResult result = engine.calculatePremium(
            standardPolicy,
            createApplicant(30).setAddress(createAddress(region, crimeRate, false)),
            standardContext
        );
        assertEquals(expectedFactor, getRegionFactor(result), 0.01);
    }
    
    // Fluent Builder Pattern for Test Data
    private static class ApplicantBuilder {
        private Applicant applicant = new Applicant();
        
        public ApplicantBuilder setAge(int age) {
            applicant.setAge(age);
            return this;
        }
        
        public ApplicantBuilder setSmoking(boolean smoking) {
            applicant.setSmoking(smoking);
            return this;
        }
        
        // ... 他のsetterメソッド
        
        public Applicant build() {
            return applicant;
        }
        
        // 暗黙的変換のためのメソッド
        public static implicit operator Applicant(ApplicantBuilder builder) {
            return builder.build();
        }
    }
}
```

### 📊 実務での条件網羅実装戦略

#### 💡 1. 段階的導入アプローチ
```markdown
## 3段階条件網羅導入計画

### Phase 1: クリティカルパス（2週間）
- 契約成立可否に関わる条件（年齢、特別条件等）
- 目標: 高リスク条件の100%網羅

### Phase 2: 計算ロジック（4週間）  
- 保険料計算に関わる主要因子
- 目標: 主要計算ロジックの90%網羅

### Phase 3: 割引・特典（2週間）
- 各種割引・特典の適用条件
- 目標: 顧客影響度の高い条件の80%網羅
```

#### 💡 2. 効率化手法の活用
```java
// パラメータ化テストによる効率化
@ParameterizedTest
@CsvSource({
    "17, true, false",     // 年齢制限: age < 18
    "86, true, false",     // 年齢制限: age > 85  
    "30, false, true",     // 正常範囲
    "25, false, true",     // 境界値
    "65, false, true"      // 境界値
})
public void testAgeValidation_ParameterizedConditionCoverage(
    int age, boolean expectRejected, boolean expectApproved) {
    
    PremiumCalculationResult result = engine.calculatePremium(
        standardPolicy, createApplicant(age), standardContext
    );
    
    if (expectRejected) {
        assertRejected(result);
    } else if (expectApproved) {
        assertApproved(result);
    }
}
```

---

## 🎯 上級レベルでの重要な実装ポイント

### 💡 1. 実用性とのバランス
- **完全網羅の放棄**: 理論上の100%より実用的な80-90%を目指す
- **リスクベース優先**: ビジネス影響度の高い条件を重点的に網羅
- **段階的導入**: 一度にすべての条件を網羅しようとしない

### 💡 2. テスト保守性の確保
- **テストデータファクトリー**: 複雑なテストデータ作成の効率化
- **条件マッピング**: 個別条件とテストケースの対応関係の文書化
- **自動化戦略**: 条件網羅測定の自動化とCI/CD統合

### 💡 3. チーム内での知識共有
- **条件分析ワークショップ**: 複雑な条件の共同分析
- **ベストプラクティス共有**: 効率的な条件網羅手法の横展開
- **レビュープロセス**: 条件網羅品質のピアレビュー

---

## 🚀 次のステップ

上級演習を完了したら、「05_追加演習・補強練習.md」でさらなるスキル向上を図り、最終的に「06_実務適用ガイド.md」で実際のプロジェクトでの活用方法を学習しましょう。

実務レベルの条件網羅スキルを身につけて、複雑なビジネスロジックの品質確保に貢献していきます！
