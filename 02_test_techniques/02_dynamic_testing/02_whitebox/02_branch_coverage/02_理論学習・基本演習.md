# 📚 分岐網羅（Branch Coverage）- 理論学習・基本演習

## 🎯 学習目標
- 分岐網羅の理論を正確に理解する
- 分岐網羅率の計算方法を習得する
- 基本的なテストケース設計ができるようになる

---

## 📊 分岐網羅の理論

### 🔍 分岐（Branch）とは

#### 💡 分岐の定義
プログラムの実行フローが複数の経路に分かれる箇所を**分岐**と呼びます。

#### 📋 分岐の種類
```java
// 1. if文
if (condition) {
    // True分岐
} else {
    // False分岐
}

// 2. while文  
while (condition) {    // 条件評価
    // ループ内（True分岐）
}
// ループ外（False分岐）

// 3. for文
for (int i = 0; i < 10; i++) {  // 条件評価
    // ループ内（True分岐）
}
// ループ外（False分岐）

// 4. switch文
switch (value) {
    case 1:           // 分岐1
        break;
    case 2:           // 分岐2
        break;
    default:          // デフォルト分岐
}

// 5. 三項演算子
result = condition ? valueA : valueB;  // True/False分岐

// 6. 短絡評価
if (obj != null && obj.isValid()) {    // 複数の条件評価点
    // 処理
}
```

### 📐 分岐網羅率の計算

#### 💡 計算式
```
分岐網羅率 = (実行された分岐数 / 総分岐数) × 100%
```

#### 📊 計算例
```java
public class TemperatureClassifier {
    public String classify(int temperature) {
        String result;
        
        if (temperature >= 30) {        // 分岐1: True/False
            result = "Hot";
        } else if (temperature >= 20) {  // 分岐2: True/False  
            result = "Warm";
        } else if (temperature >= 10) {  // 分岐3: True/False
            result = "Cool";
        } else {
            result = "Cold";
        }
        
        if (temperature > 35) {         // 分岐4: True/False
            result += " (Extreme)";
        }
        
        return result;
    }
}
```

**総分岐数**: 8分岐（4つのif文 × 2（True/False））

**テストケース分析**：
- `classify(25)`: 分岐1-False, 分岐2-True, 分岐3-?, 分岐4-False
- 実行分岐数: 3分岐
- 分岐網羅率: 3/8 × 100% = **37.5%**

---

## 💪 基本演習 1：単純な条件分岐

### 📝 問題
以下のメソッドで**100%分岐網羅**を達成するテストケースを設計してください。

```java
public class AgeValidator {
    public boolean isAdult(int age) {
        if (age >= 18) {
            return true;
        } else {
            return false;
        }
    }
}
```

### 🤔 分析手順
1. **分岐の特定**
2. **必要なテストケース数の算出**
3. **テストケースの設計**

#### ステップ1: 分岐の特定
```java
if (age >= 18) {    // 分岐1
    return true;    // 分岐1-True
} else {
    return false;   // 分岐1-False
}
```
- **総分岐数**: 2（True/False）

#### ステップ2: 必要なテストケース
- 分岐1-True: `age >= 18` の場合
- 分岐1-False: `age < 18` の場合

#### ステップ3: テストケース設計
```java
@Test
public void testIsAdult_BranchCoverage() {
    AgeValidator validator = new AgeValidator();
    
    // 分岐1-True: 18歳以上
    assertTrue(validator.isAdult(18));   // 境界値
    assertTrue(validator.isAdult(25));   // 代表値
    
    // 分岐1-False: 18歳未満
    assertFalse(validator.isAdult(17));  // 境界値
    assertFalse(validator.isAdult(10));  // 代表値
}
```

### ✅ 解答
**必要最小限のテストケース**：
```java
@Test
public void testIsAdult_MinimalBranchCoverage() {
    AgeValidator validator = new AgeValidator();
    
    // 分岐1-True
    assertTrue(validator.isAdult(18));
    
    // 分岐1-False  
    assertFalse(validator.isAdult(17));
}
```
**分岐網羅率**: 2/2 × 100% = **100%**

---

## 💪 基本演習 2：ネストした条件分岐

### 📝 問題
以下のメソッドで**100%分岐網羅**を達成するテストケースを設計してください。

```java
public class DiscountCalculator {
    public double getDiscount(boolean isMember, int purchaseAmount) {
        double discount = 0.0;
        
        if (isMember) {                    // 分岐1
            if (purchaseAmount >= 1000) {   // 分岐2
                discount = 0.20;
            } else {
                discount = 0.10;
            }
        } else {
            if (purchaseAmount >= 1000) {   // 分岐3
                discount = 0.05;
            }
            // else節なし（discount = 0.0のまま）
        }
        
        return discount;
    }
}
```

### 🤔 分析手順

#### ステップ1: 分岐の特定と番号付け
```java
if (isMember) {                    // 分岐1: True/False
    if (purchaseAmount >= 1000) {   // 分岐2: True/False
        discount = 0.20;           // 分岐2-True
    } else {
        discount = 0.10;           // 分岐2-False
    }
} else {                           // 分岐1-False
    if (purchaseAmount >= 1000) {   // 分岐3: True/False
        discount = 0.05;           // 分岐3-True
    }
    // 分岐3-False（暗黙）
}
```

#### ステップ2: 分岐の整理
- **分岐1**: `isMember` → True/False
- **分岐2**: `isMember=True` 時の `purchaseAmount >= 1000` → True/False
- **分岐3**: `isMember=False` 時の `purchaseAmount >= 1000` → True/False
- **総分岐数**: 6分岐

#### ステップ3: テストケース設計
```java
@Test
public void testGetDiscount_BranchCoverage() {
    DiscountCalculator calc = new DiscountCalculator();
    
    // 分岐1-True, 分岐2-True
    assertEquals(0.20, calc.getDiscount(true, 1000), 0.001);
    
    // 分岐1-True, 分岐2-False
    assertEquals(0.10, calc.getDiscount(true, 500), 0.001);
    
    // 分岐1-False, 分岐3-True  
    assertEquals(0.05, calc.getDiscount(false, 1000), 0.001);
    
    // 分岐1-False, 分岐3-False
    assertEquals(0.0, calc.getDiscount(false, 500), 0.001);
}
```

### ✅ 解答
**分岐網羅達成**: 6/6 = **100%**

**テストケース最小セット**：
1. `getDiscount(true, 1000)` → 0.20
2. `getDiscount(true, 500)` → 0.10  
3. `getDiscount(false, 1000)` → 0.05
4. `getDiscount(false, 500)` → 0.0

---

## 💪 基本演習 3：ループと分岐の組み合わせ

### 📝 問題
以下のメソッドで**100%分岐網羅**を達成するテストケースを設計してください。

```java
public class NumberProcessor {
    public List<Integer> processPositiveNumbers(List<Integer> numbers) {
        List<Integer> result = new ArrayList<>();
        
        if (numbers == null) {           // 分岐1
            return result;
        }
        
        for (Integer num : numbers) {    // 分岐2: ループ実行/非実行
            if (num != null && num > 0) { // 分岐3
                result.add(num * 2);
            }
        }
        
        if (result.isEmpty()) {          // 分岐4
            result.add(-1);  // エラー指示
        }
        
        return result;
    }
}
```

### 🤔 分析手順

#### ステップ1: 分岐の特定
```java
if (numbers == null) {           // 分岐1: True/False
    return result;
}

for (Integer num : numbers) {    // 分岐2: ループ実行/非実行
    if (num != null && num > 0) { // 分岐3: True/False
        result.add(num * 2);
    }
}

if (result.isEmpty()) {          // 分岐4: True/False
    result.add(-1);
}
```

#### ステップ2: 必要な分岐パターン
- **分岐1-True**: `numbers == null`
- **分岐1-False**: `numbers != null`
- **分岐2-True**: ループが1回以上実行
- **分岐2-False**: ループが実行されない（空リスト）
- **分岐3-True**: `num != null && num > 0`
- **分岐3-False**: `num == null || num <= 0`
- **分岐4-True**: `result.isEmpty()`
- **分岐4-False**: `!result.isEmpty()`

#### ステップ3: テストケース設計
```java
@Test
public void testProcessPositiveNumbers_BranchCoverage() {
    NumberProcessor processor = new NumberProcessor();
    
    // 分岐1-True: null入力
    List<Integer> result1 = processor.processPositiveNumbers(null);
    assertEquals(Arrays.asList(), result1);
    
    // 分岐2-False, 分岐4-True: 空リスト
    List<Integer> result2 = processor.processPositiveNumbers(Arrays.asList());
    assertEquals(Arrays.asList(-1), result2);
    
    // 分岐2-True, 分岐3-False, 分岐4-True: 正数なし
    List<Integer> result3 = processor.processPositiveNumbers(Arrays.asList(null, -1, 0));
    assertEquals(Arrays.asList(-1), result3);
    
    // 分岐2-True, 分岐3-True, 分岐4-False: 正数あり
    List<Integer> result4 = processor.processPositiveNumbers(Arrays.asList(1, 2, 3));
    assertEquals(Arrays.asList(2, 4, 6), result4);
    
    // 混合ケース: 分岐3の両方をテスト
    List<Integer> result5 = processor.processPositiveNumbers(Arrays.asList(-1, 2, null, 3));
    assertEquals(Arrays.asList(4, 6), result5);
}
```

### ✅ 解答検証
**総分岐数**: 8分岐
**テストケースで実行される分岐**: 全8分岐
**分岐網羅率**: 8/8 = **100%**

---

## 💪 基本演習 4：switch文の分岐網羅

### 📝 問題
以下のメソッドで**100%分岐網羅**を達成するテストケースを設計してください。

```java
public class DayTypeClassifier {
    public String getDayType(int dayOfWeek) {
        String result;
        
        switch (dayOfWeek) {
            case 1:
            case 7:
                result = "Weekend";
                break;
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
                result = "Weekday";
                break;
            default:
                result = "Invalid";
        }
        
        if (result.equals("Weekend")) {    // 分岐: True/False
            result += " (Relax time!)";
        }
        
        return result;
    }
}
```

### 🤔 分析手順

#### ステップ1: switch文の分岐特定
switch文では、各caseとdefaultが分岐となります：
- **分岐1**: `case 1 || case 7` → "Weekend"
- **分岐2**: `case 2,3,4,5,6` → "Weekday"
- **分岐3**: `default` → "Invalid"
- **分岐4**: `result.equals("Weekend")` → True/False

#### ステップ2: テストケース設計
```java
@Test
public void testGetDayType_BranchCoverage() {
    DayTypeClassifier classifier = new DayTypeClassifier();
    
    // 分岐1: Weekend case (and 分岐4-True)
    assertEquals("Weekend (Relax time!)", classifier.getDayType(1));
    assertEquals("Weekend (Relax time!)", classifier.getDayType(7));
    
    // 分岐2: Weekday case (and 分岐4-False)
    assertEquals("Weekday", classifier.getDayType(2));
    assertEquals("Weekday", classifier.getDayType(6));
    
    // 分岐3: Default case (and 分岐4-False)
    assertEquals("Invalid", classifier.getDayType(0));
    assertEquals("Invalid", classifier.getDayType(8));
}
```

### ✅ 解答
**最小必要テストケース**：
```java
@Test
public void testGetDayType_MinimalBranchCoverage() {
    DayTypeClassifier classifier = new DayTypeClassifier();
    
    assertEquals("Weekend (Relax time!)", classifier.getDayType(1));  // 分岐1 + 分岐4-True
    assertEquals("Weekday", classifier.getDayType(2));                // 分岐2 + 分岐4-False
    assertEquals("Invalid", classifier.getDayType(0));                // 分岐3 + 分岐4-False
}
```
**分岐網羅率**: 100%

---

## 🔍 分岐網羅の実践ポイント

### 📊 効果的な分岐特定方法

#### 💡 コードの可視化
```java
// 分岐番号を付けた解析例
public boolean validate(String input) {
    if (input == null) {              // 分岐1: T/F
        return false;
    }
    
    if (input.length() < 3) {         // 分岐2: T/F
        return false;
    }
    
    for (char c : input.toCharArray()) {  // 分岐3: ループ実行/非実行
        if (!Character.isLetterOrDigit(c)) {  // 分岐4: T/F
            return false;
        }
    }
    
    return true;
}
```

**分岐一覧**：
1. 分岐1-True: `input == null`
2. 分岐1-False: `input != null`
3. 分岐2-True: `input.length() < 3`
4. 分岐2-False: `input.length() >= 3`
5. 分岐3-True: ループ実行（文字数 > 0）
6. 分岐3-False: ループ非実行（文字数 = 0）
7. 分岐4-True: `!Character.isLetterOrDigit(c)`
8. 分岐4-False: `Character.isLetterOrDigit(c)`

### 🎯 テストケース最適化

#### 💡 効率的なテストケース設計
```java
@Test
public void testValidate_OptimizedBranchCoverage() {
    // 複数分岐を1つのテストケースでカバー
    assertFalse(validate(null));           // 分岐1-True
    assertFalse(validate("ab"));           // 分岐1-False, 分岐2-True  
    assertFalse(validate(""));             // 分岐1-False, 分岐2-True, 分岐3-False
    assertFalse(validate("abc!"));         // 分岐1-False, 分岐2-False, 分岐3-True, 分岐4-True
    assertTrue(validate("abc123"));        // 分岐1-False, 分岐2-False, 分岐3-True, 分岐4-False
}
```

### 📈 カバレッジツールの活用

#### 💡 JaCoCo での分岐網羅測定例
```xml
<!-- Maven設定例 -->
<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.7</version>
    <executions>
        <execution>
            <goals>
                <goal>prepare-agent</goal>
            </goals>
        </execution>
        <execution>
            <id>report</id>
            <phase>test</phase>
            <goals>
                <goal>report</goal>
            </goals>
        </execution>
        <execution>
            <id>check</id>
            <goals>
                <goal>check</goal>
            </goals>
            <configuration>
                <rules>
                    <rule>
                        <element>CLASS</element>
                        <limits>
                            <limit>
                                <counter>BRANCH</counter>
                                <value>COVEREDRATIO</value>
                                <minimum>0.90</minimum>  <!-- 90%分岐網羅 -->
                            </limit>
                        </limits>
                    </rule>
                </rules>
            </configuration>
        </execution>
    </executions>
</plugin>
```

---

## 🎯 まとめ：分岐網羅の要点

### ✅ 習得すべきポイント
1. **分岐の定義**: 条件分岐、ループ、switch文等の分岐箇所の特定
2. **True/False両方**: 各分岐で真偽両方の経路をテスト
3. **網羅率計算**: (実行分岐数/総分岐数) × 100%
4. **最小テストケース**: 効率的な分岐網羅達成方法

### 🔍 よくある間違い
- ❌ 命令網羅100%なら分岐網羅も100%
- ❌ 分岐網羅は条件網羅と同じ
- ❌ すべての条件組み合わせをテストする必要がある

### 💡 実践のコツ
- 分岐を番号付けして整理する
- カバレッジツールで可視化する
- 最小限のテストケースで最大の効果を狙う

---

## 🚀 次のステップ

理論と基本演習を完了したら、**「03_習得レベル確認.md」**で理解度をチェックしましょう！

分岐網羅の基礎をしっかり固めてから、より高度な応用に進んでいきます。
