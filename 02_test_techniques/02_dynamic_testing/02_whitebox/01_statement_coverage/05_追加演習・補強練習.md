# 📚 命令網羅（Statement Coverage）- 追加演習・補強練習

## 🎯 この演習の目的
- 命令網羅の理解を深める多様なパターン演習
- 複雑なコード構造での命令網羅測定練習
- 実務でよくある問題パターンの習得

---

## 💪 補強演習 1：エラーハンドリングと命令網羅

### 📝 問題
以下のエラーハンドリングを含むメソッドの命令網羅を達成するテストケースを設計してください。

```java
public class FileProcessor {
    public String processFile(String filePath, boolean validateFormat) {
        String result = "";
        
        if (filePath == null || filePath.isEmpty()) {
            throw new IllegalArgumentException("ファイルパスが無効です");
        }
        
        try {
            File file = new File(filePath);
            if (!file.exists()) {
                return "ファイルが存在しません";
            }
            
            if (validateFormat) {
                if (!filePath.endsWith(".txt")) {
                    return "サポートされていないファイル形式です";
                }
            }
            
            // ファイル読み込み処理（仮想）
            result = "ファイル処理完了: " + filePath;
            
        } catch (SecurityException e) {
            return "ファイルアクセスが拒否されました";
        } catch (Exception e) {
            return "予期しないエラーが発生しました";
        }
        
        return result;
    }
}
```

### ✅ 解答
**100% 命令網羅に必要なテストケース**：

1. **正常ケース（既存ファイル、フォーマット検証なし）**
   ```java
   @Test
   public void testProcessFile_ExistingFile_NoValidation() {
       // given
       String filePath = "existing_file.txt";
       boolean validateFormat = false;
       
       // when
       String result = processor.processFile(filePath, validateFormat);
       
       // then
       assertEquals("ファイル処理完了: existing_file.txt", result);
   }
   ```

2. **正常ケース（既存ファイル、フォーマット検証あり）**
   ```java
   @Test
   public void testProcessFile_ExistingTxtFile_WithValidation() {
       // given
       String filePath = "existing_file.txt";
       boolean validateFormat = true;
       
       // when
       String result = processor.processFile(filePath, validateFormat);
       
       // then
       assertEquals("ファイル処理完了: existing_file.txt", result);
   }
   ```

3. **null パスエラー**
   ```java
   @Test
   public void testProcessFile_NullPath_ThrowsException() {
       // when & then
       assertThrows(IllegalArgumentException.class, 
           () -> processor.processFile(null, false));
   }
   ```

4. **空パスエラー**
   ```java
   @Test
   public void testProcessFile_EmptyPath_ThrowsException() {
       // when & then
       assertThrows(IllegalArgumentException.class, 
           () -> processor.processFile("", false));
   }
   ```

5. **ファイル未存在**
   ```java
   @Test
   public void testProcessFile_NonExistentFile() {
       // given
       String filePath = "non_existent_file.txt";
       
       // when
       String result = processor.processFile(filePath, false);
       
       // then
       assertEquals("ファイルが存在しません", result);
   }
   ```

6. **不正フォーマット**
   ```java
   @Test
   public void testProcessFile_InvalidFormat_WithValidation() {
       // given
       String filePath = "existing_file.pdf";  // 既存だがPDFファイル
       boolean validateFormat = true;
       
       // when
       String result = processor.processFile(filePath, validateFormat);
       
       // then
       assertEquals("サポートされていないファイル形式です", result);
   }
   ```

---

## 💪 補強演習 2：ループと条件の組み合わせ

### 📝 問題
以下のメソッドで100%命令網羅を達成するテストケースを設計してください。

```java
public class DataProcessor {
    public List<String> processDataList(List<Integer> numbers, int threshold) {
        List<String> results = new ArrayList<>();
        
        if (numbers == null) {
            return results;  // 空リスト返却
        }
        
        for (Integer num : numbers) {
            if (num == null) {
                continue;  // null要素はスキップ
            }
            
            if (num > threshold) {
                results.add("HIGH: " + num);
            } else if (num == threshold) {
                results.add("EQUAL: " + num);
            } else {
                results.add("LOW: " + num);
            }
            
            // 特殊処理：負数の場合
            if (num < 0) {
                results.add("NEGATIVE: " + num);
            }
        }
        
        if (results.isEmpty()) {
            results.add("NO_VALID_DATA");
        }
        
        return results;
    }
}
```

### ✅ 解答
**100% 命令網羅に必要なテストケース**：

1. **nullリスト**
   ```java
   @Test
   public void testProcessDataList_NullList() {
       List<String> result = processor.processDataList(null, 10);
       assertTrue(result.isEmpty());
   }
   ```

2. **null要素を含むリスト**
   ```java
   @Test
   public void testProcessDataList_WithNullElements() {
       List<Integer> numbers = Arrays.asList(15, null, 5);
       List<String> result = processor.processDataList(numbers, 10);
       assertEquals(Arrays.asList("HIGH: 15", "LOW: 5"), result);
   }
   ```

3. **閾値より大きい値**
   ```java
   @Test
   public void testProcessDataList_HighValues() {
       List<Integer> numbers = Arrays.asList(15, 20);
       List<String> result = processor.processDataList(numbers, 10);
       assertEquals(Arrays.asList("HIGH: 15", "HIGH: 20"), result);
   }
   ```

4. **閾値と等しい値**
   ```java
   @Test
   public void testProcessDataList_EqualValue() {
       List<Integer> numbers = Arrays.asList(10);
       List<String> result = processor.processDataList(numbers, 10);
       assertEquals(Arrays.asList("EQUAL: 10"), result);
   }
   ```

5. **閾値より小さい値（正数）**
   ```java
   @Test
   public void testProcessDataList_LowPositiveValues() {
       List<Integer> numbers = Arrays.asList(5, 8);
       List<String> result = processor.processDataList(numbers, 10);
       assertEquals(Arrays.asList("LOW: 5", "LOW: 8"), result);
   }
   ```

6. **負数（特殊処理）**
   ```java
   @Test
   public void testProcessDataList_NegativeValues() {
       List<Integer> numbers = Arrays.asList(-5, -10);
       List<String> result = processor.processDataList(numbers, 10);
       assertEquals(Arrays.asList("LOW: -5", "NEGATIVE: -5", "LOW: -10", "NEGATIVE: -10"), result);
   }
   ```

7. **全null要素（NO_VALID_DATA パス）**
   ```java
   @Test
   public void testProcessDataList_AllNullElements() {
       List<Integer> numbers = Arrays.asList(null, null);
       List<String> result = processor.processDataList(numbers, 10);
       assertEquals(Arrays.asList("NO_VALID_DATA"), result);
   }
   ```

---

## 💪 補強演習 3：複雑な分岐構造

### 📝 問題
以下のユーザー認証メソッドで100%命令網羅を達成してください。

```java
public class UserAuthenticator {
    public AuthResult authenticate(String username, String password, boolean rememberMe) {
        AuthResult result = new AuthResult();
        
        // 基本検証
        if (username == null || username.trim().isEmpty()) {
            result.setStatus("INVALID_USERNAME");
            return result;
        }
        
        if (password == null || password.length() < 8) {
            result.setStatus("INVALID_PASSWORD");
            return result;
        }
        
        // ユーザー存在確認（仮想）
        if (!userExists(username)) {
            result.setStatus("USER_NOT_FOUND");
            return result;
        }
        
        // パスワード検証（仮想）
        if (!validatePassword(username, password)) {
            result.setStatus("AUTHENTICATION_FAILED");
            incrementFailedAttempts(username);
            return result;
        }
        
        // 成功処理
        result.setStatus("SUCCESS");
        result.setUsername(username);
        
        if (rememberMe) {
            result.setRememberToken(generateToken(username));
        }
        
        resetFailedAttempts(username);
        return result;
    }
    
    // 仮想メソッド（実装は省略）
    private boolean userExists(String username) { return true; }
    private boolean validatePassword(String username, String password) { return true; }
    private void incrementFailedAttempts(String username) { }
    private void resetFailedAttempts(String username) { }
    private String generateToken(String username) { return "token_" + username; }
}
```

### ✅ 解答・解説

この演習では、早期リターンが多用された複雑な分岐構造での命令網羅を学習します。

**必要なテストケース（7つ）**：

1. **null ユーザー名**
2. **空ユーザー名**
3. **null パスワード**
4. **短いパスワード**
5. **存在しないユーザー**
6. **パスワード不一致**
7. **認証成功（remember なし）**
8. **認証成功（remember あり）**

---

## 🔍 実務での命令網羅ポイント

### ⚡ 見落としやすい命令
1. **例外ハンドリング内の命令**
2. **ループ内のcontinue/break後の命令**
3. **早期リターン後の命令**
4. **finally ブロック内の命令**

### 🎯 効率的な命令網羅達成方法
1. **コードカバレッジツールの活用**
2. **実行されていない行の可視化**
3. **段階的なテストケース追加**
4. **例外パスの網羅的テスト**

### 📊 命令網羅の品質指標
- **90%以上**: 基本的な品質レベル
- **95%以上**: 高品質レベル
- **100%**: 理想的（ただし、到達不可能コードを除く）

---

## 🎯 次のステップ

この演習で命令網羅の実践スキルが向上しました。次は以下に進みましょう：

1. **分岐網羅（Branch Coverage）**: より高度な網羅基準
2. **条件網羅（Condition Coverage）**: 複雑な条件式の完全テスト
3. **複合網羅技法**: 複数の網羅基準の組み合わせ

実務では命令網羅を基礎として、より高度な網羅基準を適用していきます。
