# 🎯 条件網羅（Condition Coverage）- 学習準備・概要把握

## 🌟 条件網羅とは

### 📊 定義
**条件網羅（Condition Coverage）**とは、プログラム内のすべての複合条件において、各個別条件（atomic condition）が真（True）と偽（False）の両方の値を少なくとも1回は取ることを確認するテスト技法です。

### 🔍 具体例で理解する
```java
public class UserAccessValidator {
    public boolean canAccess(User user, Resource resource) {
        // 複合条件：3つの個別条件を含む
        if (user != null && user.isActive() && resource.isPublic()) {
            return true;
        }
        return false;
    }
}
```

**条件網羅を達成するには**：
- **個別条件1**: `user != null` → True と False の両方をテスト
- **個別条件2**: `user.isActive()` → True と False の両方をテスト
- **個別条件3**: `resource.isPublic()` → True と False の両方をテスト

### 📈 分岐網羅との重要な違い

#### 🔄 分岐網羅の場合
```java
// 分岐網羅では「複合条件全体」のTrue/Falseをテスト
@Test
public void testCanAccess_BranchCoverage() {
    // True分岐: 複合条件全体がtrueになるケース
    assertTrue(validator.canAccess(activeUser, publicResource));
    
    // False分岐: 複合条件全体がfalseになるケース  
    assertFalse(validator.canAccess(null, publicResource));
}
// → 分岐網羅100%達成だが、個別条件2と3のFalseは未テスト
```

#### 🎯 条件網羅の場合
```java
// 条件網羅では「各個別条件」のTrue/Falseをテスト
@Test
public void testCanAccess_ConditionCoverage() {
    User activeUser = createActiveUser();
    User inactiveUser = createInactiveUser();
    Resource publicResource = createPublicResource();
    Resource privateResource = createPrivateResource();
    
    // 条件1-True: user != null
    assertTrue(validator.canAccess(activeUser, publicResource));
    
    // 条件1-False: user == null
    assertFalse(validator.canAccess(null, publicResource));
    
    // 条件2-True: user.isActive() == true
    assertTrue(validator.canAccess(activeUser, publicResource));
    
    // 条件2-False: user.isActive() == false
    assertFalse(validator.canAccess(inactiveUser, publicResource));
    
    // 条件3-True: resource.isPublic() == true
    assertTrue(validator.canAccess(activeUser, publicResource));
    
    // 条件3-False: resource.isPublic() == false
    assertFalse(validator.canAccess(activeUser, privateResource));
}
```

## 🆚 ホワイトボックス技法の階層関係

### 📊 厳しさの順序（緩い → 厳しい）
```
命令網羅 → 分岐網羅 → 条件網羅 → MC/DC → 複数条件網羅
```

### 📈 包含関係
- **条件網羅100%** ⇒ **分岐網羅100%** ⇒ **命令網羅100%**
- **逆は必ずしも成立しない**

### 🔍 比較例
```java
public boolean validatePassword(String password, boolean isAdmin) {
    if (password != null && password.length() >= 8 && (isAdmin || password.contains("@"))) {
        return true;
    }
    return false;
}
```

| テスト技法 | テスト要求 | テストケース例 |
|-----------|-----------|---------------|
| **命令網羅** | すべての命令実行 | `validatePassword("password@", true)` |
| **分岐網羅** | 複合条件のT/F | 上記 + `validatePassword(null, false)` |
| **条件網羅** | 各条件のT/F | 6個の個別条件 × 2 = 12パターン |

## 🎯 なぜ条件網羅が重要なのか

### 🐛 条件網羅で発見できるバグ例

#### 例1: 条件の論理エラー
```java
// バグのあるコード：AND と OR の混同
public boolean isEligibleForDiscount(Customer customer) {
    // 意図：「VIPかつ（購入額1万円以上または3回以上購入）」
    // 実装：誤った論理演算子
    if (customer.isVIP() && customer.getTotalPurchase() >= 10000 || customer.getPurchaseCount() >= 3) {
        return true;
    }
    return false;
}
```

**分岐網羅のみ**: 複合条件のTrue/Falseのみテスト → バグ未発見
**条件網羅**: 各条件の詳細テスト → 論理エラー発見

#### 例2: 短絡評価の副作用
```java
public boolean processUserAction(User user, String action) {
    // 意図しない副作用：ログ記録が条件によってスキップされる
    if (user != null && user.isActive() && logAction(user, action)) {
        return performAction(user, action);
    }
    return false;
}

private boolean logAction(User user, String action) {
    // ログ記録（副作用あり）
    logger.info("User {} performed {}", user.getName(), action);
    return true;
}
```

**条件網羅**: `user == null` のケースで `logAction` が呼ばれないことを確認

### 💼 条件網羅が特に有効な場面

#### 🏦 金融・保険システム
```java
public boolean isLoanApproved(Applicant applicant) {
    // 複雑な承認条件
    if (applicant.getCreditScore() >= 700 && 
        applicant.getIncome() >= 50000 && 
        applicant.getEmploymentYears() >= 2 &&
        !applicant.hasBankruptcy()) {
        return true;
    }
    return false;
}
// → 各承認条件の詳細テストが必要
```

#### 🔒 セキュリティシステム
```java
public boolean hasAccess(User user, Resource resource, String operation) {
    // セキュリティ条件
    if (user.isAuthenticated() && 
        user.hasRole(resource.getRequiredRole()) && 
        resource.isAccessible() &&
        isOperationAllowed(user, operation)) {
        return true;
    }
    return false;
}
// → セキュリティ条件の厳密なテストが必要
```

## 🎯 学習目標

### 📚 この学習で身につけるスキル

#### 🔍 理論理解
- [ ] 条件網羅の正確な定義を説明できる
- [ ] 複合条件内の個別条件を特定できる
- [ ] 分岐網羅・命令網羅との違いを具体例で示せる
- [ ] 条件網羅率の計算方法を理解している
- [ ] 短絡評価が条件網羅に与える影響を説明できる

#### 🛠️ 実践スキル
- [ ] 複雑な複合条件でも各条件のTrue/Falseをテストできる
- [ ] 効率的な条件網羅テストケースを設計できる
- [ ] カバレッジツールで条件網羅を測定できる
- [ ] 条件網羅の課題（組み合わせ爆発等）を理解している
- [ ] 実務での適用可能性を判断できる

#### 🚀 応用能力
- [ ] プロジェクト特性に応じた適切な網羅目標を設定できる
- [ ] 分岐網羅との効果的な組み合わせができる
- [ ] MC/DC等のより高度な技法との関係を理解している
- [ ] 条件網羅の価値と制約をチームに説明できる

## 👥 このガイドの対象者

### ✅ 読むべき人
- **テストエンジニア（中級以上）**: より高度なテスト技法を学びたい
- **開発者（上級）**: 複雑なロジックの品質向上を目指す
- **QAリーダー**: チームの技術力向上を図りたい
- **プロジェクトマネージャー**: 高信頼性システムの品質基準を理解したい

### 📚 前提知識
- **必須**: 分岐網羅の完全理解と実践経験
- **必須**: 論理演算（AND、OR、NOT）の理解
- **推奨**: 複雑なビジネスロジックのテスト経験
- **推奨**: カバレッジツールの使用経験

## 🎯 具体的な成果物設定

### 📋 学習完了時の成果物

#### 📊 理論理解の確認
- [ ] 条件網羅の概念説明レポート（A4 2枚）
- [ ] 分岐網羅との比較分析表
- [ ] 複合条件の分析手法マニュアル
- [ ] 条件網羅率計算の演習解答

#### 🛠️ 実践スキルの証明
- [ ] 複雑な条件での個別条件特定演習
- [ ] 条件網羅を達成するテストケース設計
- [ ] 短絡評価を考慮したテスト戦略
- [ ] カバレッジツール活用レポート

#### 🚀 応用能力の実証
- [ ] 実務シナリオでの条件網羅適用計画
- [ ] 他技法との組み合わせ戦略書
- [ ] プロジェクト品質基準への組み込み提案
- [ ] 条件網羅の課題と対策レポート

### 📈 評価基準
- **合格基準**: 各演習で85%以上の正答率
- **優秀基準**: 実務適用可能なレベルでの理解と実践
- **指導者基準**: チームメンバーに技法の価値と制約を説明できる

## 🔄 学習の進め方

### 📚 効果的な学習方法

#### 🔍 段階的理解アプローチ
1. **概念理解**: 条件網羅の本質と価値の理解
2. **比較学習**: 分岐網羅との違いの明確化
3. **実践練習**: 簡単な複合条件から複雑な条件へ
4. **課題理解**: 実用性の限界と対策の理解

#### 💪 実践重視アプローチ
1. **多様な条件**: 様々なパターンの複合条件で練習
2. **ツール活用**: カバレッジ測定による理論と実践の統合
3. **実務応用**: 実際のプロジェクトコードでの練習
4. **制約理解**: 実用性とのバランスの体得

### ⏰ 学習ペース
- **集中学習**: 2日間で全体を学習（推奨）
- **分散学習**: 1週間で段階的に学習
- **継続学習**: 2週間でじっくり理解と実践

## 📊 条件網羅の実務価値と制約

### 💼 ビジネス価値
- **品質向上**: 複雑なロジックの詳細な検証
- **リスク軽減**: 条件の組み合わせによる想定外バグの防止
- **信頼性確保**: 高信頼性システムでの厳密な品質保証
- **保守性向上**: 条件変更時の影響範囲の把握

### ⚠️ 実務制約
- **複雑性**: 条件数増加による指数的テストケース増加
- **コスト**: 詳細度の高さに伴う工数増加
- **適用限界**: すべてのプロジェクトに適用できない
- **短絡評価**: 言語仕様による制約

### 🎯 適用判断基準
```markdown
## 条件網羅適用の判断マトリクス

| プロジェクト特性 | 条件網羅適用 | 理由 |
|-----------------|-------------|------|
| 金融・医療・航空 | 必須 | 高信頼性要求 |
| セキュリティ関連 | 推奨 | 厳密な条件検証 |
| 一般業務システム | 選択的 | コストと効果のバランス |
| プロトタイプ | 不要 | 開発速度優先 |
```

## 🔍 条件網羅の特殊な課題

### ⚡ 短絡評価の影響
```java
// 短絡評価により条件2が評価されない場合
if (user == null || user.getName() == null) {
    return false;
}
// user == null が true なら、user.getName() は評価されない
```

### 📈 組み合わせ爆発
```java
// 6個の条件 → 2^6 = 64通りの組み合わせ
if (c1 && c2 && c3 && c4 && c5 && c6) {
    // 処理
}
// 条件網羅：各条件のT/F = 12テストケース（最小）
// 複数条件網羅：全組み合わせ = 64テストケース
```

### 🎯 実用的なバランス
- **高リスク条件**: 条件網羅を適用
- **低リスク条件**: 分岐網羅で十分
- **コスト制約**: 重要度による優先順位付け

## 🎯 学習完了後の次のステップ

### 🔄 発展学習
- **MC/DC**: Modified Condition/Decision Coverage
- **複数条件網羅**: すべての条件組み合わせのテスト
- **パス網羅**: 実行可能な全経路のテスト

### 💼 実務応用
- **プロジェクト適用**: 実際の開発での段階的導入
- **チーム指導**: 技法の価値と制約の共有
- **品質基準**: 組織の品質基準への組み込み

---

## 🚀 次のアクション

準備ができたら **「02_理論学習・基本演習.md」** に進んで、条件網羅の具体的な学習を開始しましょう！

条件網羅は高度な技法ですが、複雑なビジネスロジックの品質確保には非常に価値の高いスキルです。段階的に習得していけば、必ず実務で活用できるようになります。

📖 **重要**: 学習中に分岐網羅の理解に不安を感じたら、いつでも `02_branch_coverage` に戻って復習してください。
