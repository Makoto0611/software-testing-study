# 💪 分岐網羅（Branch Coverage）- 追加演習・補強練習

## 🎯 補強練習の目的
- 分岐網羅の理解を多様なパターンで深める
- 実務でよく遭遇する複雑なケースの習得
- 効率的なテスト設計手法の定着

---

## 💪 補強演習 1：再帰処理と分岐網羅

### 📝 問題
以下の再帰的なディレクトリ検索メソッドで分岐網羅を達成してください。

```java
public class DirectorySearcher {
    private List<String> foundFiles = new ArrayList<>();
    private int maxDepth;
    
    public List<String> searchFiles(String directoryPath, String extension, 
                                   int maxSearchDepth, boolean includeHidden) {
        this.maxDepth = maxSearchDepth;
        this.foundFiles.clear();
        
        if (directoryPath == null || extension == null) {
            return foundFiles;
        }
        
        File directory = new File(directoryPath);
        if (!directory.exists() || !directory.isDirectory()) {
            return foundFiles;
        }
        
        searchRecursively(directory, extension, 0, includeHidden);
        return foundFiles;
    }
    
    private void searchRecursively(File directory, String extension, 
                                  int currentDepth, boolean includeHidden) {
        // 深度制限チェック
        if (currentDepth >= maxDepth) {
            return;
        }
        
        File[] files = directory.listFiles();
        if (files == null) {
            return; // アクセス権限なし等
        }
        
        for (File file : files) {
            // 隠しファイル・ディレクトリの処理
            if (file.isHidden() && !includeHidden) {
                continue;
            }
            
            if (file.isFile()) {
                // ファイルの場合
                String fileName = file.getName().toLowerCase();
                if (extension.isEmpty() || fileName.endsWith(extension.toLowerCase())) {
                    foundFiles.add(file.getAbsolutePath());
                }
            } else if (file.isDirectory()) {
                // ディレクトリの場合、再帰検索
                searchRecursively(file, extension, currentDepth + 1, includeHidden);
            }
        }
    }
}
```

### ✅ 解答：再帰処理の分岐網羅テスト

```java
@Test
public void testSearchFiles_BranchCoverage() throws IOException {
    DirectorySearcher searcher = new DirectorySearcher();
    
    // テスト用ディレクトリ構造作成
    File testRoot = createTestDirectoryStructure();
    String testPath = testRoot.getAbsolutePath();
    
    // TC1: null入力
    List<String> result1 = searcher.searchFiles(null, ".txt", 5, false);
    assertEquals(0, result1.size());
    
    // TC2: 存在しないディレクトリ
    List<String> result2 = searcher.searchFiles("/nonexistent", ".txt", 5, false);
    assertEquals(0, result2.size());
    
    // TC3: ファイルパスを指定（ディレクトリではない）
    File testFile = new File(testPath, "test.txt");
    List<String> result3 = searcher.searchFiles(testFile.getAbsolutePath(), ".txt", 5, false);
    assertEquals(0, result3.size());
    
    // TC4: 深度制限テスト（maxDepth = 1）
    List<String> result4 = searcher.searchFiles(testPath, ".txt", 1, false);
    assertTrue("Should find files in root level", result4.size() > 0);
    assertTrue("Should not find files in deep subdirectories", 
               result4.stream().noneMatch(path -> path.contains("level2")));
    
    // TC5: 隠しファイル除外
    List<String> result5 = searcher.searchFiles(testPath, ".txt", 5, false);
    assertTrue("Should not find hidden files", 
               result5.stream().noneMatch(path -> path.contains(".hidden")));
    
    // TC6: 隠しファイル含む
    List<String> result6 = searcher.searchFiles(testPath, ".txt", 5, true);
    assertTrue("Should find hidden files", 
               result6.stream().anyMatch(path -> path.contains(".hidden")));
    
    // TC7: 拡張子なし（すべてのファイル）
    List<String> result7 = searcher.searchFiles(testPath, "", 5, false);
    assertTrue("Should find all file types", result7.size() > result5.size());
    
    // TC8: 特定拡張子のみ
    List<String> result8 = searcher.searchFiles(testPath, ".java", 5, false);
    assertTrue("Should find only Java files", 
               result8.stream().allMatch(path -> path.toLowerCase().endsWith(".java")));
    
    // TC9: アクセス権限なしディレクトリ（files == null のケース）
    File restrictedDir = new File(testPath, "restricted");
    restrictedDir.mkdir();
    restrictedDir.setReadable(false);
    
    List<String> result9 = searcher.searchFiles(testPath, ".txt", 5, false);
    // エラーにならずに処理が継続されることを確認
    assertNotNull(result9);
    
    // クリーンアップ
    restrictedDir.setReadable(true);
    cleanupTestDirectory(testRoot);
}

// テスト用ディレクトリ構造作成
private File createTestDirectoryStructure() throws IOException {
    File testRoot = Files.createTempDirectory("test_search").toFile();
    
    // ルートレベルファイル
    new File(testRoot, "root.txt").createNewFile();
    new File(testRoot, "root.java").createNewFile();
    new File(testRoot, ".hidden.txt").createNewFile();
    
    // レベル1ディレクトリ
    File level1 = new File(testRoot, "level1");
    level1.mkdir();
    new File(level1, "level1.txt").createNewFile();
    new File(level1, "level1.java").createNewFile();
    
    // レベル2ディレクトリ（深度テスト用）
    File level2 = new File(level1, "level2");
    level2.mkdir();
    new File(level2, "level2.txt").createNewFile();
    
    // 隠しディレクトリ
    File hiddenDir = new File(testRoot, ".hiddenDir");
    hiddenDir.mkdir();
    new File(hiddenDir, "hidden.txt").createNewFile();
    
    return testRoot;
}
```

---

## 💪 補強演習 2：状態機械パターンの分岐網羅

### 📝 問題
以下の注文状態管理システムで分岐網羅を達成してください。

```java
public class OrderStateMachine {
    public enum OrderState {
        CREATED, PAID, SHIPPED, DELIVERED, CANCELLED, RETURNED
    }
    
    public class StateTransitionResult {
        private boolean success;
        private String message;
        private OrderState newState;
        
        // constructors, getters, setters...
    }
    
    public StateTransitionResult processEvent(OrderState currentState, String event, 
                                            Map<String, Object> context) {
        if (currentState == null || event == null) {
            return new StateTransitionResult(false, "Invalid input", currentState);
        }
        
        event = event.toUpperCase().trim();
        
        switch (currentState) {
            case CREATED:
                return handleCreatedState(event, context);
            case PAID:
                return handlePaidState(event, context);
            case SHIPPED:
                return handleShippedState(event, context);
            case DELIVERED:
                return handleDeliveredState(event, context);
            case CANCELLED:
                return handleCancelledState(event, context);
            case RETURNED:
                return handleReturnedState(event, context);
            default:
                return new StateTransitionResult(false, "Unknown state", currentState);
        }
    }
    
    private StateTransitionResult handleCreatedState(String event, Map<String, Object> context) {
        switch (event) {
            case "PAY":
                if (context != null && Boolean.TRUE.equals(context.get("paymentValid"))) {
                    return new StateTransitionResult(true, "Payment processed", OrderState.PAID);
                } else {
                    return new StateTransitionResult(false, "Payment failed", OrderState.CREATED);
                }
            case "CANCEL":
                return new StateTransitionResult(true, "Order cancelled", OrderState.CANCELLED);
            default:
                return new StateTransitionResult(false, "Invalid event for CREATED state", OrderState.CREATED);
        }
    }
    
    private StateTransitionResult handlePaidState(String event, Map<String, Object> context) {
        switch (event) {
            case "SHIP":
                if (context != null && context.get("inventory") != null) {
                    Integer inventory = (Integer) context.get("inventory");
                    if (inventory > 0) {
                        return new StateTransitionResult(true, "Order shipped", OrderState.SHIPPED);
                    } else {
                        return new StateTransitionResult(false, "Out of stock", OrderState.PAID);
                    }
                } else {
                    return new StateTransitionResult(false, "Inventory not available", OrderState.PAID);
                }
            case "CANCEL":
                Boolean refundProcessed = context != null ? 
                    (Boolean) context.get("refundProcessed") : false;
                if (Boolean.TRUE.equals(refundProcessed)) {
                    return new StateTransitionResult(true, "Order cancelled with refund", OrderState.CANCELLED);
                } else {
                    return new StateTransitionResult(false, "Refund processing failed", OrderState.PAID);
                }
            default:
                return new StateTransitionResult(false, "Invalid event for PAID state", OrderState.PAID);
        }
    }
    
    private StateTransitionResult handleShippedState(String event, Map<String, Object> context) {
        switch (event) {
            case "DELIVER":
                return new StateTransitionResult(true, "Order delivered", OrderState.DELIVERED);
            case "RETURN":
                return new StateTransitionResult(true, "Order returned during shipping", OrderState.RETURNED);
            default:
                return new StateTransitionResult(false, "Invalid event for SHIPPED state", OrderState.SHIPPED);
        }
    }
    
    private StateTransitionResult handleDeliveredState(String event, Map<String, Object> context) {
        if ("RETURN".equals(event)) {
            if (context != null && context.get("returnReason") != null) {
                return new StateTransitionResult(true, "Return initiated", OrderState.RETURNED);
            } else {
                return new StateTransitionResult(false, "Return reason required", OrderState.DELIVERED);
            }
        }
        return new StateTransitionResult(false, "Invalid event for DELIVERED state", OrderState.DELIVERED);
    }
    
    private StateTransitionResult handleCancelledState(String event, Map<String, Object> context) {
        // キャンセル状態からは遷移なし
        return new StateTransitionResult(false, "No transitions allowed from CANCELLED state", OrderState.CANCELLED);
    }
    
    private StateTransitionResult handleReturnedState(String event, Map<String, Object> context) {
        // 返品状態からは遷移なし
        return new StateTransitionResult(false, "No transitions allowed from RETURNED state", OrderState.RETURNED);
    }
}
```

### ✅ 解答：状態機械の完全分岐網羅テスト

```java
@Test
public void testOrderStateMachine_CompleteBranchCoverage() {
    OrderStateMachine stateMachine = new OrderStateMachine();
    
    // === 入力検証テスト ===
    
    // TC1: null state
    StateTransitionResult result1 = stateMachine.processEvent(null, "PAY", null);
    assertFalse(result1.isSuccess());
    assertEquals("Invalid input", result1.getMessage());
    
    // TC2: null event
    StateTransitionResult result2 = stateMachine.processEvent(OrderState.CREATED, null, null);
    assertFalse(result2.isSuccess());
    assertEquals("Invalid input", result2.getMessage());
    
    // === CREATED状態のテスト ===
    
    // TC3: CREATED -> PAY (成功)
    Map<String, Object> validPayment = Map.of("paymentValid", true);
    StateTransitionResult result3 = stateMachine.processEvent(OrderState.CREATED, "pay", validPayment);
    assertTrue(result3.isSuccess());
    assertEquals(OrderState.PAID, result3.getNewState());
    assertEquals("Payment processed", result3.getMessage());
    
    // TC4: CREATED -> PAY (失敗)
    Map<String, Object> invalidPayment = Map.of("paymentValid", false);
    StateTransitionResult result4 = stateMachine.processEvent(OrderState.CREATED, "PAY", invalidPayment);
    assertFalse(result4.isSuccess());
    assertEquals(OrderState.CREATED, result4.getNewState());
    assertEquals("Payment failed", result4.getMessage());
    
    // TC5: CREATED -> PAY (context null)
    StateTransitionResult result5 = stateMachine.processEvent(OrderState.CREATED, "PAY", null);
    assertFalse(result5.isSuccess());
    assertEquals(OrderState.CREATED, result5.getNewState());
    
    // TC6: CREATED -> CANCEL
    StateTransitionResult result6 = stateMachine.processEvent(OrderState.CREATED, "CANCEL", null);
    assertTrue(result6.isSuccess());
    assertEquals(OrderState.CANCELLED, result6.getNewState());
    
    // TC7: CREATED -> 無効イベント
    StateTransitionResult result7 = stateMachine.processEvent(OrderState.CREATED, "SHIP", null);
    assertFalse(result7.isSuccess());
    assertEquals(OrderState.CREATED, result7.getNewState());
    assertTrue(result7.getMessage().contains("Invalid event"));
    
    // === PAID状態のテスト ===
    
    // TC8: PAID -> SHIP (成功)
    Map<String, Object> availableInventory = Map.of("inventory", 10);
    StateTransitionResult result8 = stateMachine.processEvent(OrderState.PAID, "SHIP", availableInventory);
    assertTrue(result8.isSuccess());
    assertEquals(OrderState.SHIPPED, result8.getNewState());
    
    // TC9: PAID -> SHIP (在庫なし)
    Map<String, Object> noInventory = Map.of("inventory", 0);
    StateTransitionResult result9 = stateMachine.processEvent(OrderState.PAID, "SHIP", noInventory);
    assertFalse(result9.isSuccess());
    assertEquals(OrderState.PAID, result9.getNewState());
    assertEquals("Out of stock", result9.getMessage());
    
    // TC10: PAID -> SHIP (在庫情報なし)
    StateTransitionResult result10 = stateMachine.processEvent(OrderState.PAID, "SHIP", null);
    assertFalse(result10.isSuccess());
    assertEquals("Inventory not available", result10.getMessage());
    
    // TC11: PAID -> CANCEL (返金成功)
    Map<String, Object> refundSuccess = Map.of("refundProcessed", true);
    StateTransitionResult result11 = stateMachine.processEvent(OrderState.PAID, "CANCEL", refundSuccess);
    assertTrue(result11.isSuccess());
    assertEquals(OrderState.CANCELLED, result11.getNewState());
    
    // TC12: PAID -> CANCEL (返金失敗)
    Map<String, Object> refundFailed = Map.of("refundProcessed", false);
    StateTransitionResult result12 = stateMachine.processEvent(OrderState.PAID, "CANCEL", refundFailed);
    assertFalse(result12.isSuccess());
    assertEquals(OrderState.PAID, result12.getNewState());
    
    // TC13: PAID -> CANCEL (context null)
    StateTransitionResult result13 = stateMachine.processEvent(OrderState.PAID, "CANCEL", null);
    assertFalse(result13.isSuccess());
    assertEquals("Refund processing failed", result13.getMessage());
    
    // === SHIPPED状態のテスト ===
    
    // TC14: SHIPPED -> DELIVER
    StateTransitionResult result14 = stateMachine.processEvent(OrderState.SHIPPED, "DELIVER", null);
    assertTrue(result14.isSuccess());
    assertEquals(OrderState.DELIVERED, result14.getNewState());
    
    // TC15: SHIPPED -> RETURN
    StateTransitionResult result15 = stateMachine.processEvent(OrderState.SHIPPED, "RETURN", null);
    assertTrue(result15.isSuccess());
    assertEquals(OrderState.RETURNED, result15.getNewState());
    
    // TC16: SHIPPED -> 無効イベント
    StateTransitionResult result16 = stateMachine.processEvent(OrderState.SHIPPED, "PAY", null);
    assertFalse(result16.isSuccess());
    assertEquals(OrderState.SHIPPED, result16.getNewState());
    
    // === DELIVERED状態のテスト ===
    
    // TC17: DELIVERED -> RETURN (理由あり)
    Map<String, Object> returnReason = Map.of("returnReason", "Defective product");
    StateTransitionResult result17 = stateMachine.processEvent(OrderState.DELIVERED, "RETURN", returnReason);
    assertTrue(result17.isSuccess());
    assertEquals(OrderState.RETURNED, result17.getNewState());
    
    // TC18: DELIVERED -> RETURN (理由なし)
    StateTransitionResult result18 = stateMachine.processEvent(OrderState.DELIVERED, "RETURN", null);
    assertFalse(result18.isSuccess());
    assertEquals(OrderState.DELIVERED, result18.getNewState());
    assertEquals("Return reason required", result18.getMessage());
    
    // TC19: DELIVERED -> 無効イベント
    StateTransitionResult result19 = stateMachine.processEvent(OrderState.DELIVERED, "SHIP", null);
    assertFalse(result19.isSuccess());
    assertEquals(OrderState.DELIVERED, result19.getNewState());
    
    // === 終了状態のテスト ===
    
    // TC20: CANCELLED状態（遷移なし）
    StateTransitionResult result20 = stateMachine.processEvent(OrderState.CANCELLED, "ANY_EVENT", null);
    assertFalse(result20.isSuccess());
    assertEquals(OrderState.CANCELLED, result20.getNewState());
    assertTrue(result20.getMessage().contains("No transitions allowed"));
    
    // TC21: RETURNED状態（遷移なし）
    StateTransitionResult result21 = stateMachine.processEvent(OrderState.RETURNED, "ANY_EVENT", null);
    assertFalse(result21.isSuccess());
    assertEquals(OrderState.RETURNED, result21.getNewState());
    assertTrue(result21.getMessage().contains("No transitions allowed"));
    
    // === エッジケーステスト ===
    
    // TC22: イベント名の大文字小文字・空白処理
    StateTransitionResult result22 = stateMachine.processEvent(OrderState.CREATED, " pay ", validPayment);
    assertTrue(result22.isSuccess());
    assertEquals(OrderState.PAID, result22.getNewState());
    
    // TC23: 存在しない状態（default case）
    // 注：これは実際のenumでは発生しないが、将来の拡張性のためのテスト
    // 実際のテストでは、リフレクションやモックを使用することも可能
}
```

---

## 💪 補強演習 3：並行処理と分岐網羅

### 📝 問題
以下のスレッドセーフなカウンターシステムで分岐網羅を達成してください。

```java
public class ThreadSafeCounter {
    private volatile int count = 0;
    private volatile boolean isActive = true;
    private final int maxCount;
    private final Object lock = new Object();
    private final List<CounterListener> listeners = new ArrayList<>();
    
    public ThreadSafeCounter(int maxCount) {
        this.maxCount = maxCount;
    }
    
    public boolean increment() {
        if (!isActive) {
            return false;
        }
        
        synchronized (lock) {
            if (!isActive) { // ダブルチェック
                return false;
            }
            
            if (count >= maxCount) {
                notifyListeners("MAX_REACHED", count);
                return false;
            }
            
            count++;
            
            if (count == maxCount) {
                isActive = false;
                notifyListeners("LIMIT_REACHED", count);
            } else if (count % 10 == 0) {
                notifyListeners("MILESTONE", count);
            }
            
            return true;
        }
    }
    
    public boolean decrement() {
        if (!isActive) {
            return false;
        }
        
        synchronized (lock) {
            if (count <= 0) {
                notifyListeners("MIN_REACHED", count);
                return false;
            }
            
            count--;
            notifyListeners("DECREMENTED", count);
            return true;
        }
    }
    
    public void reset() {
        synchronized (lock) {
            count = 0;
            isActive = true;
            notifyListeners("RESET", count);
        }
    }
    
    private void notifyListeners(String event, int value) {
        if (listeners.isEmpty()) {
            return;
        }
        
        for (CounterListener listener : listeners) {
            try {
                listener.onCounterEvent(event, value);
            } catch (Exception e) {
                // リスナーでのエラーは無視（ログ出力等は省略）
            }
        }
    }
    
    public void addListener(CounterListener listener) {
        if (listener != null) {
            synchronized (lock) {
                listeners.add(listener);
            }
        }
    }
    
    public int getCount() {
        return count;
    }
    
    public boolean isActive() {
        return isActive;
    }
    
    interface CounterListener {
        void onCounterEvent(String event, int value);
    }
}
```

### ✅ 解答：並行処理の分岐網羅テスト

```java
@Test
public void testThreadSafeCounter_BranchCoverage() throws InterruptedException {
    // === 基本機能テスト ===
    
    // TC1: 通常のインクリメント
    ThreadSafeCounter counter = new ThreadSafeCounter(5);
    assertTrue(counter.increment());
    assertEquals(1, counter.getCount());
    
    // TC2: 最大値到達
    for (int i = 0; i < 4; i++) {
        assertTrue(counter.increment());
    }
    assertEquals(5, counter.getCount());
    assertFalse(counter.isActive());
    
    // TC3: 非アクティブ時のインクリメント（外側チェック）
    assertFalse(counter.increment());
    assertEquals(5, counter.getCount());
    
    // TC4: リセット後のインクリメント
    counter.reset();
    assertTrue(counter.isActive());
    assertEquals(0, counter.getCount());
    assertTrue(counter.increment());
    
    // === デクリメントテスト ===
    
    // TC5: 通常のデクリメント
    ThreadSafeCounter counter2 = new ThreadSafeCounter(10);
    counter2.increment();
    counter2.increment();
    assertTrue(counter2.decrement());
    assertEquals(1, counter2.getCount());
    
    // TC6: 最小値でのデクリメント
    counter2.decrement();
    assertEquals(0, counter2.getCount());
    assertFalse(counter2.decrement()); // count <= 0
    
    // TC7: 非アクティブ時のデクリメント
    ThreadSafeCounter counter3 = new ThreadSafeCounter(1);
    counter3.increment(); // 最大値到達でisActive = false
    assertFalse(counter3.decrement());
    
    // === リスナーテスト ===
    
    // TC8: リスナーなし（notifyListeners内のearly return）
    ThreadSafeCounter counter4 = new ThreadSafeCounter(10);
    counter4.increment(); // リスナーがないので何も通知されない
    
    // TC9: 正常なリスナー
    ThreadSafeCounter counter5 = new ThreadSafeCounter(20);
    MockCounterListener listener = new MockCounterListener();
    counter5.addListener(listener);
    
    counter5.increment();
    assertTrue(listener.getEvents().contains("MILESTONE")); // count % 10 == 0でないので呼ばれない... 待って
    
    // TC10: マイルストーンイベント（10の倍数）
    for (int i = 0; i < 9; i++) {
        counter5.increment(); // count = 10になる
    }
    assertTrue(listener.getEvents().contains("MILESTONE"));
    
    // TC11: 最大値到達イベント
    ThreadSafeCounter counter6 = new ThreadSafeCounter(2);
    MockCounterListener listener2 = new MockCounterListener();
    counter6.addListener(listener2);
    
    counter6.increment(); // count = 1
    counter6.increment(); // count = 2, LIMIT_REACHED
    assertTrue(listener2.getEvents().contains("LIMIT_REACHED"));
    
    // TC12: 最大値超過イベント
    assertFalse(counter6.increment()); // MAX_REACHED
    assertTrue(listener2.getEvents().contains("MAX_REACHED"));
    
    // TC13: デクリメントイベント
    ThreadSafeCounter counter7 = new ThreadSafeCounter(10);
    MockCounterListener listener3 = new MockCounterListener();
    counter7.addListener(listener3);
    
    counter7.increment();
    counter7.decrement();
    assertTrue(listener3.getEvents().contains("DECREMENTED"));
    
    // TC14: 最小値到達イベント
    counter7.decrement(); // count = 0
    assertFalse(counter7.decrement()); // MIN_REACHED
    assertTrue(listener3.getEvents().contains("MIN_REACHED"));
    
    // TC15: リセットイベント
    counter7.reset();
    assertTrue(listener3.getEvents().contains("RESET"));
    
    // TC16: nullリスナー追加
    counter7.addListener(null); // 何も起こらない
    
    // TC17: リスナーでの例外
    ThreadSafeCounter counter8 = new ThreadSafeCounter(10);
    CounterListener faultyListener = (event, value) -> {
        throw new RuntimeException("Listener error");
    };
    counter8.addListener(faultyListener);
    
    // 例外が発生してもカウンターは正常に動作
    assertTrue(counter8.increment());
    assertEquals(1, counter8.getCount());
    
    // === 並行処理テスト ===
    
    // TC18: 複数スレッドでのインクリメント
    ThreadSafeCounter concurrentCounter = new ThreadSafeCounter(1000);
    int numThreads = 10;
    int incrementsPerThread = 50;
    CountDownLatch latch = new CountDownLatch(numThreads);
    
    for (int i = 0; i < numThreads; i++) {
        new Thread(() -> {
            for (int j = 0; j < incrementsPerThread; j++) {
                concurrentCounter.increment();
            }
            latch.countDown();
        }).start();
    }
    
    latch.await(5, TimeUnit.SECONDS);
    assertEquals(500, concurrentCounter.getCount()); // 10 * 50 = 500
    
    // TC19: インクリメントとデクリメントの並行実行
    ThreadSafeCounter mixedCounter = new ThreadSafeCounter(100);
    CountDownLatch mixedLatch = new CountDownLatch(2);
    AtomicInteger incrementCount = new AtomicInteger(0);
    AtomicInteger decrementCount = new AtomicInteger(0);
    
    // インクリメントスレッド
    new Thread(() -> {
        for (int i = 0; i < 50; i++) {
            if (mixedCounter.increment()) {
                incrementCount.incrementAndGet();
            }
        }
        mixedLatch.countDown();
    }).start();
    
    // デクリメントスレッド（少し遅延を入れて開始）
    new Thread(() -> {
        try {
            Thread.sleep(10); // インクリメントが先に実行されるように
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        for (int i = 0; i < 30; i++) {
            if (mixedCounter.decrement()) {
                decrementCount.incrementAndGet();
            }
        }
        mixedLatch.countDown();
    }).start();
    
    mixedLatch.await(5, TimeUnit.SECONDS);
    
    // 最終的なカウントは正の値になるはず（インクリメント > デクリメント）
    assertTrue(mixedCounter.getCount() >= 0);
    assertTrue(incrementCount.get() > 0);
    assertTrue(decrementCount.get() > 0);
    
    // TC20: 非アクティブ時の並行アクセス（ダブルチェックテスト）
    ThreadSafeCounter doubleCheckCounter = new ThreadSafeCounter(1);
    CountDownLatch doubleCheckLatch = new CountDownLatch(3);
    AtomicInteger successCount = new AtomicInteger(0);
    
    for (int i = 0; i < 3; i++) {
        new Thread(() -> {
            if (doubleCheckCounter.increment()) {
                successCount.incrementAndGet();
            }
            doubleCheckLatch.countDown();
        }).start();
    }
    
    doubleCheckLatch.await(5, TimeUnit.SECONDS);
    
    // 最大値が1なので、成功するインクリメントは1回のみ
    assertEquals(1, successCount.get());
    assertEquals(1, doubleCheckCounter.getCount());
    assertFalse(doubleCheckCounter.isActive());
}

// テスト用のモックリスナー
class MockCounterListener implements ThreadSafeCounter.CounterListener {
    private final List<String> events = new ArrayList<>();
    
    @Override
    public void onCounterEvent(String event, int value) {
        synchronized (events) {
            events.add(event);
        }
    }
    
    public List<String> getEvents() {
        synchronized (events) {
            return new ArrayList<>(events);
        }
    }
}
```

---

## 🔍 補強演習での重要学習ポイント

### 💡 1. 複雑な制御フローの分岐網羅
- **再帰処理**: 深度制限、終了条件の分岐
- **状態機械**: 状態×イベントの組み合わせ分岐
- **並行処理**: 同期化ブロック内外の分岐

### 💡 2. 実務的なテスト設計
- **境界値との組み合わせ**: 分岐条件の境界値テスト
- **異常系の網羅**: 例外処理、エラーケースの分岐
- **リソース管理**: ファイル、スレッド等のリソース関連分岐

### 💡 3. テスト効率の最適化
- **並行テスト**: 複数スレッドでの分岐実行確認
- **モック・スタブ**: 外部依存の分岐を制御したテスト
- **パラメータ化**: 類似パターンの効率的テスト

---

## 🎯 補強練習完了後の確認ポイント

### ✅ 習得確認項目
- [ ] 再帰処理での分岐特定ができる
- [ ] 状態機械パターンの全分岐を網羅できる
- [ ] 並行処理の同期ポイントでの分岐を理解している
- [ ] 複雑な条件分岐を効率的にテストできる
- [ ] 実務レベルの異常系分岐をカバーできる

### 📈 次のレベルへの準備
これらの補強演習を完了したら、「06_実務適用ガイド.md」で実際のプロジェクトでの分岐網羅活用方法を学習し、さらに高度な技法（条件網羅、MC/DC等）への挑戦準備も整います。

実務での複雑なコードパターンに対する分岐網羅適用スキルを身につけましょう！
