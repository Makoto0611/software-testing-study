# 🚀 条件網羅（Condition Coverage）- 実務適用ガイド

## 🎯 実務プロジェクトでの条件網羅戦略

### 📊 プロジェクト特性別の適用方針

#### 🏦 金融・保険システム
- **目標条件網羅率**: 95-100%
- **重点領域**: 業務ルール、計算ロジック、承認フロー
- **適用範囲**: リスク評価、与信判定、保険料計算等の複雑な条件
- **除外対象**: 極力最小化（監査要件により正当化が必要）

```java
// 金融システムでの条件網羅例
public class CreditDecisionEngine {
    public CreditDecision evaluateCredit(Application app, CreditHistory history, MarketData market) {
        // 複雑な与信条件 - 100%条件網羅が必要
        if ((app.getIncome() >= 50000 && history.getScore() >= 700) ||
            (app.getAssets() >= app.getLoanAmount() * 0.3 && history.hasNoDefaults()) ||
            (app.hasGuarantor() && app.getGuarantor().getScore() >= 750)) {
            
            // さらに詳細な条件分岐...
            return evaluateDetailedCriteria(app, history, market);
        }
        return CreditDecision.REJECT;
    }
}

// 対応する条件網羅テスト
@Test
public void testCreditDecision_FullConditionCoverage() {
    // 全17個の個別条件でTrue/False両方をテスト
    // 金融業界の監査要件により完全網羅が必須
}
```

#### 🏥 医療・ヘルスケアシステム
- **目標条件網羅率**: 90-95%
- **重点領域**: 診断支援、薬剤相互作用、投薬量計算
- **適用範囲**: 患者安全に関わる全ての条件
- **除外対象**: 患者安全への影響を評価して決定

#### 🌐 一般的なWebアプリケーション
- **目標条件網羅率**: 70-85%
- **重点領域**: 認証・認可、決済処理、データ変換
- **適用範囲**: ビジネスクリティカルな機能
- **除外対象**: UI制御、ログ出力、簡単な分岐

#### 🚀 スタートアップ・プロトタイプ
- **目標条件網羅率**: 50-70%
- **重点領域**: コアビジネスロジックのみ
- **適用範囲**: MVP機能の重要な条件
- **除外対象**: 将来変更予定の機能、実験的機能

---

## 🔗 分岐網羅との効果的な組み合わせ戦略

### 🎯 段階的導入アプローチ

#### Phase 1: 分岐網羅ベース（プロジェクト開始～3ヶ月）
```java
// まず分岐網羅で基盤を固める
@Test
public void testBusinessRule_BranchCoverage() {
    // 複合条件全体のTrue/Falseをテスト
    assertTrue(processor.validateBusinessRule(validData));
    assertFalse(processor.validateBusinessRule(invalidData));
}
```

#### Phase 2: 高リスク条件の条件網羅（3～6ヶ月）
```java
// ビジネスクリティカルな条件で条件網羅を導入
@Test  
public void testBusinessRule_CriticalConditionCoverage() {
    // 複合条件内の個別条件を詳細にテスト
    
    // 個別条件1のTrue/False
    assertTrue(processor.validateBusinessRule(
        createData(validUser, validAmount, validDate)));
    assertFalse(processor.validateBusinessRule(
        createData(invalidUser, validAmount, validDate)));
        
    // 個別条件2のTrue/False
    assertTrue(processor.validateBusinessRule(
        createData(validUser, validAmount, validDate)));
    assertFalse(processor.validateBusinessRule(
        createData(validUser, invalidAmount, validDate)));
        
    // ... 他の個別条件も同様にテスト
}
```

#### Phase 3: 全体的な条件網羅（6ヶ月～）
```java
// プロジェクトの成熟に合わせて条件網羅を拡大
@Test
public void testBusinessRule_ComprehensiveConditionCoverage() {
    // 全ての複雑な条件で条件網羅を適用
    // パフォーマンスとのバランスを考慮しながら段階的に拡大
}
```

### 📊 技法選択マトリクス

| 条件の複雑さ | ビジネス影響度 | 推奨技法 | 目標網羅率 |
|------------|-------------|---------|----------|
| 単純（1-2条件） | 低 | 分岐網羅 | 90% |
| 単純 | 高 | 条件網羅 | 95% |
| 複雑（3-5条件） | 低 | 分岐網羅 | 85% |
| 複雑 | 高 | 条件網羅 | 95% |
| 非常に複雑（6+条件） | 低 | 分岐網羅 + 部分的条件網羅 | 80% |
| 非常に複雑 | 高 | 条件網羅 + MC/DC | 98% |

---

## 🛠️ CI/CDパイプラインでの条件網羅管理

### 📊 継続的品質監視

#### 💡 Jenkins での条件網羅測定
```groovy
pipeline {
    agent any
    
    stages {
        stage('Test & Coverage') {
            steps {
                sh 'mvn clean test jacoco:report'
                
                script {
                    // 条件網羅の詳細分析
                    def coverageReport = readFile('target/site/jacoco/index.html')
                    def branchCoverage = extractBranchCoverage(coverageReport)
                    def conditionCoverage = extractConditionCoverage(coverageReport)
                    
                    echo "Branch Coverage: ${branchCoverage}%"
                    echo "Condition Coverage: ${conditionCoverage}%"
                    
                    // 段階的品質ゲート
                    if (conditionCoverage < getMinimumConditionCoverage()) {
                        error("Condition coverage ${conditionCoverage}% is below minimum threshold")
                    }
                    
                    // 条件網羅の低下検出
                    def previousCoverage = getPreviousConditionCoverage()
                    if (conditionCoverage < previousCoverage - 2) {
                        currentBuild.result = 'UNSTABLE'
                        echo "WARNING: Condition coverage decreased by ${previousCoverage - conditionCoverage}%"
                    }
                }
            }
        }
        
        stage('Condition Coverage Analysis') {
            steps {
                script {
                    // 未カバー条件の詳細分析
                    def uncoveredConditions = analyzeUncoveredConditions()
                    
                    writeFile file: 'condition-coverage-report.md', text: generateConditionCoverageReport(uncoveredConditions)
                    
                    archiveArtifacts artifacts: 'condition-coverage-report.md'
                }
            }
        }
    }
    
    post {
        always {
            publishHTML([
                allowMissing: false,
                alwaysLinkToLastBuild: true,
                keepAll: true,
                reportDir: 'target/site/jacoco',
                reportFiles: 'index.html',
                reportName: 'Coverage Report'
            ])
        }
        
        unstable {
            emailext (
                subject: "Condition Coverage Warning: ${env.JOB_NAME} - Build ${env.BUILD_NUMBER}",
                body: "Condition coverage has decreased. Please review the coverage report.",
                to: "${env.CHANGE_AUTHOR_EMAIL}"
            )
        }
    }
}

// 条件網羅の最小要求値をプロジェクト段階に応じて動的設定
def getMinimumConditionCoverage() {
    def phase = env.PROJECT_PHASE ?: 'development'
    
    switch(phase) {
        case 'prototype':
            return 50
        case 'development':
            return 70
        case 'staging':
            return 85
        case 'production':
            return 90
        default:
            return 70
    }
}
```

#### 💡 GitHub Actions での条件網羅品質管理
```yaml
name: Condition Coverage Quality Gate

on:
  pull_request:
    branches: [ main, develop ]
  push:
    branches: [ main ]

jobs:
  condition-coverage:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0  # 履歴比較のため
    
    - name: Set up Development Environment
      uses: actions/setup-java@v3
      with:
        java-version: '11'
        distribution: 'temurin'
    
    - name: Run Tests with Detailed Coverage
      run: |
        mvn clean test jacoco:report
        mvn jacoco:report-aggregate  # 条件網羅詳細レポート
    
    - name: Analyze Condition Coverage
      run: |
        # 条件網羅の詳細分析
        python scripts/analyze-condition-coverage.py \
          --coverage-file target/site/jacoco/jacoco.xml \
          --output condition-analysis.json
    
    - name: Condition Coverage Quality Gate
      run: |
        CONDITION_COVERAGE=$(jq -r '.overallConditionCoverage' condition-analysis.json)
        UNCOVERED_CRITICAL=$(jq -r '.uncoveredCriticalConditions | length' condition-analysis.json)
        
        echo "Current Condition Coverage: $CONDITION_COVERAGE%"
        echo "Uncovered Critical Conditions: $UNCOVERED_CRITICAL"
        
        # 段階的品質基準
        MIN_COVERAGE=70
        if [ "$GITHUB_REF" == "refs/heads/main" ]; then
          MIN_COVERAGE=85
        fi
        
        if (( $(echo "$CONDITION_COVERAGE < $MIN_COVERAGE" | bc -l) )); then
          echo "❌ Condition coverage $CONDITION_COVERAGE% is below minimum $MIN_COVERAGE%"
          exit 1
        fi
        
        if [ "$UNCOVERED_CRITICAL" -gt 0 ]; then
          echo "⚠️ Found $UNCOVERED_CRITICAL uncovered critical conditions"
          echo "::warning::Critical conditions are not fully covered"
        fi
        
        echo "✅ Condition coverage meets quality standards"
    
    - name: Comment PR with Condition Coverage Details
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          const analysis = JSON.parse(fs.readFileSync('condition-analysis.json', 'utf8'));
          
          const body = `## 🎯 Condition Coverage Analysis
          
          | Metric | Current | Target | Status |
          |--------|---------|---------|---------|
          | Overall Condition Coverage | ${analysis.overallConditionCoverage}% | 85% | ${analysis.overallConditionCoverage >= 85 ? '✅' : '⚠️'} |
          | Critical Conditions | ${analysis.criticalConditionCoverage}% | 95% | ${analysis.criticalConditionCoverage >= 95 ? '✅' : '⚠️'} |
          | Complex Conditions | ${analysis.complexConditionCoverage}% | 90% | ${analysis.complexConditionCoverage >= 90 ? '✅' : '⚠️'} |
          
          ### 📊 Detailed Analysis
          - **Newly Added Conditions**: ${analysis.newConditions.length}
          - **Uncovered Critical Conditions**: ${analysis.uncoveredCriticalConditions.length}
          - **Improved Coverage**: ${analysis.improvedCoverage.length} areas
          
          ${analysis.uncoveredCriticalConditions.length > 0 ? 
            `### ⚠️ Uncovered Critical Conditions
            ${analysis.uncoveredCriticalConditions.map(c => `- \`${c.method}\`: ${c.description}`).join('\n')}` : ''}
          
          [View detailed coverage report](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID})`;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: body
          });
```

---

## 🎯 プロジェクト段階別の実装戦略

### 🚀 初期導入期（0-3ヶ月）

#### 📋 導入準備チェックリスト
```markdown
## 条件網羅導入準備

### 🛠️ 技術基盤
- [ ] カバレッジツールの条件網羅対応確認（JaCoCo 0.8.5+推奨）
- [ ] CI/CDパイプラインへの統合
- [ ] 品質ゲート設定（段階的基準）
- [ ] レポート自動生成・配布

### 👥 チーム準備  
- [ ] 条件網羅の基本概念研修
- [ ] 分岐網羅との違いの理解
- [ ] 効率的なテスト設計手法習得
- [ ] ツール使用方法習得

### 📊 プロジェクト設定
- [ ] 対象範囲の明確化（高リスク領域の特定）
- [ ] 品質基準の設定（段階的目標）
- [ ] 除外対象の定義と正当化
- [ ] 測定頻度の決定
```

#### 💡 段階的導入例
```java
// Week 1-4: 高リスク業務ロジックから開始
@Test
public class PaymentProcessorConditionCoverageTests {
    
    @Test
    public void testPaymentValidation_CriticalConditions() {
        // 決済処理の重要な条件のみ条件網羅を適用
        // 目標: 重要条件の95%網羅
    }
}

// Week 5-8: 対象範囲を拡大
@Test
public class BusinessRuleEngineConditionCoverageTests {
    
    @Test
    public void testBusinessRules_ExpandedConditionCoverage() {
        // 業務ルール全般に条件網羅を拡大
        // 目標: 業務ルールの85%網羅
    }
}

// Week 9-12: システム全体への適用検討
```

### 🏗️ 展開期（3-6ヶ月）

#### 💪 効率化手法の導入
```java
// テストデータファクトリーパターン
public class ConditionCoverageTestDataFactory {
    
    public static TestDataBuilder forConditionCoverage() {
        return new TestDataBuilder()
            .withSystematicConditionValues()
            .withBoundaryConditions()
            .withExceptionScenarios();
    }
    
    public static class TestDataBuilder {
        private Map<String, Object> conditions = new HashMap<>();
        
        public TestDataBuilder withCondition(String name, boolean value) {
            conditions.put(name, value);
            return this;
        }
        
        public TestDataBuilder withSystematicConditionValues() {
            // 条件網羅に必要な体系的なテストデータを生成
            return this;
        }
        
        public TestData build() {
            return new TestData(conditions);
        }
    }
}

// パラメータ化テストによる効率化
@ParameterizedTest
@MethodSource("conditionCombinations")
public void testComplexConditions_Parameterized(
    boolean condition1, boolean condition2, boolean condition3, 
    boolean expectedResult) {
    
    TestData data = ConditionCoverageTestDataFactory
        .forConditionCoverage()
        .withCondition("userValid", condition1)
        .withCondition("amountValid", condition2)
        .withCondition("timeValid", condition3)
        .build();
        
    boolean actual = processor.processRequest(data);
    assertEquals(expectedResult, actual);
}

static Stream<Arguments> conditionCombinations() {
    // 条件網羅に必要な最小限の組み合わせを生成
    return Stream.of(
        Arguments.of(true, true, true, true),    // 全条件True
        Arguments.of(false, true, true, false),  // condition1のFalseテスト
        Arguments.of(true, false, true, false),  // condition2のFalseテスト
        Arguments.of(true, true, false, false)   // condition3のFalseテスト
    );
}
```

### 🎯 成熟期（6ヶ月～）

#### 📈 高度な適用技法
```java
// MC/DCとの組み合わせ
@Test
public class SafetyCriticalSystemConditionCoverage {
    
    @Test
    public void testSafetyLogic_MCDCConditionCoverage() {
        // Modified Condition/Decision Coverage
        // 各条件が結果に独立して影響することを確認
        
        // 条件1の独立性テスト
        assertTrue(safetySystem.isOperationSafe(
            createContext(true, false, false)));   // 条件1のみTrue
        assertFalse(safetySystem.isOperationSafe(
            createContext(false, false, false)));  // 条件1のみ変更
            
        // 条件2の独立性テスト
        assertTrue(safetySystem.isOperationSafe(
            createContext(false, true, false)));   // 条件2のみTrue
        assertFalse(safetySystem.isOperationSafe(
            createContext(false, false, false)));  // 条件2のみ変更
            
        // ... 他の条件の独立性も同様にテスト
    }
}

// パフォーマンス最適化
@Test
public class OptimizedConditionCoverageTests {
    
    @RepeatedTest(1000)
    @Timeout(value = 100, unit = TimeUnit.MILLISECONDS)
    public void testConditionCoverage_PerformanceOptimized() {
        // 条件網羅テストのパフォーマンス最適化
        // - テストデータの事前生成
        // - モックの効率的な利用
        // - 並列実行の活用
    }
}
```

---

## 💡 実務での成功要因とリスク管理

### ✅ 成功要因

#### 🎯 1. 段階的アプローチ
```markdown
## 成功する条件網羅導入パターン

### Phase 1: 選択的導入（1-3ヶ月）
- 高リスク・高価値領域に限定
- 分岐網羅からの自然な発展
- チームの学習コスト最小化

### Phase 2: 拡張適用（3-6ヶ月）
- 成功事例を基に対象拡大
- 効率化手法の導入
- 品質向上効果の定量測定

### Phase 3: 標準化（6ヶ月～）
- 組織標準への組み込み
- 新規プロジェクトでの標準適用
- 継続的改善プロセスの確立
```

#### 🤝 2. チーム内での合意形成
```java
// 条件網羅導入の価値を定量的に示す
public class ConditionCoverageValueDemonstration {
    
    @Test
    public void demonstrateConditionCoverageValue() {
        // 分岐網羅のみの場合
        BranchCoverageTest branchTest = new BranchCoverageTest();
        TestResults branchResults = branchTest.runTests();
        
        // 条件網羅を追加した場合
        ConditionCoverageTest conditionTest = new ConditionCoverageTest();
        TestResults conditionResults = conditionTest.runTests();
        
        // 価値の定量化
        int additionalBugsFound = conditionResults.getBugsFound() - branchResults.getBugsFound();
        double testEffectiveness = (double) additionalBugsFound / conditionResults.getTestCount();
        
        // レポート生成
        generateValueReport(branchResults, conditionResults, additionalBugsFound, testEffectiveness);
    }
    
    private void generateValueReport(TestResults branch, TestResults condition, 
                                   int additionalBugs, double effectiveness) {
        System.out.println("=== 条件網羅導入効果レポート ===");
        System.out.println("分岐網羅のみ: " + branch.getBugsFound() + " bugs発見");
        System.out.println("条件網羅追加: " + condition.getBugsFound() + " bugs発見");
        System.out.println("追加発見バグ: " + additionalBugs + " bugs");
        System.out.println("テスト効果向上: " + String.format("%.2f%%", effectiveness * 100));
    }
}
```

### ⚠️ リスク管理

#### 💣 よくある失敗パターンと対策

##### 1. 完璧主義の罠
```java
// 悪い例: 理論的完璧性を追求
@Test
public void testEveryPossibleCondition() {
    // 64個の条件組み合わせをすべてテスト（2^6 = 64）
    // → 実用性を無視した過度なテスト
}

// 良い例: 実用的なバランス
@Test
public void testCriticalConditionCombinations() {
    // ビジネス影響度の高い条件組み合わせに焦点
    // 80/20ルール：20%の条件で80%のリスクをカバー
}
```

##### 2. チーム抵抗への対処
```markdown
## チーム抵抗の原因と対策

### 抵抗要因
- 学習コスト増加への懸念
- 開発速度低下への不安
- 複雑性増加による保守性悪化の心配

### 対策
- 段階的導入による学習負荷軽減
- 自動化による効率化
- 明確な価値実証
- 成功事例の共有
```

##### 3. ツール制約への対応
```java
// カバレッジツールの制約を理解した設計
@Test
public class ToolLimitationAwareTests {
    
    @Test
    public void testComplexCondition_ToolFriendly() {
        // ツールが正確に測定できる形でテストを設計
        
        // 複雑な条件を分割して測定精度を向上
        boolean condition1 = evaluateCondition1(data);
        boolean condition2 = evaluateCondition2(data);
        boolean condition3 = evaluateCondition3(data);
        
        boolean result = condition1 && condition2 && condition3;
        
        // 各条件の個別テストも実行
        testCondition1Separately(data);
        testCondition2Separately(data);
        testCondition3Separately(data);
    }
}
```

---

## 🎯 組織レベルでの条件網羅標準化

### 📋 品質標準への組み込み

#### 💡 組織標準テンプレート
```markdown
# 条件網羅適用標準

## 適用判断基準
| システム分類 | 適用レベル | 目標網羅率 | 適用範囲 |
|------------|----------|----------|---------|
| Mission Critical | 必須 | 95% | 全業務ロジック |
| Business Critical | 推奨 | 85% | 主要業務機能 |
| Supporting | 選択的 | 70% | 高リスク部分 |
| Experimental | 最小限 | 50% | コア機能のみ |

## 実装ガイドライン
1. 段階的導入（3ヶ月スパン）
2. リスクベース優先順位付け
3. 自動化による効率化
4. 継続的改善プロセス

## 品質評価指標
- 条件網羅達成率
- バグ検出効果
- 開発効率への影響
- チーム習熟度
```

### 🔄 継続的改善プロセス

#### 📊 四半期レビュープロセス
```markdown
## 条件網羅四半期レビュー

### 📈 効果測定
- 導入前後のバグ検出率比較
- テスト作成効率の変化
- プロダクション障害件数の推移
- 顧客満足度への影響

### 🎯 改善アクション
- 低効果領域の分析と対策
- 高効果領域の横展開
- ツール・プロセスの改善
- チーム教育の強化

### 📋 次四半期計画
- 新規適用領域の選定
- 品質目標の調整
- リソース配分の最適化
```

---

## 🚀 条件網羅の将来展望

### 🤖 AI・機械学習との融合
```python
# AI支援による条件網羅最適化（概念例）
class AIAssistedConditionCoverage:
    
    def optimize_test_cases(self, code_analysis, historical_bug_data):
        """
        AIを活用した条件網羅テストケース最適化
        - コード分析による高リスク条件の特定
        - 過去のバグデータからの学習
        - 最小限のテストケースで最大の効果を実現
        """
        high_risk_conditions = self.identify_high_risk_conditions(code_analysis)
        optimal_combinations = self.generate_optimal_combinations(
            high_risk_conditions, historical_bug_data
        )
        return optimal_combinations
    
    def predict_bug_probability(self, condition_combinations):
        """
        条件組み合わせからバグ確率を予測
        - 機械学習モデルによる予測
        - リソース配分の最適化支援
        """
        pass
```

### 🔮 次世代テスト技法への発展
- **Symbolic Execution**: 条件網羅の自動生成
- **Model-Based Testing**: ビジネスモデルからの条件網羅
- **Property-Based Testing**: 条件の性質に基づく自動テスト

---

## 🎯 まとめ：条件網羅の実務価値

条件網羅は**高度な技法**ですが、適切に適用すれば：

### ✅ 得られる価値
- **品質向上**: 複雑な条件での詳細なバグ検出
- **リスク軽減**: ビジネスクリティカルな条件の厳密な検証
- **保守性向上**: 条件変更時の影響範囲の明確化
- **信頼性確保**: 高信頼性システムでの必須技法

### 📊 成功のポイント
- **段階的導入**: 一度にすべてを目指さない
- **リスクベース**: 影響度の高い条件を優先
- **効率化**: ツールと自動化の活用
- **チーム育成**: 継続的な技法向上

条件網羅をマスターして、より高品質なソフトウェア開発を実現してください！次は**MC/DC**や**経験ベーステスト**等のより高度な技法にチャレンジしていきましょう。
