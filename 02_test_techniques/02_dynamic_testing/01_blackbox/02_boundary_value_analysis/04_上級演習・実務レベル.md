# 💪 境界値分析 上級演習・実務レベル

## 📚 この段階のゴール

**実務で遭遇する複雑な境界値を扱えるようになる**
- [ ] 複数条件が絡む境界値を特定できる
- [ ] 状態依存の境界値を扱える
- [ ] パフォーマンス/セキュリティ境界値を考慮できる
- [ ] 実務プロジェクトで適用できる

**⏰ 推奨時間**: 約90分

---

## 🎯 上級演習の特徴

```
基本演習との違い:
❌ 単一条件・静的な境界値
✅ 複数条件・動的な境界値
✅ ビジネスルールが複雑
✅ パフォーマンス/セキュリティ考慮
✅ 実装まで含む総合的な設計
```

**すぐに演習を始めましょう！ 🚀**

---

## 🎯 演習1: 複数ユーザー種別の境界値【難易度: ★★★】

### 📝 実務シナリオ
```
ファイルアップロードシステム
- 無料会員: 10MB以下、1日5ファイルまで
- 有料会員: 100MB以下、1日50ファイルまで
- 企業会員: 1GB以下、無制限
- 管理者: 無制限
```

### 課題

**Q1. 各ユーザー種別の境界値テストケースを設計してください**

| ユーザー種別 | ファイルサイズ境界値 | アップロード数境界値 |
|-------------|---------------------|---------------------|
| 無料会員 | | |
| 有料会員 | | |
| 企業会員 | | |

**Q2. PHPUnitで実装してください**

```php
class FileUploadValidator
{
    public function canUpload(
        string $userType, 
        int $fileSizeMB, 
        int $todayUploadCount
    ): bool {
        // [ここに実装]
    }
}

class FileUploadValidatorTest extends TestCase
{
    // [テストを実装]
}
```

<details>
<summary>💡 解答</summary>

**Q1. 境界値テストケース**

| ユーザー種別 | ファイルサイズ境界値 | アップロード数境界値 |
|-------------|---------------------|---------------------|
| 無料会員 | 9MB, 10MB, 11MB | 4回, 5回, 6回 |
| 有料会員 | 99MB, 100MB, 101MB | 49回, 50回, 51回 |
| 企業会員 | 1023MB, 1024MB, 1025MB | 無制限 |

**Q2. PHPUnit実装**

```php
class FileUploadValidator
{
    private const LIMITS = [
        'free' => ['size' => 10, 'count' => 5],
        'paid' => ['size' => 100, 'count' => 50],
        'enterprise' => ['size' => 1024, 'count' => PHP_INT_MAX],
        'admin' => ['size' => PHP_INT_MAX, 'count' => PHP_INT_MAX],
    ];

    public function canUpload(
        string $userType, 
        int $fileSizeMB, 
        int $todayUploadCount
    ): bool {
        if (!isset(self::LIMITS[$userType])) {
            throw new InvalidArgumentException("Invalid user type: $userType");
        }

        $limit = self::LIMITS[$userType];
        
        return $fileSizeMB <= $limit['size'] && 
               $todayUploadCount < $limit['count'];
    }
}

class FileUploadValidatorTest extends TestCase
{
    private FileUploadValidator $validator;

    protected function setUp(): void
    {
        $this->validator = new FileUploadValidator();
    }

    /** @test 無料会員 - ファイルサイズ境界値 */
    public function 無料会員_ファイルサイズ9MB_OK()
    {
        $this->assertTrue($this->validator->canUpload('free', 9, 0));
    }

    /** @test */
    public function 無料会員_ファイルサイズ10MB_OK()
    {
        $this->assertTrue($this->validator->canUpload('free', 10, 0));
    }

    /** @test */
    public function 無料会員_ファイルサイズ11MB_NG()
    {
        $this->assertFalse($this->validator->canUpload('free', 11, 0));
    }

    /** @test 無料会員 - アップロード数境界値 */
    public function 無料会員_4回目_OK()
    {
        $this->assertTrue($this->validator->canUpload('free', 5, 4));
    }

    /** @test */
    public function 無料会員_5回目_NG()
    {
        $this->assertFalse($this->validator->canUpload('free', 5, 5));
    }

    /** @test 有料会員 - ファイルサイズ境界値 */
    public function 有料会員_ファイルサイズ99MB_OK()
    {
        $this->assertTrue($this->validator->canUpload('paid', 99, 0));
    }

    /** @test */
    public function 有料会員_ファイルサイズ100MB_OK()
    {
        $this->assertTrue($this->validator->canUpload('paid', 100, 0));
    }

    /** @test */
    public function 有料会員_ファイルサイズ101MB_NG()
    {
        $this->assertFalse($this->validator->canUpload('paid', 101, 0));
    }

    /** @test 有料会員 - アップロード数境界値 */
    public function 有料会員_49回目_OK()
    {
        $this->assertTrue($this->validator->canUpload('paid', 50, 49));
    }

    /** @test */
    public function 有料会員_50回目_NG()
    {
        $this->assertFalse($this->validator->canUpload('paid', 50, 50));
    }

    /** @test 企業会員 - ファイルサイズ境界値 */
    public function 企業会員_ファイルサイズ1023MB_OK()
    {
        $this->assertTrue($this->validator->canUpload('enterprise', 1023, 0));
    }

    /** @test */
    public function 企業会員_ファイルサイズ1024MB_OK()
    {
        $this->assertTrue($this->validator->canUpload('enterprise', 1024, 0));
    }

    /** @test */
    public function 企業会員_ファイルサイズ1025MB_NG()
    {
        $this->assertFalse($this->validator->canUpload('enterprise', 1025, 0));
    }

    /** @test */
    public function 企業会員_100回アップロード_OK()
    {
        $this->assertTrue($this->validator->canUpload('enterprise', 500, 100));
    }

    /** @test データプロバイダで網羅 */
    /** @dataProvider ユーザー種別境界値パターン */
    public function ユーザー種別ごとの境界値テスト(
        string $userType, 
        int $size, 
        int $count, 
        bool $expected
    ) {
        $this->assertEquals($expected, $this->validator->canUpload($userType, $size, $count));
    }

    public function ユーザー種別境界値パターン(): array
    {
        return [
            // [userType, size, count, expected]
            '無料_サイズ下限OK' => ['free', 10, 0, true],
            '無料_サイズ上限NG' => ['free', 11, 0, false],
            '無料_回数上限OK' => ['free', 5, 4, true],
            '無料_回数上限NG' => ['free', 5, 5, false],
            '有料_サイズ下限OK' => ['paid', 100, 0, true],
            '有料_サイズ上限NG' => ['paid', 101, 0, false],
            '有料_回数上限OK' => ['paid', 50, 49, true],
            '有料_回数上限NG' => ['paid', 50, 50, false],
            '企業_サイズ下限OK' => ['enterprise', 1024, 0, true],
            '企業_サイズ上限NG' => ['enterprise', 1025, 0, false],
        ];
    }
}
```
</details>

---

## 🎯 演習2: 状態依存の境界値【難易度: ★★★】

### 📝 実務シナリオ
```
ECサイトのポイント利用
- 通常時: 購入金額の30%までポイント利用可
- セール時: 購入金額の50%までポイント利用可
- 会員ランクGold以上: 購入金額の100%までポイント利用可
- 最低利用ポイント: 100ポイント
- 保有ポイントを超えて利用不可
```

### 課題
**完全な実装を最初から書いてください**

```php
// [ここに完全な実装]
```

<details>
<summary>💡 解答例</summary>

```php
class PointUsageCalculator
{
    private const MIN_USAGE_POINTS = 100;

    public function getMaxUsablePoints(
        int $purchaseAmount,
        int $ownedPoints,
        bool $isSale,
        string $memberRank
    ): int {
        // 最低利用ポイント未満は使えない
        if ($ownedPoints < self::MIN_USAGE_POINTS) {
            return 0;
        }

        // 利用率の決定
        $usageRate = $this->calculateUsageRate($isSale, $memberRank);
        
        // 購入金額に基づく上限
        $maxByAmount = (int) ($purchaseAmount * $usageRate);
        
        // 保有ポイントと購入金額上限の小さい方
        return min($ownedPoints, $maxByAmount);
    }

    private function calculateUsageRate(bool $isSale, string $memberRank): float
    {
        if (in_array($memberRank, ['Gold', 'Platinum'])) {
            return 1.0; // 100%
        }

        return $isSale ? 0.5 : 0.3;
    }
}

class PointUsageCalculatorTest extends TestCase
{
    private PointUsageCalculator $calculator;

    protected function setUp(): void
    {
        $this->calculator = new PointUsageCalculator();
    }

    /** @test 最低利用ポイントの境界値 */
    public function 保有ポイント99_利用不可()
    {
        $result = $this->calculator->getMaxUsablePoints(
            purchaseAmount: 10000,
            ownedPoints: 99,
            isSale: false,
            memberRank: 'Silver'
        );
        $this->assertEquals(0, $result);
    }

    /** @test */
    public function 保有ポイント100_利用可能()
    {
        $result = $this->calculator->getMaxUsablePoints(
            purchaseAmount: 10000,
            ownedPoints: 100,
            isSale: false,
            memberRank: 'Silver'
        );
        $this->assertEquals(100, $result);
    }

    /** @test 通常時30%境界値 */
    public function 通常時_購入10000円_保有3000ポイント_上限3000()
    {
        $result = $this->calculator->getMaxUsablePoints(
            purchaseAmount: 10000,
            ownedPoints: 3000,
            isSale: false,
            memberRank: 'Silver'
        );
        $this->assertEquals(3000, $result); // 10000 * 0.3 = 3000
    }

    /** @test */
    public function 通常時_購入10000円_保有5000ポイント_上限3000()
    {
        $result = $this->calculator->getMaxUsablePoints(
            purchaseAmount: 10000,
            ownedPoints: 5000,
            isSale: false,
            memberRank: 'Silver'
        );
        $this->assertEquals(3000, $result); // 保有は5000だが、30%制限で3000まで
    }

    /** @test セール時50%境界値 */
    public function セール時_購入10000円_保有5000ポイント_上限5000()
    {
        $result = $this->calculator->getMaxUsablePoints(
            purchaseAmount: 10000,
            ownedPoints: 5000,
            isSale: true,
            memberRank: 'Silver'
        );
        $this->assertEquals(5000, $result); // 10000 * 0.5 = 5000
    }

    /** @test */
    public function セール時_購入10000円_保有7000ポイント_上限5000()
    {
        $result = $this->calculator->getMaxUsablePoints(
            purchaseAmount: 10000,
            ownedPoints: 7000,
            isSale: true,
            memberRank: 'Silver'
        );
        $this->assertEquals(5000, $result); // 保有は7000だが、50%制限で5000まで
    }

    /** @test Gold会員100%境界値 */
    public function Gold会員_購入10000円_保有10000ポイント_全額利用可()
    {
        $result = $this->calculator->getMaxUsablePoints(
            purchaseAmount: 10000,
            ownedPoints: 10000,
            isSale: false,
            memberRank: 'Gold'
        );
        $this->assertEquals(10000, $result);
    }

    /** @test */
    public function Gold会員_購入10000円_保有15000ポイント_上限10000()
    {
        $result = $this->calculator->getMaxUsablePoints(
            purchaseAmount: 10000,
            ownedPoints: 15000,
            isSale: false,
            memberRank: 'Gold'
        );
        $this->assertEquals(10000, $result); // 購入金額が上限
    }

    /** @test データ駆動テスト */
    /** @dataProvider ポイント利用境界値パターン */
    public function ポイント利用の複合境界値テスト(
        int $purchaseAmount,
        int $ownedPoints,
        bool $isSale,
        string $memberRank,
        int $expected
    ) {
        $result = $this->calculator->getMaxUsablePoints(
            $purchaseAmount,
            $ownedPoints,
            $isSale,
            $memberRank
        );
        $this->assertEquals($expected, $result);
    }

    public function ポイント利用境界値パターン(): array
    {
        return [
            // [purchaseAmount, ownedPoints, isSale, memberRank, expected]
            '最低ポイント未満' => [10000, 99, false, 'Silver', 0],
            '最低ポイント丁度' => [10000, 100, false, 'Silver', 100],
            '通常30%_保有不足' => [10000, 2000, false, 'Silver', 2000],
            '通常30%_保有十分' => [10000, 5000, false, 'Silver', 3000],
            'セール50%_保有不足' => [10000, 4000, true, 'Silver', 4000],
            'セール50%_保有十分' => [10000, 7000, true, 'Silver', 5000],
            'Gold100%_保有不足' => [10000, 8000, false, 'Gold', 8000],
            'Gold100%_保有十分' => [10000, 15000, false, 'Gold', 10000],
            'Platinum100%' => [10000, 10000, false, 'Platinum', 10000],
        ];
    }
}
```
</details>

---

## 🎯 演習3: Laravel実践 - バリデーション境界値【難易度: ★★★】

### 📝 実務シナリオ
```
Laravelフォームリクエストでの複雑なバリデーション
- ユーザー登録フォーム
- 年齢: 18-99歳
- ユーザー名: 3-20文字（英数字のみ）
- メールアドレス: 有効なフォーマット、最大255文字
- パスワード: 8-30文字、英大小数字記号必須
```

### 課題
**Laravel FormRequestとFeatureテストを実装してください**

<details>
<summary>💡 解答例</summary>

```php
// app/Http/Requests/UserRegistrationRequest.php
class UserRegistrationRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'age' => ['required', 'integer', 'min:18', 'max:99'],
            'username' => ['required', 'string', 'min:3', 'max:20', 'regex:/^[a-zA-Z0-9]+$/'],
            'email' => ['required', 'email', 'max:255'],
            'password' => [
                'required',
                'string',
                'min:8',
                'max:30',
                'regex:/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]+$/'
            ],
        ];
    }

    public function messages(): array
    {
        return [
            'age.min' => '年齢は18歳以上である必要があります',
            'age.max' => '年齢は99歳以下である必要があります',
            'username.regex' => 'ユーザー名は英数字のみ使用できます',
            'password.regex' => 'パスワードは英大文字、小文字、数字、記号をすべて含む必要があります',
        ];
    }
}

// tests/Feature/UserRegistrationRequestTest.php
class UserRegistrationRequestTest extends TestCase
{
    /** @test 年齢の境界値テスト */
    public function 年齢17歳_バリデーションエラー()
    {
        $response = $this->postJson('/api/register', [
            'age' => 17,
            'username' => 'testuser',
            'email' => 'test@example.com',
            'password' => 'Test1234!',
        ]);

        $response->assertStatus(422)
                 ->assertJsonValidationErrors('age');
    }

    /** @test */
    public function 年齢18歳_バリデーション成功()
    {
        $response = $this->postJson('/api/register', [
            'age' => 18,
            'username' => 'testuser',
            'email' => 'test@example.com',
            'password' => 'Test1234!',
        ]);

        $response->assertStatus(200); // または201
    }

    /** @test */
    public function 年齢99歳_バリデーション成功()
    {
        $response = $this->postJson('/api/register', [
            'age' => 99,
            'username' => 'testuser',
            'email' => 'test@example.com',
            'password' => 'Test1234!',
        ]);

        $response->assertStatus(200);
    }

    /** @test */
    public function 年齢100歳_バリデーションエラー()
    {
        $response = $this->postJson('/api/register', [
            'age' => 100,
            'username' => 'testuser',
            'email' => 'test@example.com',
            'password' => 'Test1234!',
        ]);

        $response->assertStatus(422)
                 ->assertJsonValidationErrors('age');
    }

    /** @test ユーザー名の境界値テスト */
    public function ユーザー名2文字_バリデーションエラー()
    {
        $response = $this->postJson('/api/register', [
            'age' => 25,
            'username' => 'ab',
            'email' => 'test@example.com',
            'password' => 'Test1234!',
        ]);

        $response->assertStatus(422)
                 ->assertJsonValidationErrors('username');
    }

    /** @test */
    public function ユーザー名3文字_バリデーション成功()
    {
        $response = $this->postJson('/api/register', [
            'age' => 25,
            'username' => 'abc',
            'email' => 'test@example.com',
            'password' => 'Test1234!',
        ]);

        $response->assertStatus(200);
    }

    /** @test */
    public function ユーザー名20文字_バリデーション成功()
    {
        $response = $this->postJson('/api/register', [
            'age' => 25,
            'username' => str_repeat('a', 20),
            'email' => 'test@example.com',
            'password' => 'Test1234!',
        ]);

        $response->assertStatus(200);
    }

    /** @test */
    public function ユーザー名21文字_バリデーションエラー()
    {
        $response = $this->postJson('/api/register', [
            'age' => 25,
            'username' => str_repeat('a', 21),
            'email' => 'test@example.com',
            'password' => 'Test1234!',
        ]);

        $response->assertStatus(422)
                 ->assertJsonValidationErrors('username');
    }

    /** @test パスワードの境界値テスト */
    public function パスワード7文字_バリデーションエラー()
    {
        $response = $this->postJson('/api/register', [
            'age' => 25,
            'username' => 'testuser',
            'email' => 'test@example.com',
            'password' => 'Test12!',
        ]);

        $response->assertStatus(422)
                 ->assertJsonValidationErrors('password');
    }

    /** @test */
    public function パスワード8文字_バリデーション成功()
    {
        $response = $this->postJson('/api/register', [
            'age' => 25,
            'username' => 'testuser',
            'email' => 'test@example.com',
            'password' => 'Test123!',
        ]);

        $response->assertStatus(200);
    }

    /** @test */
    public function パスワード30文字_バリデーション成功()
    {
        $response = $this->postJson('/api/register', [
            'age' => 25,
            'username' => 'testuser',
            'email' => 'test@example.com',
            'password' => 'Test123!' . str_repeat('a', 22),
        ]);

        $response->assertStatus(200);
    }

    /** @test */
    public function パスワード31文字_バリデーションエラー()
    {
        $response = $this->postJson('/api/register', [
            'age' => 25,
            'username' => 'testuser',
            'email' => 'test@example.com',
            'password' => 'Test123!' . str_repeat('a', 23),
        ]);

        $response->assertStatus(422)
                 ->assertJsonValidationErrors('password');
    }

    /** @test メールアドレスの境界値テスト */
    public function メールアドレス255文字_バリデーション成功()
    {
        // local@domain の形式で255文字
        $localPart = str_repeat('a', 243); // 243 + @ + example.com(11) = 255
        $email = $localPart . '@example.com';

        $response = $this->postJson('/api/register', [
            'age' => 25,
            'username' => 'testuser',
            'email' => $email,
            'password' => 'Test1234!',
        ]);

        $response->assertStatus(200);
    }

    /** @test */
    public function メールアドレス256文字_バリデーションエラー()
    {
        $localPart = str_repeat('a', 244); // 244 + @ + example.com(11) = 256
        $email = $localPart . '@example.com';

        $response = $this->postJson('/api/register', [
            'age' => 25,
            'username' => 'testuser',
            'email' => $email,
            'password' => 'Test1234!',
        ]);

        $response->assertStatus(422)
                 ->assertJsonValidationErrors('email');
    }
}
```
</details>

---

## 🎯 演習4: API境界値とレート制限【難易度: ★★★】

### 📝 実務シナリオ
```
REST API のレート制限
- 無料プラン: 100リクエスト/時間
- 有料プラン: 1000リクエスト/時間
- 企業プラン: 10000リクエスト/時間
- 制限超過: 429 Too Many Requests
- レスポンスヘッダーで残り回数を返す
```

### 課題
**ミドルウェアとテストを実装してください**

<details>
<summary>💡 解答例</summary>

```php
// app/Http/Middleware/ApiRateLimiter.php
class ApiRateLimiter
{
    private const RATE_LIMITS = [
        'free' => 100,
        'paid' => 1000,
        'enterprise' => 10000,
    ];

    public function handle($request, Closure $next)
    {
        $userPlan = $request->user()->plan ?? 'free';
        $limit = self::RATE_LIMITS[$userPlan];
        
        $key = 'api_rate_limit:' . $request->user()->id;
        $current = Cache::get($key, 0);

        if ($current >= $limit) {
            return response()->json([
                'error' => 'Rate limit exceeded',
                'limit' => $limit,
                'reset_at' => now()->addHour()->timestamp,
            ], 429);
        }

        Cache::put($key, $current + 1, now()->addHour());

        $response = $next($request);
        
        // レスポンスヘッダーに残り回数を追加
        $remaining = $limit - ($current + 1);
        $response->header('X-RateLimit-Limit', $limit);
        $response->header('X-RateLimit-Remaining', $remaining);

        return $response;
    }
}

// tests/Feature/ApiRateLimiterTest.php
class ApiRateLimiterTest extends TestCase
{
    protected function setUp(): void
    {
        parent::setUp();
        Cache::flush();
    }

    /** @test 無料プラン - 100リクエスト境界値 */
    public function 無料プラン_99回目リクエスト_成功()
    {
        $user = User::factory()->create(['plan' => 'free']);

        // 99回リクエスト
        for ($i = 0; $i < 99; $i++) {
            Cache::increment('api_rate_limit:' . $user->id);
        }

        $response = $this->actingAs($user)->getJson('/api/data');

        $response->assertStatus(200)
                 ->assertHeader('X-RateLimit-Remaining', '0');
    }

    /** @test */
    public function 無料プラン_100回目リクエスト_制限超過()
    {
        $user = User::factory()->create(['plan' => 'free']);

        // 100回リクエスト済み
        Cache::put('api_rate_limit:' . $user->id, 100, now()->addHour());

        $response = $this->actingAs($user)->getJson('/api/data');

        $response->assertStatus(429)
                 ->assertJson(['error' => 'Rate limit exceeded']);
    }

    /** @test 有料プラン - 1000リクエスト境界値 */
    public function 有料プラン_999回目リクエスト_成功()
    {
        $user = User::factory()->create(['plan' => 'paid']);

        Cache::put('api_rate_limit:' . $user->id, 999, now()->addHour());

        $response = $this->actingAs($user)->getJson('/api/data');

        $response->assertStatus(200)
                 ->assertHeader('X-RateLimit-Limit', '1000')
                 ->assertHeader('X-RateLimit-Remaining', '0');
    }

    /** @test */
    public function 有料プラン_1000回目リクエスト_制限超過()
    {
        $user = User::factory()->create(['plan' => 'paid']);

        Cache::put('api_rate_limit:' . $user->id, 1000, now()->addHour());

        $response = $this->actingAs($user)->getJson('/api/data');

        $response->assertStatus(429);
    }

    /** @test 企業プラン - 10000リクエスト境界値 */
    public function 企業プラン_9999回目リクエスト_成功()
    {
        $user = User::factory()->create(['plan' => 'enterprise']);

        Cache::put('api_rate_limit:' . $user->id, 9999, now()->addHour());

        $response = $this->actingAs($user)->getJson('/api/data');

        $response->assertStatus(200)
                 ->assertHeader('X-RateLimit-Limit', '10000')
                 ->assertHeader('X-RateLimit-Remaining', '0');
    }

    /** @test */
    public function 企業プラン_10000回目リクエスト_制限超過()
    {
        $user = User::factory()->create(['plan' => 'enterprise']);

        Cache::put('api_rate_limit:' . $user->id, 10000, now()->addHour());

        $response = $this->actingAs($user)->getJson('/api/data');

        $response->assertStatus(429);
    }
}
```
</details>

---

## 🎯 演習5: パフォーマンステスト境界値【難易度: ★★★】

### 📝 実務シナリオ
```
データベースページネーション
- 1ページあたり: 10-100件
- 最大ページ数: 1000ページまで
- レスポンスタイム: 500ms以内
- 大量データでの性能劣化を検証
```

### 課題
**パフォーマンス境界値を含むテストを実装してください**

<details>
<summary>💡 解答例</summary>

```php
class ProductRepository
{
    private const MIN_PER_PAGE = 10;
    private const MAX_PER_PAGE = 100;
    private const MAX_PAGE = 1000;

    public function paginate(int $page, int $perPage): Collection
    {
        if ($perPage < self::MIN_PER_PAGE || $perPage > self::MAX_PER_PAGE) {
            throw new InvalidArgumentException(
                "Per page must be between " . self::MIN_PER_PAGE . " and " . self::MAX_PER_PAGE
            );
        }

        if ($page < 1 || $page > self::MAX_PAGE) {
            throw new InvalidArgumentException(
                "Page must be between 1 and " . self::MAX_PAGE
            );
        }

        $offset = ($page - 1) * $perPage;
        
        return Product::offset($offset)->limit($perPage)->get();
    }
}

class ProductRepositoryTest extends TestCase
{
    private ProductRepository $repository;

    protected function setUp(): void
    {
        parent::setUp();
        $this->repository = new ProductRepository();
        
        // テストデータを10万件作成
        Product::factory()->count(100000)->create();
    }

    /** @test perPage境界値テスト */
    public function 9件取得_例外()
    {
        $this->expectException(InvalidArgumentException::class);
        $this->repository->paginate(1, 9);
    }

    /** @test */
    public function 10件取得_成功()
    {
        $result = $this->repository->paginate(1, 10);
        $this->assertCount(10, $result);
    }

    /** @test */
    public function 100件取得_成功()
    {
        $result = $this->repository->paginate(1, 100);
        $this->assertCount(100, $result);
    }

    /** @test */
    public function 101件取得_例外()
    {
        $this->expectException(InvalidArgumentException::class);
        $this->repository->paginate(1, 101);
    }

    /** @test ページ番号境界値テスト */
    public function ページ0_例外()
    {
        $this->expectException(InvalidArgumentException::class);
        $this->repository->paginate(0, 10);
    }

    /** @test */
    public function ページ1_成功()
    {
        $result = $this->repository->paginate(1, 10);
        $this->assertCount(10, $result);
    }

    /** @test */
    public function ページ1000_成功()
    {
        $result = $this->repository->paginate(1000, 10);
        $this->assertInstanceOf(Collection::class, $result);
    }

    /** @test */
    public function ページ1001_例外()
    {
        $this->expectException(InvalidArgumentException::class);
        $this->repository->paginate(1001, 10);
    }

    /** @test パフォーマンス境界値テスト */
    public function 10件取得_500ms以内()
    {
        $start = microtime(true);
        $this->repository->paginate(1, 10);
        $elapsed = (microtime(true) - $start) * 1000;

        $this->assertLessThan(500, $elapsed, "Response time exceeded 500ms");
    }

    /** @test */
    public function 100件取得_500ms以内()
    {
        $start = microtime(true);
        $this->repository->paginate(1, 100);
        $elapsed = (microtime(true) - $start) * 1000;

        $this->assertLessThan(500, $elapsed, "Response time exceeded 500ms");
    }

    /** @test */
    public function 最終ページ取得_500ms以内()
    {
        $start = microtime(true);
        $this->repository->paginate(1000, 100);
        $elapsed = (microtime(true) - $start) * 1000;

        $this->assertLessThan(500, $elapsed, "Response time exceeded 500ms");
    }

    /** @test 境界でのデータ整合性 */
    public function ページ境界でのデータ重複なし()
    {
        $page1 = $this->repository->paginate(1, 10);
        $page2 = $this->repository->paginate(2, 10);

        $ids1 = $page1->pluck('id')->toArray();
        $ids2 = $page2->pluck('id')->toArray();

        $this->assertEmpty(array_intersect($ids1, $ids2), "Pages have overlapping data");
    }
}
```
</details>

---

## 📊 学習成果の確認

### ✅ **上級スキルチェックリスト**

- [ ] 複数条件の境界値を特定・実装できた（演習1-2）
- [ ] Laravel実践シナリオを実装できた（演習3）
- [ ] API/レート制限の境界値を扱えた（演習4）
- [ ] パフォーマンス境界値を考慮できた（演習5）

### 📝 **振り返り**

**できたこと**
```
例:
- ユーザー種別ごとの境界値設計
- 状態依存の複雑な境界値
- Laravel Featureテストの実装
```

**難しかったこと**
```
例:
- 複数条件の組み合わせパターン
- パフォーマンステストの設計
- データプロバイダの効果的活用
```

**実務で活かしたいこと**
```
例:
- 次のプロジェクトでの適用
- チームへの知識共有
- テスト自動化への組み込み
```

---

## 🚀 次のステップ

**到達基準**:
- 演習5問中4問以上実装完了
- 実務シナリオで適用イメージができる

**次は**: `05_追加演習・補強練習.md` で弱点強化

**💪 実務レベルに到達！次は特定分野の深掘りです 🎉**