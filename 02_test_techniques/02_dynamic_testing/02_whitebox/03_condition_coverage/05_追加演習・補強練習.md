# ğŸ’ª æ¡ä»¶ç¶²ç¾…ï¼ˆCondition Coverageï¼‰- è¿½åŠ æ¼”ç¿’ãƒ»è£œå¼·ç·´ç¿’

## ğŸ¯ è£œå¼·ç·´ç¿’ã®ç›®çš„
- æ¡ä»¶ç¶²ç¾…ã®ç†è§£ã‚’å¤šæ§˜ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã§æ·±ã‚ã‚‹
- ç‰¹æ®Šãªã‚±ãƒ¼ã‚¹ï¼ˆè¨€èªå›ºæœ‰ã®ç‰¹å¾´ç­‰ï¼‰ã§ã®é©ç”¨æ–¹æ³•ç¿’å¾—
- å®Ÿå‹™ã§ã‚ˆãã‚ã‚‹è¤‡é›‘ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã®å…‹æœ

---

## ğŸ’ª è£œå¼·æ¼”ç¿’ 1ï¼šè¨€èªå›ºæœ‰ã®æ¡ä»¶è©•ä¾¡

### ğŸ“ å•é¡Œï¼šNullableå‹ã¨æ¡ä»¶ç¶²ç¾…
ä»¥ä¸‹ã®C#ã‚³ãƒ¼ãƒ‰ã§æ¡ä»¶ç¶²ç¾…ã‚’é”æˆã—ã¦ãã ã•ã„ã€‚

```csharp
public class NullableConditionProcessor 
{
    public ProcessResult ProcessData(int? value, string data, bool? flag)
    {
        // Nullableå‹ã®æ¡ä»¶è©•ä¾¡
        if (value.HasValue && value.Value > 0 && 
            !string.IsNullOrEmpty(data) && 
            flag == true)
        {
            return ProcessResult.Success($"Processed: {value.Value} with {data}");
        }
        
        // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®è¤‡åˆæ¡ä»¶
        if (!value.HasValue || value.Value <= 0)
        {
            return ProcessResult.Error("Invalid value");
        }
        
        if (string.IsNullOrEmpty(data) && (flag == null || flag == false))
        {
            return ProcessResult.Error("Missing data and flag");
        }
        
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†
        if (flag == null && !string.IsNullOrEmpty(data))
        {
            return ProcessResult.Warning("Flag not specified, using default");
        }
        
        return ProcessResult.Error("Unhandled condition");
    }
}
```

### ğŸ¤” åˆ†ææ‰‹é †

#### ã‚¹ãƒ†ãƒƒãƒ—1: Nullableå‹ã®æ¡ä»¶ç‰¹å®š
```csharp
// ç¬¬1ã®è¤‡åˆæ¡ä»¶
if (value.HasValue && value.Value > 0 && 
    !string.IsNullOrEmpty(data) && 
    flag == true)

// å€‹åˆ¥æ¡ä»¶:
// 1. value.HasValue
// 2. value.Value > 0
// 3. !string.IsNullOrEmpty(data) (= string.IsNullOrEmpty(data) ã®NOT)
// 4. flag == true
```

#### ã‚¹ãƒ†ãƒƒãƒ—2: 3å€¤è«–ç†ã®è€ƒæ…®
```csharp
// bool? flag ã®å¯èƒ½ãªå€¤: true, false, null
// flag == true â†’ true/false
// flag == false â†’ true/false  
// flag == null â†’ true/false
```

### âœ… è§£ç­”ï¼šNullableå‹å¯¾å¿œã®æ¡ä»¶ç¶²ç¾…ãƒ†ã‚¹ãƒˆ

```csharp
[TestClass]
public class NullableConditionProcessorTests
{
    private NullableConditionProcessor processor;
    
    [TestInitialize]
    public void Setup()
    {
        processor = new NullableConditionProcessor();
    }
    
    [TestMethod]
    public void TestProcessData_NullableConditionCoverage()
    {
        // === ç¬¬1è¤‡åˆæ¡ä»¶ã®æ¡ä»¶ç¶²ç¾… ===
        
        // æ¡ä»¶1-True: value.HasValue = true
        ProcessResult result1 = processor.ProcessData(5, "test", true);
        Assert.AreEqual("Success", result1.Status);
        
        // æ¡ä»¶1-False: value.HasValue = false
        ProcessResult result2 = processor.ProcessData(null, "test", true);
        Assert.AreEqual("Error", result2.Status);
        Assert.AreEqual("Invalid value", result2.Message);
        
        // æ¡ä»¶2-True: value.Value > 0 (value.HasValueãŒtrueã®å ´åˆ)
        ProcessResult result3 = processor.ProcessData(10, "test", true);
        Assert.AreEqual("Success", result3.Status);
        
        // æ¡ä»¶2-False: value.Value <= 0
        ProcessResult result4 = processor.ProcessData(-5, "test", true);
        Assert.AreEqual("Error", result4.Status);
        
        // æ¡ä»¶3-True: !string.IsNullOrEmpty(data) = true (dataãŒæœ‰åŠ¹)
        ProcessResult result5 = processor.ProcessData(5, "valid", true);
        Assert.AreEqual("Success", result5.Status);
        
        // æ¡ä»¶3-False: string.IsNullOrEmpty(data) = true
        ProcessResult result6 = processor.ProcessData(5, "", true);
        Assert.AreEqual("Error", result6.Status);
        
        ProcessResult result7 = processor.ProcessData(5, null, true);
        Assert.AreEqual("Error", result7.Status);
        
        // æ¡ä»¶4-True: flag == true
        ProcessResult result8 = processor.ProcessData(5, "test", true);
        Assert.AreEqual("Success", result8.Status);
        
        // æ¡ä»¶4-False: flag != true (falseã¨nullã‚’å«ã‚€)
        ProcessResult result9 = processor.ProcessData(5, "test", false);
        Assert.AreEqual("Error", result9.Status);
        
        ProcessResult result10 = processor.ProcessData(5, "test", null);
        Assert.AreEqual("Warning", result10.Status);
        
        // === ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æ¡ä»¶ã®ç¶²ç¾… ===
        
        // ç¬¬2è¤‡åˆæ¡ä»¶: !value.HasValue || value.Value <= 0
        // æ¡ä»¶1-True: !value.HasValue = true
        ProcessResult errorResult1 = processor.ProcessData(null, "test", false);
        Assert.AreEqual("Error", errorResult1.Status);
        Assert.AreEqual("Invalid value", errorResult1.Message);
        
        // æ¡ä»¶2-True: value.Value <= 0
        ProcessResult errorResult2 = processor.ProcessData(0, "test", false);
        Assert.AreEqual("Error", errorResult2.Status);
        
        // ç¬¬3è¤‡åˆæ¡ä»¶: string.IsNullOrEmpty(data) && (flag == null || flag == false)
        ProcessResult errorResult3 = processor.ProcessData(5, "", null);  // ä¸¡æ¡ä»¶true
        Assert.AreEqual("Error", errorResult3.Status);
        Assert.AreEqual("Missing data and flag", errorResult3.Message);
        
        ProcessResult errorResult4 = processor.ProcessData(5, "", false); // ä¸¡æ¡ä»¶true
        Assert.AreEqual("Error", errorResult4.Status);
        
        // ç¬¬4è¤‡åˆæ¡ä»¶: flag == null && !string.IsNullOrEmpty(data)
        ProcessResult warningResult = processor.ProcessData(5, "test", null);
        Assert.AreEqual("Warning", warningResult.Status);
        Assert.AreEqual("Flag not specified, using default", warningResult.Message);
    }
    
    [TestMethod]
    public void TestNullableSpecificConditions()
    {
        // Nullableå‹ç‰¹æœ‰ã®æ¡ä»¶ãƒ‘ã‚¿ãƒ¼ãƒ³
        
        // bool? ã®3å€¤ã™ã¹ã¦ã‚’ãƒ†ã‚¹ãƒˆ
        Assert.AreEqual("Success", processor.ProcessData(1, "test", true).Status);   // true
        Assert.AreEqual("Error", processor.ProcessData(1, "test", false).Status);    // false
        Assert.AreEqual("Warning", processor.ProcessData(1, "test", null).Status);   // null
        
        // int? ã®2çŠ¶æ…‹ã‚’ãƒ†ã‚¹ãƒˆ
        Assert.AreEqual("Success", processor.ProcessData(1, "test", true).Status);   // HasValue
        Assert.AreEqual("Error", processor.ProcessData(null, "test", true).Status);  // !HasValue
    }
}
```

---

## ğŸ’ª è£œå¼·æ¼”ç¿’ 2ï¼šJavaScript/TypeScriptã®æ¡ä»¶ç¶²ç¾…

### ğŸ“ å•é¡Œï¼šå‹å¼·åˆ¶ã¨çŸ­çµ¡è©•ä¾¡
ä»¥ä¸‹ã®JavaScriptã‚³ãƒ¼ãƒ‰ã§æ¡ä»¶ç¶²ç¾…ã‚’é”æˆã—ã¦ãã ã•ã„ã€‚

```javascript
class DataValidator {
    validateUserInput(user, settings, options) {
        // JavaScriptç‰¹æœ‰ã®å‹å¼·åˆ¶ã‚’å«ã‚€æ¡ä»¶
        if (user && user.name && user.name.trim() && 
            settings && settings.enabled && 
            (!options || options.strict !== false)) {
            
            return { valid: true, message: "Validation passed" };
        }
        
        // Falsyå€¤ã®è¤‡åˆãƒã‚§ãƒƒã‚¯
        if (!user || !user.name || user.name === '' || 
            user.name === null || user.name === undefined) {
            
            return { valid: false, message: "Invalid user name" };
        }
        
        // å‹ãƒã‚§ãƒƒã‚¯ã¨å€¤ãƒã‚§ãƒƒã‚¯ã®çµ„ã¿åˆã‚ã›
        if (typeof settings !== 'object' || 
            settings === null || 
            typeof settings.enabled !== 'boolean' ||
            settings.enabled === false) {
            
            return { valid: false, message: "Invalid settings" };
        }
        
        // Optional chainingé¢¨ã®æ¡ä»¶ãƒã‚§ãƒƒã‚¯
        if (options && 
            options.hasOwnProperty('strict') && 
            options.strict === false &&
            (!options.allowEmpty || options.allowEmpty !== true)) {
            
            return { valid: false, message: "Strict mode disabled but empty not allowed" };
        }
        
        return { valid: false, message: "Unknown validation failure" };
    }
    
    validateNumericRange(value, min, max, config) {
        // æ•°å€¤å¤‰æ›ã¨ç¯„å›²ãƒã‚§ãƒƒã‚¯
        const numValue = Number(value);
        
        if (isNaN(numValue) || 
            (!config || !config.allowInfinity) && !isFinite(numValue)) {
            
            return { valid: false, error: "Not a valid number" };
        }
        
        // ç¯„å›²ãƒã‚§ãƒƒã‚¯ã®è¤‡åˆæ¡ä»¶
        const hasMin = min !== null && min !== undefined && !isNaN(min);
        const hasMax = max !== null && max !== undefined && !isNaN(max);
        
        if ((hasMin && numValue < min) || 
            (hasMax && numValue > max) ||
            (hasMin && hasMax && min > max)) {
            
            return { valid: false, error: "Value out of range" };
        }
        
        // ç‰¹æ®Šå€¤ã®ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
        if ((numValue === 0 && config && config.disallowZero) ||
            (numValue < 0 && config && config.positiveOnly) ||
            (Number.isInteger(numValue) && config && config.decimalsOnly)) {
            
            return { valid: false, error: "Value violates constraints" };
        }
        
        return { valid: true, value: numValue };
    }
}
```

### âœ… è§£ç­”ï¼šJavaScriptç‰¹æœ‰ã®æ¡ä»¶ç¶²ç¾…ãƒ†ã‚¹ãƒˆ

```javascript
describe('DataValidator Condition Coverage', () => {
    let validator;
    
    beforeEach(() => {
        validator = new DataValidator();
    });
    
    describe('validateUserInput - Condition Coverage', () => {
        
        it('should cover all truthy/falsy conditions', () => {
            // === ç¬¬1è¤‡åˆæ¡ä»¶ã®æ¡ä»¶ç¶²ç¾… ===
            
            // æ¡ä»¶1-True: user (truthy)
            let result = validator.validateUserInput(
                { name: 'John' },     // user: truthy
                { enabled: true },    // settings: truthy, enabled: true
                undefined             // options: falsy (!options = true)
            );
            expect(result.valid).toBe(true);
            
            // æ¡ä»¶1-False: user (falsy)
            result = validator.validateUserInput(
                null,                 // user: falsy
                { enabled: true },
                undefined
            );
            expect(result.valid).toBe(false);
            expect(result.message).toBe("Invalid user name");
            
            // æ¡ä»¶2-True: user.name (truthy)
            result = validator.validateUserInput(
                { name: 'John' },     // user.name: truthy
                { enabled: true },
                undefined
            );
            expect(result.valid).toBe(true);
            
            // æ¡ä»¶2-False: user.name (falsy)
            result = validator.validateUserInput(
                { name: '' },         // user.name: falsy (ç©ºæ–‡å­—)
                { enabled: true },
                undefined
            );
            expect(result.valid).toBe(false);
            
            result = validator.validateUserInput(
                { name: null },       // user.name: falsy (null)
                { enabled: true },
                undefined
            );
            expect(result.valid).toBe(false);
            
            result = validator.validateUserInput(
                {},                   // user.name: undefined (falsy)
                { enabled: true },
                undefined
            );
            expect(result.valid).toBe(false);
            
            // æ¡ä»¶3-True: user.name.trim() (truthy - ç©ºç™½ã§ãªã„æ–‡å­—åˆ—)
            result = validator.validateUserInput(
                { name: '  John  ' }, // trimå¾Œ: truthy
                { enabled: true },
                undefined
            );
            expect(result.valid).toBe(true);
            
            // æ¡ä»¶3-False: user.name.trim() (falsy - ç©ºç™½ã®ã¿)
            result = validator.validateUserInput(
                { name: '   ' },      // trimå¾Œ: falsy
                { enabled: true },
                undefined
            );
            expect(result.valid).toBe(false);
            
            // æ¡ä»¶4-True: settings (truthy)
            result = validator.validateUserInput(
                { name: 'John' },
                { enabled: true },    // settings: truthy
                undefined
            );
            expect(result.valid).toBe(true);
            
            // æ¡ä»¶4-False: settings (falsy)
            result = validator.validateUserInput(
                { name: 'John' },
                null,                 // settings: falsy
                undefined
            );
            expect(result.valid).toBe(false);
            expect(result.message).toBe("Invalid settings");
            
            // æ¡ä»¶5-True: settings.enabled (true)
            result = validator.validateUserInput(
                { name: 'John' },
                { enabled: true },    // enabled: true
                undefined
            );
            expect(result.valid).toBe(true);
            
            // æ¡ä»¶5-False: settings.enabled (false)
            result = validator.validateUserInput(
                { name: 'John' },
                { enabled: false },   // enabled: false
                undefined
            );
            expect(result.valid).toBe(false);
            
            // æ¡ä»¶6-True: !options (options is falsy)
            result = validator.validateUserInput(
                { name: 'John' },
                { enabled: true },
                null                  // options: falsy (!options = true)
            );
            expect(result.valid).toBe(true);
            
            // æ¡ä»¶6-False: options.strict !== false (optionsãŒtruthyã§strict !== false)
            result = validator.validateUserInput(
                { name: 'John' },
                { enabled: true },
                { strict: true }      // options: truthy, strict !== false
            );
            expect(result.valid).toBe(true);
            
            result = validator.validateUserInput(
                { name: 'John' },
                { enabled: true },
                { strict: false }     // options: truthy, strict === false
            );
            expect(result.valid).toBe(false);
        });
        
        it('should test typeof conditions', () => {
            // typeof ãƒã‚§ãƒƒã‚¯ã®æ¡ä»¶ç¶²ç¾…
            
            // typeof settings !== 'object': true
            let result = validator.validateUserInput(
                { name: 'John' },
                'invalid',            // string (not object)
                undefined
            );
            expect(result.valid).toBe(false);
            expect(result.message).toBe("Invalid settings");
            
            result = validator.validateUserInput(
                { name: 'John' },
                42,                   // number (not object)
                undefined
            );
            expect(result.valid).toBe(false);
            
            // settings === null: true (typeof null === 'object' ã ãŒ null ãƒã‚§ãƒƒã‚¯)
            result = validator.validateUserInput(
                { name: 'John' },
                null,                 // null
                undefined
            );
            expect(result.valid).toBe(false);
            
            // typeof settings.enabled !== 'boolean': true
            result = validator.validateUserInput(
                { name: 'John' },
                { enabled: 'yes' },   // string (not boolean)
                undefined
            );
            expect(result.valid).toBe(false);
        });
    });
    
    describe('validateNumericRange - Condition Coverage', () => {
        
        it('should cover numeric conversion conditions', () => {
            // === æ•°å€¤å¤‰æ›ã®æ¡ä»¶ç¶²ç¾… ===
            
            // isNaN(numValue): true
            let result = validator.validateNumericRange('abc', 0, 100, {});
            expect(result.valid).toBe(false);
            expect(result.error).toBe("Not a valid number");
            
            // isNaN(numValue): false
            result = validator.validateNumericRange('42', 0, 100, {});
            expect(result.valid).toBe(true);
            
            // !isFinite(numValue): true (config.allowInfinity: false)
            result = validator.validateNumericRange('Infinity', 0, 100, { allowInfinity: false });
            expect(result.valid).toBe(false);
            
            // allowInfinity: true
            result = validator.validateNumericRange('Infinity', 0, 100, { allowInfinity: true });
            expect(result.valid).toBe(true);
            
            // !config: true (config falsy)
            result = validator.validateNumericRange('Infinity', 0, 100, null);
            expect(result.valid).toBe(false);
        });
        
        it('should cover range check conditions', () => {
            // === ç¯„å›²ãƒã‚§ãƒƒã‚¯ã®æ¡ä»¶ç¶²ç¾… ===
            
            // hasMin: true/false
            let result = validator.validateNumericRange(50, 10, 100, {});   // hasMin: true
            expect(result.valid).toBe(true);
            
            result = validator.validateNumericRange(50, null, 100, {});     // hasMin: false
            expect(result.valid).toBe(true);
            
            result = validator.validateNumericRange(50, undefined, 100, {}); // hasMin: false
            expect(result.valid).toBe(true);
            
            // hasMax: true/false
            result = validator.validateNumericRange(50, 10, 100, {});       // hasMax: true
            expect(result.valid).toBe(true);
            
            result = validator.validateNumericRange(50, 10, null, {});      // hasMax: false
            expect(result.valid).toBe(true);
            
            // numValue < min: true
            result = validator.validateNumericRange(5, 10, 100, {});
            expect(result.valid).toBe(false);
            expect(result.error).toBe("Value out of range");
            
            // numValue > max: true
            result = validator.validateNumericRange(150, 10, 100, {});
            expect(result.valid).toBe(false);
            
            // min > max: true (invalid range)
            result = validator.validateNumericRange(50, 100, 10, {});
            expect(result.valid).toBe(false);
        });
        
        it('should cover special value conditions', () => {
            // === ç‰¹æ®Šå€¤ã®æ¡ä»¶ç¶²ç¾… ===
            
            // numValue === 0 && config.disallowZero: true
            let result = validator.validateNumericRange(0, -10, 10, { disallowZero: true });
            expect(result.valid).toBe(false);
            expect(result.error).toBe("Value violates constraints");
            
            // numValue < 0 && config.positiveOnly: true  
            result = validator.validateNumericRange(-5, -10, 10, { positiveOnly: true });
            expect(result.valid).toBe(false);
            
            // Number.isInteger(numValue) && config.decimalsOnly: true
            result = validator.validateNumericRange(42, 0, 100, { decimalsOnly: true });
            expect(result.valid).toBe(false);
            
            // æ­£å¸¸ã‚±ãƒ¼ã‚¹ï¼ˆå…¨æ¡ä»¶falseï¼‰
            result = validator.validateNumericRange(42.5, 0, 100, { 
                disallowZero: false, 
                positiveOnly: false, 
                decimalsOnly: false 
            });
            expect(result.valid).toBe(true);
        });
    });
});
```

---

## ğŸ’ª è£œå¼·æ¼”ç¿’ 3ï¼šéåŒæœŸå‡¦ç†ã¨æ¡ä»¶ç¶²ç¾…

### ğŸ“ å•é¡Œï¼šPromiseãƒ»async/awaitã§ã®æ¡ä»¶ç¶²ç¾…
ä»¥ä¸‹ã®TypeScriptã‚³ãƒ¼ãƒ‰ã§æ¡ä»¶ç¶²ç¾…ã‚’é”æˆã—ã¦ãã ã•ã„ã€‚

```typescript
class AsyncDataProcessor {
    
    async processDataPipeline(
        input: DataInput, 
        config: ProcessingConfig, 
        context: ProcessingContext
    ): Promise<ProcessingResult> {
        
        // å‰å‡¦ç†æ¡ä»¶ãƒã‚§ãƒƒã‚¯
        if (!input || !input.data || input.data.length === 0) {
            return {
                success: false,
                error: "Invalid input data",
                code: "INPUT_ERROR"
            };
        }
        
        if (!config || (!config.enableValidation && !config.enableTransformation)) {
            return {
                success: false,
                error: "Invalid configuration",
                code: "CONFIG_ERROR"
            };
        }
        
        try {
            let processedData = input.data;
            
            // æ¤œè¨¼ãƒ•ã‚§ãƒ¼ã‚º
            if (config.enableValidation) {
                const validationResult = await this.validateData(processedData, config.validationRules);
                
                if (!validationResult.isValid && 
                    (!config.continueOnValidationError || validationResult.severity === 'CRITICAL')) {
                    
                    return {
                        success: false,
                        error: `Validation failed: ${validationResult.message}`,
                        code: "VALIDATION_ERROR"
                    };
                }
                
                if (validationResult.isValid && config.filterInvalidData) {
                    processedData = validationResult.validData;
                }
            }
            
            // å¤‰æ›ãƒ•ã‚§ãƒ¼ã‚º
            if (config.enableTransformation) {
                const transformationResult = await this.transformData(processedData, config.transformationRules);
                
                if (!transformationResult.success) {
                    if (config.rollbackOnTransformationError && 
                        context.transactionId && 
                        context.supportRollback) {
                        
                        await this.rollbackTransaction(context.transactionId);
                        return {
                            success: false,
                            error: "Transformation failed, changes rolled back",
                            code: "TRANSFORMATION_ROLLBACK"
                        };
                    } else {
                        return {
                            success: false,
                            error: `Transformation failed: ${transformationResult.error}`,
                            code: "TRANSFORMATION_ERROR"
                        };
                    }
                }
                
                processedData = transformationResult.data;
            }
            
            // å¾Œå‡¦ç†æ¡ä»¶ãƒã‚§ãƒƒã‚¯
            if (processedData.length === 0 && !config.allowEmptyResult) {
                return {
                    success: false,
                    error: "Processing resulted in empty data",
                    code: "EMPTY_RESULT"
                };
            }
            
            // ä¿å­˜å‡¦ç†
            if (config.enablePersistence && 
                (!context.readOnlyMode || context.forceWrite)) {
                
                const persistResult = await this.persistData(processedData, context);
                
                if (!persistResult.success && config.requireSuccessfulPersistence) {
                    return {
                        success: false,
                        error: "Data persistence failed",
                        code: "PERSISTENCE_ERROR"
                    };
                }
            }
            
            return {
                success: true,
                data: processedData,
                metadata: {
                    originalCount: input.data.length,
                    processedCount: processedData.length,
                    validationEnabled: config.enableValidation,
                    transformationEnabled: config.enableTransformation
                }
            };
            
        } catch (error) {
            // ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®æ¡ä»¶åˆ†å²
            if (error instanceof ValidationError && config.treatValidationErrorsAsWarnings) {
                return {
                    success: true,
                    data: input.data,
                    warnings: [error.message]
                };
            } else if (error instanceof TimeoutError && config.retryOnTimeout) {
                return await this.processDataPipeline(input, config, context); // å†è©¦è¡Œ
            } else {
                return {
                    success: false,
                    error: `Unexpected error: ${error.message}`,
                    code: "UNEXPECTED_ERROR"
                };
            }
        }
    }
    
    // ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆãƒ¢ãƒƒã‚¯ç”¨ï¼‰
    private async validateData(data: any[], rules: ValidationRules): Promise<ValidationResult> {
        // å®Ÿè£…ã¯çœç•¥
        return { isValid: true, validData: data, message: "", severity: "INFO" };
    }
    
    private async transformData(data: any[], rules: TransformationRules): Promise<TransformationResult> {
        // å®Ÿè£…ã¯çœç•¥
        return { success: true, data: data };
    }
    
    private async rollbackTransaction(transactionId: string): Promise<void> {
        // å®Ÿè£…ã¯çœç•¥
    }
    
    private async persistData(data: any[], context: ProcessingContext): Promise<PersistenceResult> {
        // å®Ÿè£…ã¯çœç•¥
        return { success: true };
    }
}
```

### âœ… è§£ç­”ï¼šéåŒæœŸå‡¦ç†ã®æ¡ä»¶ç¶²ç¾…ãƒ†ã‚¹ãƒˆ

```typescript
describe('AsyncDataProcessor Condition Coverage', () => {
    let processor: AsyncDataProcessor;
    let mockValidateData: jest.SpyInstance;
    let mockTransformData: jest.SpyInstance;
    let mockRollbackTransaction: jest.SpyInstance;
    let mockPersistData: jest.SpyInstance;
    
    beforeEach(() => {
        processor = new AsyncDataProcessor();
        
        // ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ¢ãƒƒã‚¯
        mockValidateData = jest.spyOn(processor as any, 'validateData');
        mockTransformData = jest.spyOn(processor as any, 'transformData');
        mockRollbackTransaction = jest.spyOn(processor as any, 'rollbackTransaction');
        mockPersistData = jest.spyOn(processor as any, 'persistData');
    });
    
    afterEach(() => {
        jest.restoreAllMocks();
    });
    
    describe('Input Validation Conditions', () => {
        
        it('should cover all input validation conditions', async () => {
            // === å…¥åŠ›æ¤œè¨¼ã®æ¡ä»¶ç¶²ç¾… ===
            
            // æ¡ä»¶1-True: !input
            let result = await processor.processDataPipeline(
                null,
                { enableValidation: true, enableTransformation: false },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(false);
            expect(result.code).toBe("INPUT_ERROR");
            
            // æ¡ä»¶2-True: !input.data
            result = await processor.processDataPipeline(
                { data: null },
                { enableValidation: true, enableTransformation: false },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(false);
            
            // æ¡ä»¶3-True: input.data.length === 0
            result = await processor.processDataPipeline(
                { data: [] },
                { enableValidation: true, enableTransformation: false },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(false);
            
            // å…¨æ¡ä»¶Falseï¼ˆæ­£å¸¸å…¥åŠ›ï¼‰
            mockValidateData.mockResolvedValue({ isValid: true, validData: [1, 2, 3], message: "", severity: "INFO" });
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },  // æœ‰åŠ¹ãªå…¥åŠ›
                { enableValidation: true, enableTransformation: false },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(true);
        });
        
        it('should cover configuration validation conditions', async () => {
            // === è¨­å®šæ¤œè¨¼ã®æ¡ä»¶ç¶²ç¾… ===
            
            // æ¡ä»¶1-True: !config
            let result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                null,
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(false);
            expect(result.code).toBe("CONFIG_ERROR");
            
            // æ¡ä»¶2-True: !enableValidation && !enableTransformation
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { enableValidation: false, enableTransformation: false },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(false);
            expect(result.code).toBe("CONFIG_ERROR");
            
            // æ¡ä»¶2-False: enableValidation || enableTransformation
            mockValidateData.mockResolvedValue({ isValid: true, validData: [1, 2, 3], message: "", severity: "INFO" });
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { enableValidation: true, enableTransformation: false }, // validationæœ‰åŠ¹
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(true);
        });
    });
    
    describe('Validation Phase Conditions', () => {
        
        it('should cover validation conditions', async () => {
            // === æ¤œè¨¼ãƒ•ã‚§ãƒ¼ã‚ºã®æ¡ä»¶ç¶²ç¾… ===
            
            // enableValidation: true
            mockValidateData.mockResolvedValue({ isValid: true, validData: [1, 2, 3], message: "", severity: "INFO" });
            
            let result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { enableValidation: true, enableTransformation: false },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(true);
            expect(mockValidateData).toHaveBeenCalled();
            
            // enableValidation: false
            mockValidateData.mockClear();
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { enableValidation: false, enableTransformation: true }, // validationç„¡åŠ¹
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(mockValidateData).not.toHaveBeenCalled();
            
            // æ¤œè¨¼å¤±æ•— + ç¶™ç¶šä¸å¯
            mockValidateData.mockResolvedValue({ 
                isValid: false, 
                validData: [], 
                message: "Validation failed", 
                severity: "CRITICAL" 
            });
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    continueOnValidationError: false  // æ¤œè¨¼ã‚¨ãƒ©ãƒ¼æ™‚ç¶™ç¶šã—ãªã„
                },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(false);
            expect(result.code).toBe("VALIDATION_ERROR");
            
            // æ¤œè¨¼å¤±æ•— + ç¶™ç¶šå¯èƒ½ã ãŒCRITICAL
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    continueOnValidationError: true,  // ç¶™ç¶šã™ã‚‹è¨­å®šã ãŒ
                    // CRITICAL severityãªã®ã§åœæ­¢
                },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(false);
            
            // æ¤œè¨¼æˆåŠŸ + ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            mockValidateData.mockResolvedValue({ 
                isValid: true, 
                validData: [1, 3], // ãƒ•ã‚£ãƒ«ã‚¿å¾Œã®ãƒ‡ãƒ¼ã‚¿
                message: "", 
                severity: "INFO" 
            });
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    filterInvalidData: true  // ç„¡åŠ¹ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
                },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(true);
            expect(result.data).toEqual([1, 3]);
        });
    });
    
    describe('Transformation Phase Conditions', () => {
        
        it('should cover transformation and rollback conditions', async () => {
            // === å¤‰æ›ãƒ•ã‚§ãƒ¼ã‚ºã®æ¡ä»¶ç¶²ç¾… ===
            
            mockValidateData.mockResolvedValue({ isValid: true, validData: [1, 2, 3], message: "", severity: "INFO" });
            
            // å¤‰æ›æˆåŠŸ
            mockTransformData.mockResolvedValue({ success: true, data: [2, 4, 6] });
            
            let result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { enableValidation: true, enableTransformation: true },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(true);
            expect(result.data).toEqual([2, 4, 6]);
            
            // å¤‰æ›å¤±æ•— + ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ¡ä»¶ã™ã¹ã¦True
            mockTransformData.mockResolvedValue({ success: false, error: "Transform failed" });
            mockRollbackTransaction.mockResolvedValue(undefined);
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: true,
                    rollbackOnTransformationError: true  // ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æœ‰åŠ¹
                },
                { 
                    transactionId: "test123",  // transactionIdæœ‰åŠ¹
                    supportRollback: true,     // ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚µãƒãƒ¼ãƒˆ
                    readOnlyMode: false 
                }
            );
            expect(result.success).toBe(false);
            expect(result.code).toBe("TRANSFORMATION_ROLLBACK");
            expect(mockRollbackTransaction).toHaveBeenCalledWith("test123");
            
            // å¤‰æ›å¤±æ•— + ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ¡ä»¶ã®ä¸€éƒ¨False
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: true,
                    rollbackOnTransformationError: true
                },
                { 
                    transactionId: null,       // transactionIdç„¡åŠ¹
                    supportRollback: true,
                    readOnlyMode: false 
                }
            );
            expect(result.success).toBe(false);
            expect(result.code).toBe("TRANSFORMATION_ERROR"); // ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã•ã‚Œãªã„
        });
    });
    
    describe('Exception Handling Conditions', () => {
        
        it('should cover exception handling conditions', async () => {
            // === ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®æ¡ä»¶ç¶²ç¾… ===
            
            // ValidationError + treatValidationErrorsAsWarnings: true
            const validationError = new ValidationError("Validation issue");
            mockValidateData.mockRejectedValue(validationError);
            
            let result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    treatValidationErrorsAsWarnings: true  // è­¦å‘Šã¨ã—ã¦æ‰±ã†
                },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(true);
            expect(result.warnings).toContain("Validation issue");
            
            // TimeoutError + retryOnTimeout: true
            const timeoutError = new TimeoutError("Operation timed out");
            mockValidateData
                .mockRejectedValueOnce(timeoutError)  // 1å›ç›®ã¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
                .mockResolvedValue({ isValid: true, validData: [1, 2, 3], message: "", severity: "INFO" }); // 2å›ç›®ã¯æˆåŠŸ
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    retryOnTimeout: true  // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚å†è©¦è¡Œ
                },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(true); // å†è©¦è¡Œã§æˆåŠŸ
            
            // ãã®ä»–ã®ä¾‹å¤–
            const unexpectedError = new Error("Unexpected issue");
            mockValidateData.mockRejectedValue(unexpectedError);
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    treatValidationErrorsAsWarnings: false
                },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(false);
            expect(result.code).toBe("UNEXPECTED_ERROR");
        });
    });
    
    describe('Persistence Conditions', () => {
        
        it('should cover persistence conditions', async () => {
            mockValidateData.mockResolvedValue({ isValid: true, validData: [1, 2, 3], message: "", severity: "INFO" });
            mockPersistData.mockResolvedValue({ success: true });
            
            // === æ°¸ç¶šåŒ–ã®æ¡ä»¶ç¶²ç¾… ===
            
            // enablePersistence: true, readOnlyMode: false
            let result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    enablePersistence: true  // æ°¸ç¶šåŒ–æœ‰åŠ¹
                },
                { 
                    transactionId: "test", 
                    supportRollback: true, 
                    readOnlyMode: false,  // èª­ã¿å–ã‚Šå°‚ç”¨ã§ãªã„
                    forceWrite: false
                }
            );
            expect(result.success).toBe(true);
            expect(mockPersistData).toHaveBeenCalled();
            
            // enablePersistence: true, readOnlyMode: true, forceWrite: true
            mockPersistData.mockClear();
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    enablePersistence: true
                },
                { 
                    transactionId: "test", 
                    supportRollback: true, 
                    readOnlyMode: true,   // èª­ã¿å–ã‚Šå°‚ç”¨ã ãŒ
                    forceWrite: true      // å¼·åˆ¶æ›¸ãè¾¼ã¿
                }
            );
            expect(result.success).toBe(true);
            expect(mockPersistData).toHaveBeenCalled();
            
            // enablePersistence: true, readOnlyMode: true, forceWrite: false
            mockPersistData.mockClear();
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    enablePersistence: true
                },
                { 
                    transactionId: "test", 
                    supportRollback: true, 
                    readOnlyMode: true,   // èª­ã¿å–ã‚Šå°‚ç”¨
                    forceWrite: false     // å¼·åˆ¶æ›¸ãè¾¼ã¿ãªã—
                }
            );
            expect(result.success).toBe(true);
            expect(mockPersistData).not.toHaveBeenCalled(); // æ°¸ç¶šåŒ–ã‚¹ã‚­ãƒƒãƒ—
            
            // æ°¸ç¶šåŒ–å¤±æ•— + requireSuccessfulPersistence: true
            mockPersistData.mockResolvedValue({ success: false });
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    enablePersistence: true,
                    requireSuccessfulPersistence: true  // æ°¸ç¶šåŒ–å¿…é ˆ
                },
                { 
                    transactionId: "test", 
                    supportRollback: true, 
                    readOnlyMode: false,
                    forceWrite: false
                }
            );
            expect(result.success).toBe(false);
            expect(result.code).toBe("PERSISTENCE_ERROR");
        });
    });
});

// ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ©ãƒ¼ã‚¯ãƒ©ã‚¹ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰
class ValidationError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'ValidationError';
    }
}

class TimeoutError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'TimeoutError';
    }
}
```

---

## ğŸ¯ è£œå¼·ç·´ç¿’ã§ã®é‡è¦ãªå­¦ç¿’ãƒã‚¤ãƒ³ãƒˆ

### ğŸ’¡ 1. è¨€èªå›ºæœ‰ã®ç‰¹å¾´ã¸ã®å¯¾å¿œ
- **Nullableå‹**: nullè¨±å®¹å‹ã§ã®3å€¤è«–ç†ã®è€ƒæ…®
- **å‹å¼·åˆ¶**: JavaScriptã®æš—é»™çš„å‹å¤‰æ›ã‚’è€ƒæ…®ã—ãŸæ¡ä»¶è¨­è¨ˆ
- **çŸ­çµ¡è©•ä¾¡**: è¨€èªä»•æ§˜ã«ã‚ˆã‚‹è©•ä¾¡åœæ­¢ã®å½±éŸ¿

### ğŸ’¡ 2. éåŒæœŸå‡¦ç†ã§ã®æ¡ä»¶ç¶²ç¾…
- **Promise/async-await**: éåŒæœŸæ¡ä»¶ã§ã®ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
- **ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå‡¦ç†**: æ™‚é–“åˆ¶é™ã«ã‚ˆã‚‹æ¡ä»¶åˆ†å²
- **å†è©¦è¡Œãƒ­ã‚¸ãƒƒã‚¯**: å¤±æ•—æ™‚ã®æ¡ä»¶ä»˜ãå†å®Ÿè¡Œ

### ğŸ’¡ 3. å®Ÿå‹™ã§ã®è¤‡é›‘æ€§ã¸ã®å¯¾å¿œ
- **æ®µéšçš„ãƒ†ã‚¹ãƒˆ**: ãƒ•ã‚§ãƒ¼ã‚ºæ¯ã®æ¡ä»¶ç¶²ç¾…
- **ãƒ¢ãƒƒã‚¯æˆ¦ç•¥**: å¤–éƒ¨ä¾å­˜ã®æ¡ä»¶åˆ¶å¾¡
- **ã‚¨ãƒ©ãƒ¼ã‚·ãƒŠãƒªã‚ª**: ä¾‹å¤–ç³»ã®ç¶²ç¾…çš„ãƒ†ã‚¹ãƒˆ

---

## ğŸš€ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

è£œå¼·ç·´ç¿’ã‚’å®Œäº†ã—ãŸã‚‰ã€ã€Œ06_å®Ÿå‹™é©ç”¨ã‚¬ã‚¤ãƒ‰.mdã€ã§å®Ÿéš›ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã®æ¡ä»¶ç¶²ç¾…æ´»ç”¨æ–¹æ³•ã‚’å­¦ç¿’ã—ã¾ã—ã‚‡ã†ã€‚

æ§˜ã€…ãªè¨€èªã‚„æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ã§ã®æ¡ä»¶ç¶²ç¾…é©ç”¨ã‚¹ã‚­ãƒ«ã‚’èº«ã«ã¤ã‘ã¦ã€ã©ã®ã‚ˆã†ãªç’°å¢ƒã§ã‚‚é«˜å“è³ªãªãƒ†ã‚¹ãƒˆã‚’å®Ÿç¾ã§ãã‚‹ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã‚’ç›®æŒ‡ã—ã¾ã—ã‚‡ã†ï¼
