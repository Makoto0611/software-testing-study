# 📚 条件網羅（Condition Coverage）- 理論学習・基本演習

## 🎯 学習目標
- 条件網羅の理論を正確に理解する
- 複合条件の分析と個別条件の特定ができる
- 条件網羅率の計算方法を習得する
- 基本的な条件網羅テストケースを設計できる

---

## 📊 条件網羅の理論

### 🔍 個別条件（Atomic Condition）とは

#### 💡 定義
**個別条件**とは、複合条件を構成する最小の論理単位で、それ以上分割できない条件のことです。

#### 📋 個別条件の特定例
```java
// 複合条件の分析例
public class LoginValidator {
    public boolean validateLogin(String username, String password, boolean rememberMe) {
        // 複合条件：4つの個別条件を含む
        if (username != null && username.length() > 0 && 
            password != null && password.length() >= 8) {
            return authenticateUser(username, password);
        }
        return false;
    }
}
```

**個別条件の特定**：
- **個別条件1**: `username != null`
- **個別条件2**: `username.length() > 0`
- **個別条件3**: `password != null`
- **個別条件4**: `password.length() >= 8`

### 📐 条件網羅率の計算

#### 💡 計算式
```
条件網羅率 = (True/Falseの両方が実行された個別条件数 / 総個別条件数) × 100%
```

#### 📊 計算例
```java
public class DiscountCalculator {
    public boolean isEligibleForDiscount(Customer customer, Order order) {
        // 複合条件：3つの個別条件
        if (customer.isVIP() && order.getAmount() >= 1000 && order.getItemCount() >= 5) {
            return true;
        }
        return false;
    }
}
```

**個別条件一覧**：
1. `customer.isVIP()`
2. `order.getAmount() >= 1000`
3. `order.getItemCount() >= 5`

**テストケース実行結果**：
```java
// TC1: isEligibleForDiscount(vipCustomer, largeOrder)
// customer.isVIP() = True, order.getAmount() >= 1000 = True, order.getItemCount() >= 5 = True

// TC2: isEligibleForDiscount(normalCustomer, smallOrder)  
// customer.isVIP() = False, order.getAmount() >= 1000 = False, order.getItemCount() >= 5 = False
```

**条件網羅分析**：
- 個別条件1: True ✅, False ✅ → 網羅済み
- 個別条件2: True ✅, False ✅ → 網羅済み  
- 個別条件3: True ✅, False ✅ → 網羅済み

**条件網羅率**: 3/3 × 100% = **100%**

---

## 💪 基本演習 1：単純な複合条件

### 📝 問題
以下のメソッドで**100%条件網羅**を達成するテストケースを設計してください。

```java
public class AccessController {
    public boolean canAccessResource(User user, Resource resource) {
        if (user != null && user.isActive() && resource.isPublic()) {
            return true;
        }
        return false;
    }
}
```

### 🤔 分析手順

#### ステップ1: 個別条件の特定
```java
if (user != null && user.isActive() && resource.isPublic()) {
//  [条件1]      && [条件2]        && [条件3]
```

- **個別条件1**: `user != null`
- **個別条件2**: `user.isActive()`
- **個別条件3**: `resource.isPublic()`

#### ステップ2: 必要なテストパターン
各個別条件でTrue/Falseの両方をテストする必要があります：

| 個別条件 | True | False |
|---------|------|-------|
| `user != null` | ✓ | ✓ |
| `user.isActive()` | ✓ | ✓ |
| `resource.isPublic()` | ✓ | ✓ |

#### ステップ3: テストケース設計

### ✅ 解答
```java
@Test
public void testCanAccessResource_ConditionCoverage() {
    AccessController controller = new AccessController();
    
    // テストデータ準備
    User activeUser = createUser(true);     // isActive() = true
    User inactiveUser = createUser(false);  // isActive() = false
    Resource publicResource = createResource(true);   // isPublic() = true
    Resource privateResource = createResource(false); // isPublic() = false
    
    // 条件1-True: user != null
    assertTrue(controller.canAccessResource(activeUser, publicResource));
    
    // 条件1-False: user == null
    assertFalse(controller.canAccessResource(null, publicResource));
    
    // 条件2-True: user.isActive() == true  
    assertTrue(controller.canAccessResource(activeUser, publicResource));
    
    // 条件2-False: user.isActive() == false
    assertFalse(controller.canAccessResource(inactiveUser, publicResource));
    
    // 条件3-True: resource.isPublic() == true
    assertTrue(controller.canAccessResource(activeUser, publicResource));
    
    // 条件3-False: resource.isPublic() == false
    assertFalse(controller.canAccessResource(activeUser, privateResource));
}
```

**効率化されたテストケース**：
```java
@Test
public void testCanAccessResource_OptimizedConditionCoverage() {
    AccessController controller = new AccessController();
    
    // 最小限のテストケースで条件網羅達成
    assertTrue(controller.canAccessResource(activeUser, publicResource));    // 全条件True
    assertFalse(controller.canAccessResource(null, publicResource));         // 条件1-False
    assertFalse(controller.canAccessResource(inactiveUser, publicResource)); // 条件2-False  
    assertFalse(controller.canAccessResource(activeUser, privateResource));  // 条件3-False
}
```

**条件網羅達成**: 3/3 = **100%**

---

## 💪 基本演習 2：OR演算子を含む複合条件

### 📝 問題
以下のメソッドで**100%条件網羅**を達成するテストケースを設計してください。

```java
public class ShippingCalculator {
    public boolean isFreeShipping(Order order, Customer customer) {
        // OR演算子を含む複合条件
        if (order.getAmount() >= 5000 || customer.isPremium() || order.hasPromotionCode()) {
            return true;
        }
        return false;
    }
}
```

### 🤔 分析手順

#### ステップ1: 個別条件の特定
```java
if (order.getAmount() >= 5000 || customer.isPremium() || order.hasPromotionCode()) {
//  [条件1]                   || [条件2]              || [条件3]
```

- **個別条件1**: `order.getAmount() >= 5000`
- **個別条件2**: `customer.isPremium()`
- **個別条件3**: `order.hasPromotionCode()`

#### ステップ2: OR演算子での短絡評価の考慮
OR演算子では、左の条件がTrueになると右の条件は評価されません：
```java
if (true || anything || anything) {  // 2番目、3番目の条件は評価されない
    // 処理
}
```

#### ステップ3: 各条件のTrue/Falseを確実にテスト

### ✅ 解答
```java
@Test
public void testIsFreeShipping_ConditionCoverage() {
    ShippingCalculator calculator = new ShippingCalculator();
    
    // テストデータ準備
    Order highValueOrder = createOrder(6000, false);     // amount >= 5000, no promo
    Order lowValueOrder = createOrder(3000, false);      // amount < 5000, no promo
    Order promoOrder = createOrder(3000, true);          // amount < 5000, with promo
    Customer premiumCustomer = createCustomer(true);     // isPremium = true
    Customer normalCustomer = createCustomer(false);     // isPremium = false
    
    // 条件1-True: order.getAmount() >= 5000
    assertTrue(calculator.isFreeShipping(highValueOrder, normalCustomer));
    
    // 条件1-False: order.getAmount() < 5000（他の条件でTrueにする）
    assertTrue(calculator.isFreeShipping(lowValueOrder, premiumCustomer));
    
    // 条件2-True: customer.isPremium() == true（条件1をFalseにする）
    assertTrue(calculator.isFreeShipping(lowValueOrder, premiumCustomer));
    
    // 条件2-False: customer.isPremium() == false（条件3でTrueにする）
    assertTrue(calculator.isFreeShipping(promoOrder, normalCustomer));
    
    // 条件3-True: order.hasPromotionCode() == true（他の条件をFalseにする）
    assertTrue(calculator.isFreeShipping(promoOrder, normalCustomer));
    
    // 条件3-False: order.hasPromotionCode() == false（全条件をFalseにする）
    assertFalse(calculator.isFreeShipping(lowValueOrder, normalCustomer));
}
```

**短絡評価を考慮したテストケース設計**：
```java
@Test
public void testIsFreeShipping_ConsideringShortCircuit() {
    // 条件1が先に評価されるため、条件1をFalseにして他の条件をテスト
    
    // 条件1-False, 条件2-True, 条件3-不明（短絡評価で未実行）
    assertTrue(calculator.isFreeShipping(lowValueOrder, premiumCustomer));
    
    // 条件1-False, 条件2-False, 条件3-True
    assertTrue(calculator.isFreeShipping(lowValueOrder_noPromo, normalCustomer));
    
    // 条件1-False, 条件2-False, 条件3-False
    assertFalse(calculator.isFreeShipping(lowValueOrder_noPromo, normalCustomer));
    
    // 条件1-True（他の条件は短絡評価で未実行）
    assertTrue(calculator.isFreeShipping(highValueOrder, normalCustomer));
}
```

---

## 💪 基本演習 3：ネストした複合条件

### 📝 問題
以下のメソッドで**100%条件網羅**を達成するテストケースを設計してください。

```java
public class LoanApprovalSystem {
    public boolean approveLoan(Applicant applicant, LoanRequest request) {
        // ネストした複合条件
        if (applicant.getCreditScore() >= 700 && 
            (request.getAmount() <= 100000 || applicant.getIncome() >= 80000)) {
            return true;
        }
        return false;
    }
}
```

### 🤔 分析手順

#### ステップ1: 複合条件の構造分析
```java
// 外側のAND演算子
if (applicant.getCreditScore() >= 700 && 
    // 内側のOR演算子（括弧でグループ化）
    (request.getAmount() <= 100000 || applicant.getIncome() >= 80000)) {
```

#### ステップ2: 個別条件の特定
- **個別条件1**: `applicant.getCreditScore() >= 700`
- **個別条件2**: `request.getAmount() <= 100000`
- **個別条件3**: `applicant.getIncome() >= 80000`

#### ステップ3: 論理構造の理解
```
全体 = 条件1 && (条件2 || 条件3)
```

### ✅ 解答
```java
@Test
public void testApproveLoan_NestedConditionCoverage() {
    LoanApprovalSystem system = new LoanApprovalSystem();
    
    // テストデータ準備
    Applicant highCreditApplicant = createApplicant(750, 60000);  // credit=750, income=60000
    Applicant lowCreditApplicant = createApplicant(650, 90000);   // credit=650, income=90000
    Applicant highIncomeApplicant = createApplicant(750, 90000);  // credit=750, income=90000
    
    LoanRequest smallLoan = createLoanRequest(50000);   // amount=50000
    LoanRequest largeLoan = createLoanRequest(150000);  // amount=150000
    
    // 条件1-True: creditScore >= 700
    assertTrue(system.approveLoan(highCreditApplicant, smallLoan));
    
    // 条件1-False: creditScore < 700
    assertFalse(system.approveLoan(lowCreditApplicant, smallLoan));
    
    // 条件2-True: amount <= 100000（条件1もTrueにする）
    assertTrue(system.approveLoan(highCreditApplicant, smallLoan));
    
    // 条件2-False: amount > 100000（条件3でTrueにする）
    assertTrue(system.approveLoan(highIncomeApplicant, largeLoan));
    
    // 条件3-True: income >= 80000（条件2をFalseにする）
    assertTrue(system.approveLoan(highIncomeApplicant, largeLoan));
    
    // 条件3-False: income < 80000（条件2でTrueにする）
    assertTrue(system.approveLoan(highCreditApplicant, smallLoan));
}
```

**論理組み合わせを明確にしたテストケース**：
```java
@Test
public void testApproveLoan_ExplicitLogicCombinations() {
    // Case 1: 条件1=T, 条件2=T, 条件3=任意 → 承認
    assertTrue(system.approveLoan(
        createApplicant(750, 60000),    // 条件1=T, 条件3=F
        createLoanRequest(50000)        // 条件2=T
    ));
    
    // Case 2: 条件1=T, 条件2=F, 条件3=T → 承認
    assertTrue(system.approveLoan(
        createApplicant(750, 90000),    // 条件1=T, 条件3=T
        createLoanRequest(150000)       // 条件2=F
    ));
    
    // Case 3: 条件1=T, 条件2=F, 条件3=F → 拒否
    assertFalse(system.approveLoan(
        createApplicant(750, 60000),    // 条件1=T, 条件3=F
        createLoanRequest(150000)       // 条件2=F
    ));
    
    // Case 4: 条件1=F, 条件2=任意, 条件3=任意 → 拒否
    assertFalse(system.approveLoan(
        createApplicant(650, 90000),    // 条件1=F
        createLoanRequest(50000)        // 条件2=T
    ));
}
```

---

## 💪 基本演習 4：複雑な複合条件

### 📝 問題
以下のメソッドで**100%条件網羅**を達成するテストケースを設計してください。

```java
public class SecurityValidator {
    public boolean isSecureOperation(User user, Operation op, SecurityContext context) {
        // 複雑な複合条件
        if ((user.isAuthenticated() && user.hasRole("ADMIN")) || 
            (user.isAuthenticated() && op.isPublic() && context.isTrustedNetwork()) ||
            (op.isEmergency() && context.isEmergencyMode())) {
            return true;
        }
        return false;
    }
}
```

### 🤔 分析手順

#### ステップ1: 論理構造の分析
```java
// 大きく3つのOR条件に分かれる
Condition_A || Condition_B || Condition_C

where:
// Condition_A = (user.isAuthenticated() && user.hasRole("ADMIN"))
// Condition_B = (user.isAuthenticated() && op.isPublic() && context.isTrustedNetwork())  
// Condition_C = (op.isEmergency() && context.isEmergencyMode())
```

#### ステップ2: 個別条件の特定
- **個別条件1**: `user.isAuthenticated()` (Condition_A, Bで使用)
- **個別条件2**: `user.hasRole("ADMIN")` (Condition_Aで使用)
- **個別条件3**: `op.isPublic()` (Condition_Bで使用)
- **個別条件4**: `context.isTrustedNetwork()` (Condition_Bで使用)
- **個別条件5**: `op.isEmergency()` (Condition_Cで使用)
- **個別条件6**: `context.isEmergencyMode()` (Condition_Cで使用)

### ✅ 解答
```java
@Test
public void testIsSecureOperation_ComplexConditionCoverage() {
    SecurityValidator validator = new SecurityValidator();
    
    // === 各個別条件のTrue/Falseをテスト ===
    
    // 条件1-True: user.isAuthenticated() = true（管理者で確認）
    assertTrue(validator.isSecureOperation(
        createUser(true, "ADMIN"),         // authenticated=T, role=ADMIN
        createOperation(false, false),     // public=F, emergency=F
        createContext(false, false)        // trusted=F, emergency=F
    ));
    
    // 条件1-False: user.isAuthenticated() = false（緊急操作で確認）
    assertTrue(validator.isSecureOperation(
        createUser(false, "USER"),         // authenticated=F, role=USER
        createOperation(false, true),      // public=F, emergency=T
        createContext(false, true)         // trusted=F, emergencyMode=T
    ));
    
    // 条件2-True: user.hasRole("ADMIN") = true
    assertTrue(validator.isSecureOperation(
        createUser(true, "ADMIN"),         // authenticated=T, role=ADMIN
        createOperation(false, false),     // public=F, emergency=F
        createContext(false, false)        // trusted=F, emergency=F
    ));
    
    // 条件2-False: user.hasRole("ADMIN") = false（公開操作で確認）
    assertTrue(validator.isSecureOperation(
        createUser(true, "USER"),          // authenticated=T, role=USER(≠ADMIN)
        createOperation(true, false),      // public=T, emergency=F
        createContext(true, false)         // trusted=T, emergency=F
    ));
    
    // 条件3-True: op.isPublic() = true
    assertTrue(validator.isSecureOperation(
        createUser(true, "USER"),          // authenticated=T, role=USER
        createOperation(true, false),      // public=T, emergency=F
        createContext(true, false)         // trusted=T, emergency=F
    ));
    
    // 条件3-False: op.isPublic() = false（管理者で確認）
    assertTrue(validator.isSecureOperation(
        createUser(true, "ADMIN"),         // authenticated=T, role=ADMIN
        createOperation(false, false),     // public=F, emergency=F
        createContext(false, false)        // trusted=F, emergency=F
    ));
    
    // 条件4-True: context.isTrustedNetwork() = true
    assertTrue(validator.isSecureOperation(
        createUser(true, "USER"),          // authenticated=T, role=USER
        createOperation(true, false),      // public=T, emergency=F
        createContext(true, false)         // trusted=T, emergency=F
    ));
    
    // 条件4-False: context.isTrustedNetwork() = false（管理者で確認）
    assertTrue(validator.isSecureOperation(
        createUser(true, "ADMIN"),         // authenticated=T, role=ADMIN
        createOperation(false, false),     // public=F, emergency=F
        createContext(false, false)        // trusted=F, emergency=F
    ));
    
    // 条件5-True: op.isEmergency() = true
    assertTrue(validator.isSecureOperation(
        createUser(false, "USER"),         // authenticated=F, role=USER
        createOperation(false, true),      // public=F, emergency=T
        createContext(false, true)         // trusted=F, emergencyMode=T
    ));
    
    // 条件5-False: op.isEmergency() = false（管理者で確認）
    assertTrue(validator.isSecureOperation(
        createUser(true, "ADMIN"),         // authenticated=T, role=ADMIN
        createOperation(false, false),     // public=F, emergency=F
        createContext(false, false)        // trusted=F, emergency=F
    ));
    
    // 条件6-True: context.isEmergencyMode() = true
    assertTrue(validator.isSecureOperation(
        createUser(false, "USER"),         // authenticated=F, role=USER
        createOperation(false, true),      // public=F, emergency=T
        createContext(false, true)         // trusted=F, emergencyMode=T
    ));
    
    // 条件6-False: context.isEmergencyMode() = false（管理者で確認）
    assertTrue(validator.isSecureOperation(
        createUser(true, "ADMIN"),         // authenticated=T, role=ADMIN
        createOperation(false, false),     // public=F, emergency=F
        createContext(false, false)        // trusted=F, emergencyMode=F
    ));
    
    // 全条件Falseのケース（拒否）
    assertFalse(validator.isSecureOperation(
        createUser(false, "USER"),         // authenticated=F, role=USER
        createOperation(false, false),     // public=F, emergency=F
        createContext(false, false)        // trusted=F, emergencyMode=F
    ));
}
```

---

## 🔍 条件網羅の実践ポイント

### 📊 効率的な条件特定方法

#### 💡 真理値表の活用
```java
// 複合条件: (A && B) || C
// 個別条件: A, B, C

| A | B | C | (A && B) | (A && B) || C |
|---|---|---|----------|---------------|
| T | T | T |    T     |       T       |
| T | T | F |    T     |       T       |
| T | F | T |    F     |       T       |
| T | F | F |    F     |       F       |  ← A=T, B=F テスト
| F | T | T |    F     |       T       |
| F | T | F |    F     |       F       |  ← A=F, B=T テスト
| F | F | T |    F     |       T       |
| F | F | F |    F     |       F       |  ← C=F テスト

// 条件網羅に必要なテストケース（最小）:
// A=T: 行1,2,3,4のいずれか, A=F: 行5,6,7,8のいずれか
// B=T: 行1,2,5,6のいずれか, B=F: 行3,4,7,8のいずれか  
// C=T: 行1,3,5,7のいずれか, C=F: 行2,4,6,8のいずれか
```

#### 💡 段階的テスト設計
```java
@Test
public void testConditionCoverage_Systematic() {
    // Step 1: 各条件のTrueを確実にテスト
    // Step 2: 各条件のFalseを確実にテスト
    // Step 3: 重複を排除して最小セットに最適化
    
    // 最終的な最小テストケースセット
    assertTrue(method(true, true, false));   // A=T, B=T, C=F
    assertFalse(method(true, false, false)); // A=T, B=F, C=F
    assertFalse(method(false, true, false)); // A=F, B=T, C=F
    assertTrue(method(false, false, true));  // A=F, B=F, C=T
}
```

### 🎯 短絡評価の対策

#### 💡 評価順序の制御
```java
// 短絡評価により後続条件が評価されない場合の対策
public boolean complexCondition(boolean a, boolean b, boolean c) {
    if (a && expensiveOperation(b) && anotherOperation(c)) {
        return true;
    }
    return false;
}

@Test  
public void testComplexCondition_ShortCircuitHandling() {
    // a=Falseの場合、b,cの条件が評価されない
    assertFalse(complexCondition(false, true, true));   // a=F テスト
    
    // a=True, b=Falseの場合、cの条件が評価されない
    assertFalse(complexCondition(true, false, true));   // a=T, b=F テスト
    
    // すべての条件を確実に評価させる
    assertTrue(complexCondition(true, true, true));     // a=T, b=T, c=T テスト
    assertFalse(complexCondition(true, true, false));   // a=T, b=T, c=F テスト
}
```

### 📈 カバレッジツールの活用

#### 💡 JaCoCo での条件網羅測定
```xml
<!-- Maven 設定例 -->
<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <configuration>
        <rules>
            <rule>
                <element>CLASS</element>
                <limits>
                    <limit>
                        <counter>BRANCH</counter>
                        <value>COVEREDRATIO</value>
                        <minimum>0.90</minimum>
                    </limit>
                    <!-- 条件網羅の詳細測定 -->
                    <limit>
                        <counter>COMPLEXITY</counter>
                        <value>COVEREDRATIO</value>
                        <minimum>0.85</minimum>
                    </limit>
                </limits>
            </rule>
        </rules>
    </configuration>
</plugin>
```

---

## 🎯 まとめ：条件網羅の要点

### ✅ 習得すべきポイント
1. **個別条件の特定**: 複合条件を構成する最小単位の条件の識別
2. **True/False両方のテスト**: 各個別条件で真偽両方の値をテスト
3. **短絡評価の考慮**: AND/OR演算子での評価停止を考慮したテスト設計
4. **効率的なテスト設計**: 最小限のテストケースで最大の条件網羅を達成

### 🔍 分岐網羅との違い
- **分岐網羅**: 複合条件全体のTrue/Falseをテスト
- **条件網羅**: 複合条件内の各個別条件のTrue/Falseをテスト
- **条件網羅 ⊃ 分岐網羅**: 条件網羅100%なら分岐網羅も100%

### 💡 実践のコツ
- 真理値表を使った条件の可視化
- 段階的なテストケース設計
- カバレッジツールでの実測定
- 短絡評価を考慮した評価順序の制御

---

## 🚀 次のステップ

理論と基本演習を完了したら、**「03_習得レベル確認.md」**で理解度をチェックしましょう！

条件網羅は分岐網羅より高度な技法ですが、基本概念をしっかり理解すれば、複雑なビジネスロジックの品質確保に大きく貢献できます。
