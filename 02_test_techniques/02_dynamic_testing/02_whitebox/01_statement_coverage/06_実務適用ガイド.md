# 🚀 命令網羅（Statement Coverage）- 実務適用ガイド

## 🎯 実務プロジェクトでの命令網羅適用

### 📊 プロジェクト規模別適用方針

#### 🔥 小規模プロジェクト（～10万行）
- **目標網羅率**: 90-95%
- **適用範囲**: 全モジュール
- **測定頻度**: CI/CD毎回
- **ツール**: 軽量なカバレッジツール（JaCoCo、Istanbul等）

#### 🏢 中規模プロジェクト（10-100万行）
- **目標網羅率**: 85-90%
- **適用範囲**: コアモジュール優先
- **測定頻度**: 日次ビルド
- **ツール**: 統合カバレッジプラットフォーム（SonarQube等）

#### 🏭 大規模プロジェクト（100万行～）
- **目標網羅率**: 80-85%
- **適用範囲**: ビジネスクリティカル部分
- **測定頻度**: 週次レポート
- **ツール**: エンタープライズ向けツール

---

## 🔗 他テスト技法との効果的な組み合わせ

### 🎯 ブラックボックス技法との連携

#### 💡 同値分割 + 命令網羅
```java
// 同値分割で設計したテストケースが命令網羅を満たすか検証
public class ScoreCalculator {
    public String getGrade(int score) {
        if (score >= 90) return "A";        // 同値: 90-100
        else if (score >= 80) return "B";   // 同値: 80-89
        else if (score >= 70) return "C";   // 同値: 70-79
        else if (score >= 60) return "D";   // 同値: 60-69
        else return "F";                    // 同値: 0-59
    }
}

// 同値分割テストケース
@Test
public void testGrade_EquivalencePartitioning() {
    assertEquals("A", calculator.getGrade(95));  // 90-100の代表値
    assertEquals("B", calculator.getGrade(85));  // 80-89の代表値
    assertEquals("C", calculator.getGrade(75));  // 70-79の代表値
    assertEquals("D", calculator.getGrade(65));  // 60-69の代表値
    assertEquals("F", calculator.getGrade(45));  // 0-59の代表値
}
// → 結果: 命令網羅100%達成
```

#### 💡 境界値分析 + 命令網羅
```java
// 境界値テストが命令網羅に与える影響を分析
@Test
public void testGrade_BoundaryValues() {
    // 境界値テスト
    assertEquals("A", calculator.getGrade(90));  // 境界値
    assertEquals("B", calculator.getGrade(89));  // 境界値
    assertEquals("B", calculator.getGrade(80));  // 境界値
    assertEquals("C", calculator.getGrade(79));  // 境界値
    // ...
}
// → 境界値だけでも命令網羅100%可能
```

### 🎯 ホワイトボックス技法との連携

#### 💡 命令網羅 → 分岐網羅への発展
```java
public class LoginValidator {
    public boolean validateLogin(String user, String pass) {
        if (user != null && pass != null) {           // 分岐1
            if (user.length() > 0 && pass.length() >= 8) {  // 分岐2
                return authenticateUser(user, pass);    // 分岐3
            }
        }
        return false;
    }
}

// 命令網羅のみ（不十分）
@Test
public void testValidateLogin_StatementCoverage() {
    assertTrue(validator.validateLogin("user", "password"));   // true パスのみ
}

// 分岐網羅（推奨）
@Test
public void testValidateLogin_BranchCoverage() {
    // 全分岐の true/false をテスト
    assertTrue(validator.validateLogin("user", "password"));    // 全true
    assertFalse(validator.validateLogin(null, "password"));     // 分岐1 false
    assertFalse(validator.validateLogin("user", "short"));      // 分岐2 false
}
```

---

## 🛠️ 実務でのツール活用戦略

### 📊 CI/CD パイプライン統合

#### 💡 Jenkins統合例
```groovy
pipeline {
    stages {
        stage('Test & Coverage') {
            steps {
                script {
                    // テスト実行
                    sh 'mvn clean test'
                    
                    // カバレッジレポート生成
                    sh 'mvn jacoco:report'
                    
                    // カバレッジチェック
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'target/site/jacoco',
                        reportFiles: 'index.html',
                        reportName: 'Coverage Report'
                    ])
                    
                    // 品質ゲート
                    if (currentBuild.result == null) {
                        def coverage = readFile('target/site/jacoco/index.html')
                        if (!coverage.contains('90%')) {
                            error('Coverage below 90%')
                        }
                    }
                }
            }
        }
    }
}
```

#### 💡 GitHub Actions統合例
```yaml
name: Test Coverage
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    
    - name: Setup Java
      uses: actions/setup-java@v2
      with:
        java-version: '11'
        
    - name: Run tests with coverage
      run: mvn clean test jacoco:report
      
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v1
      with:
        file: ./target/site/jacoco/jacoco.xml
        
    - name: Coverage check
      run: |
        COVERAGE=$(grep -Po 'line-rate="\\K[^"]*' target/site/jacoco/jacoco.xml | head -1)
        if (( $(echo "$COVERAGE < 0.90" | bc -l) )); then
          echo "Coverage $COVERAGE is below 90%"
          exit 1
        fi
```

### 📈 カバレッジレポートの活用

#### 💡 継続的改善プロセス
```markdown
## 週次カバレッジレビュー

### 1. 現状分析
- 現在の命令網羅率: 87%
- 前週比: +2%
- 未カバー行数: 234行

### 2. 未カバー箇所分析
- エラーハンドリング: 45%（高優先度）
- 初期化処理: 23%（中優先度）
- ログ出力: 32%（低優先度）

### 3. 改善アクション
- [ ] エラーハンドリングのテストケース追加
- [ ] 初期化異常系テスト作成
- [ ] 次週目標: 90%達成
```

---

## 🎯 実務での品質基準設定

### 📊 業界別品質基準

#### 🏥 医療・金融システム
- **命令網羅**: 95%以上
- **分岐網羅**: 90%以上
- **条件網羅**: 85%以上
- **根拠**: 人命・財産に関わる高信頼性要求

#### 🚗 自動車・航空システム
- **命令網羅**: 100%（MC/DC推奨）
- **分岐網羅**: 100%
- **根拠**: ISO 26262、DO-178C準拠

#### 🌐 Webアプリケーション
- **命令網羅**: 80-90%
- **分岐網羅**: 75-85%
- **根拠**: 開発速度と品質のバランス

#### 📱 モバイルアプリ
- **命令網羅**: 75-85%
- **分岐網羅**: 70-80%
- **根拠**: 頻繁なリリースサイクル

### 🎯 除外すべきコード

#### 💡 カバレッジ除外例
```java
// @ExcludeFromCodeCoverage  // アノテーションで除外
public class Logger {
    // ログ出力のみのメソッド（テスト困難）
    private void writeLog(String message) {
        System.out.println(new Date() + ": " + message);
    }
    
    // デバッグ専用メソッド
    public void debugDump() {
        // 実装詳細...
    }
    
    // 到達不可能なエラー処理
    public void process() {
        try {
            // メイン処理
        } catch (UnreachableException e) {
            // 実際には発生しない例外
            throw new RuntimeException("This should never happen", e);
        }
    }
}
```

---

## 🚨 実務での注意点とベストプラクティス

### ⚠️ よくある落とし穴

#### 💣 カバレッジ至上主義の回避
```java
// 悪い例：カバレッジのためだけのテスト
@Test
public void testForCoverageOnly() {
    new Calculator().divide(10, 0);  // 例外発生するだけ
    // アサーションなし → 意味のないテスト
}

// 良い例：意味のあるテスト
@Test
public void testDivideByZero_ThrowsException() {
    Calculator calc = new Calculator();
    
    ArithmeticException exception = assertThrows(
        ArithmeticException.class, 
        () -> calc.divide(10, 0)
    );
    
    assertEquals("Division by zero", exception.getMessage());
}
```

#### 💣 テスト可能性を考慮しない設計
```java
// 悪い例：テストしにくい設計
public class UserService {
    public void createUser(String name) {
        User user = new User(name);
        user.setCreatedAt(new Date());  // 現在時刻（テスト困難）
        database.save(user);           // 外部依存（テスト困難）
    }
}

// 良い例：テスト可能な設計
public class UserService {
    private final Clock clock;
    private final UserRepository repository;
    
    // 依存性注入でテスト可能に
    public UserService(Clock clock, UserRepository repository) {
        this.clock = clock;
        this.repository = repository;
    }
    
    public void createUser(String name) {
        User user = new User(name);
        user.setCreatedAt(clock.now());  // モック可能
        repository.save(user);           // モック可能
    }
}
```

### 🎯 効果的なカバレッジ向上戦略

#### 💡 段階的アプローチ
1. **Phase 1**: 主要フローの命令網羅（70%目標）
2. **Phase 2**: 異常系の命令網羅（85%目標）
3. **Phase 3**: エッジケースの命令網羅（90%目標）
4. **Phase 4**: 分岐網羅への移行

#### 💡 チーム内での合意形成
```markdown
## チーム内カバレッジ基準

### 最低基準
- 新規機能: 命令網羅 85%以上
- 既存機能修正: 命令網羅 80%以上
- バグ修正: 該当箇所 100%

### PR承認基準
- カバレッジ低下なし
- 新規追加行の 90%以上カバー
- カバレッジレポート添付必須

### 例外処理
- レガシーコード: 段階的改善
- 外部ライブラリ: 除外対象
- 設定・定数クラス: 除外対象
```

---

## 🎯 次のステップ：分岐網羅への発展

命令網羅をマスターしたら、次は**分岐網羅（Branch Coverage）**に進みましょう：

### 🔄 学習の連続性
1. **命令網羅の課題**: 条件の真偽両方をテストしない
2. **分岐網羅の価値**: より厳密な条件分岐テスト
3. **実務での使い分け**: プロジェクト特性に応じた適用

### 📚 推奨学習順序
1. 分岐網羅の理論学習
2. 命令網羅との差異理解
3. 分岐網羅の実践演習
4. 条件網羅・MC/DCへの発展

命令網羅は**ホワイトボックステストの基礎**です。実務で継続的に活用し、より高度な網羅基準への土台としてください。
