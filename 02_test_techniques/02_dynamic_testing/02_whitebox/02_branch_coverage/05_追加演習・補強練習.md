# ğŸ’ª åˆ†å²ç¶²ç¾…ï¼ˆBranch Coverageï¼‰- è¿½åŠ æ¼”ç¿’ãƒ»è£œå¼·ç·´ç¿’

## ğŸ¯ è£œå¼·ç·´ç¿’ã®ç›®çš„
- åˆ†å²ç¶²ç¾…ã®ç†è§£ã‚’å¤šæ§˜ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã§æ·±ã‚ã‚‹
- å®Ÿå‹™ã§ã‚ˆãé­é‡ã™ã‚‹è¤‡é›‘ãªã‚±ãƒ¼ã‚¹ã®ç¿’å¾—
- åŠ¹ç‡çš„ãªãƒ†ã‚¹ãƒˆè¨­è¨ˆæ‰‹æ³•ã®å®šç€

---

## ğŸ’ª è£œå¼·æ¼”ç¿’ 1ï¼šå†å¸°å‡¦ç†ã¨åˆ†å²ç¶²ç¾…

### ğŸ“ å•é¡Œ
ä»¥ä¸‹ã®å†å¸°çš„ãªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ¤œç´¢ãƒ¡ã‚½ãƒƒãƒ‰ã§åˆ†å²ç¶²ç¾…ã‚’é”æˆã—ã¦ãã ã•ã„ã€‚

```java
public class DirectorySearcher {
    private List<String> foundFiles = new ArrayList<>();
    private int maxDepth;
    
    public List<String> searchFiles(String directoryPath, String extension, 
                                   int maxSearchDepth, boolean includeHidden) {
        this.maxDepth = maxSearchDepth;
        this.foundFiles.clear();
        
        if (directoryPath == null || extension == null) {
            return foundFiles;
        }
        
        File directory = new File(directoryPath);
        if (!directory.exists() || !directory.isDirectory()) {
            return foundFiles;
        }
        
        searchRecursively(directory, extension, 0, includeHidden);
        return foundFiles;
    }
    
    private void searchRecursively(File directory, String extension, 
                                  int currentDepth, boolean includeHidden) {
        // æ·±åº¦åˆ¶é™ãƒã‚§ãƒƒã‚¯
        if (currentDepth >= maxDepth) {
            return;
        }
        
        File[] files = directory.listFiles();
        if (files == null) {
            return; // ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãªã—ç­‰
        }
        
        for (File file : files) {
            // éš ã—ãƒ•ã‚¡ã‚¤ãƒ«ãƒ»ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å‡¦ç†
            if (file.isHidden() && !includeHidden) {
                continue;
            }
            
            if (file.isFile()) {
                // ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆ
                String fileName = file.getName().toLowerCase();
                if (extension.isEmpty() || fileName.endsWith(extension.toLowerCase())) {
                    foundFiles.add(file.getAbsolutePath());
                }
            } else if (file.isDirectory()) {
                // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®å ´åˆã€å†å¸°æ¤œç´¢
                searchRecursively(file, extension, currentDepth + 1, includeHidden);
            }
        }
    }
}
```

### âœ… è§£ç­”ï¼šå†å¸°å‡¦ç†ã®åˆ†å²ç¶²ç¾…ãƒ†ã‚¹ãƒˆ

```java
@Test
public void testSearchFiles_BranchCoverage() throws IOException {
    DirectorySearcher searcher = new DirectorySearcher();
    
    // ãƒ†ã‚¹ãƒˆç”¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ä½œæˆ
    File testRoot = createTestDirectoryStructure();
    String testPath = testRoot.getAbsolutePath();
    
    // TC1: nullå…¥åŠ›
    List<String> result1 = searcher.searchFiles(null, ".txt", 5, false);
    assertEquals(0, result1.size());
    
    // TC2: å­˜åœ¨ã—ãªã„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
    List<String> result2 = searcher.searchFiles("/nonexistent", ".txt", 5, false);
    assertEquals(0, result2.size());
    
    // TC3: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æŒ‡å®šï¼ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ã¯ãªã„ï¼‰
    File testFile = new File(testPath, "test.txt");
    List<String> result3 = searcher.searchFiles(testFile.getAbsolutePath(), ".txt", 5, false);
    assertEquals(0, result3.size());
    
    // TC4: æ·±åº¦åˆ¶é™ãƒ†ã‚¹ãƒˆï¼ˆmaxDepth = 1ï¼‰
    List<String> result4 = searcher.searchFiles(testPath, ".txt", 1, false);
    assertTrue("Should find files in root level", result4.size() > 0);
    assertTrue("Should not find files in deep subdirectories", 
               result4.stream().noneMatch(path -> path.contains("level2")));
    
    // TC5: éš ã—ãƒ•ã‚¡ã‚¤ãƒ«é™¤å¤–
    List<String> result5 = searcher.searchFiles(testPath, ".txt", 5, false);
    assertTrue("Should not find hidden files", 
               result5.stream().noneMatch(path -> path.contains(".hidden")));
    
    // TC6: éš ã—ãƒ•ã‚¡ã‚¤ãƒ«å«ã‚€
    List<String> result6 = searcher.searchFiles(testPath, ".txt", 5, true);
    assertTrue("Should find hidden files", 
               result6.stream().anyMatch(path -> path.contains(".hidden")));
    
    // TC7: æ‹¡å¼µå­ãªã—ï¼ˆã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰
    List<String> result7 = searcher.searchFiles(testPath, "", 5, false);
    assertTrue("Should find all file types", result7.size() > result5.size());
    
    // TC8: ç‰¹å®šæ‹¡å¼µå­ã®ã¿
    List<String> result8 = searcher.searchFiles(testPath, ".java", 5, false);
    assertTrue("Should find only Java files", 
               result8.stream().allMatch(path -> path.toLowerCase().endsWith(".java")));
    
    // TC9: ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãªã—ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªï¼ˆfiles == null ã®ã‚±ãƒ¼ã‚¹ï¼‰
    File restrictedDir = new File(testPath, "restricted");
    restrictedDir.mkdir();
    restrictedDir.setReadable(false);
    
    List<String> result9 = searcher.searchFiles(testPath, ".txt", 5, false);
    // ã‚¨ãƒ©ãƒ¼ã«ãªã‚‰ãšã«å‡¦ç†ãŒç¶™ç¶šã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª
    assertNotNull(result9);
    
    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    restrictedDir.setReadable(true);
    cleanupTestDirectory(testRoot);
}

// ãƒ†ã‚¹ãƒˆç”¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ä½œæˆ
private File createTestDirectoryStructure() throws IOException {
    File testRoot = Files.createTempDirectory("test_search").toFile();
    
    // ãƒ«ãƒ¼ãƒˆãƒ¬ãƒ™ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«
    new File(testRoot, "root.txt").createNewFile();
    new File(testRoot, "root.java").createNewFile();
    new File(testRoot, ".hidden.txt").createNewFile();
    
    // ãƒ¬ãƒ™ãƒ«1ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
    File level1 = new File(testRoot, "level1");
    level1.mkdir();
    new File(level1, "level1.txt").createNewFile();
    new File(level1, "level1.java").createNewFile();
    
    // ãƒ¬ãƒ™ãƒ«2ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªï¼ˆæ·±åº¦ãƒ†ã‚¹ãƒˆç”¨ï¼‰
    File level2 = new File(level1, "level2");
    level2.mkdir();
    new File(level2, "level2.txt").createNewFile();
    
    // éš ã—ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
    File hiddenDir = new File(testRoot, ".hiddenDir");
    hiddenDir.mkdir();
    new File(hiddenDir, "hidden.txt").createNewFile();
    
    return testRoot;
}
```

---

## ğŸ’ª è£œå¼·æ¼”ç¿’ 2ï¼šçŠ¶æ…‹æ©Ÿæ¢°ãƒ‘ã‚¿ãƒ¼ãƒ³ã®åˆ†å²ç¶²ç¾…

### ğŸ“ å•é¡Œ
ä»¥ä¸‹ã®æ³¨æ–‡çŠ¶æ…‹ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã§åˆ†å²ç¶²ç¾…ã‚’é”æˆã—ã¦ãã ã•ã„ã€‚

```java
public class OrderStateMachine {
    public enum OrderState {
        CREATED, PAID, SHIPPED, DELIVERED, CANCELLED, RETURNED
    }
    
    public class StateTransitionResult {
        private boolean success;
        private String message;
        private OrderState newState;
        
        // constructors, getters, setters...
    }
    
    public StateTransitionResult processEvent(OrderState currentState, String event, 
                                            Map<String, Object> context) {
        if (currentState == null || event == null) {
            return new StateTransitionResult(false, "Invalid input", currentState);
        }
        
        event = event.toUpperCase().trim();
        
        switch (currentState) {
            case CREATED:
                return handleCreatedState(event, context);
            case PAID:
                return handlePaidState(event, context);
            case SHIPPED:
                return handleShippedState(event, context);
            case DELIVERED:
                return handleDeliveredState(event, context);
            case CANCELLED:
                return handleCancelledState(event, context);
            case RETURNED:
                return handleReturnedState(event, context);
            default:
                return new StateTransitionResult(false, "Unknown state", currentState);
        }
    }
    
    private StateTransitionResult handleCreatedState(String event, Map<String, Object> context) {
        switch (event) {
            case "PAY":
                if (context != null && Boolean.TRUE.equals(context.get("paymentValid"))) {
                    return new StateTransitionResult(true, "Payment processed", OrderState.PAID);
                } else {
                    return new StateTransitionResult(false, "Payment failed", OrderState.CREATED);
                }
            case "CANCEL":
                return new StateTransitionResult(true, "Order cancelled", OrderState.CANCELLED);
            default:
                return new StateTransitionResult(false, "Invalid event for CREATED state", OrderState.CREATED);
        }
    }
    
    private StateTransitionResult handlePaidState(String event, Map<String, Object> context) {
        switch (event) {
            case "SHIP":
                if (context != null && context.get("inventory") != null) {
                    Integer inventory = (Integer) context.get("inventory");
                    if (inventory > 0) {
                        return new StateTransitionResult(true, "Order shipped", OrderState.SHIPPED);
                    } else {
                        return new StateTransitionResult(false, "Out of stock", OrderState.PAID);
                    }
                } else {
                    return new StateTransitionResult(false, "Inventory not available", OrderState.PAID);
                }
            case "CANCEL":
                Boolean refundProcessed = context != null ? 
                    (Boolean) context.get("refundProcessed") : false;
                if (Boolean.TRUE.equals(refundProcessed)) {
                    return new StateTransitionResult(true, "Order cancelled with refund", OrderState.CANCELLED);
                } else {
                    return new StateTransitionResult(false, "Refund processing failed", OrderState.PAID);
                }
            default:
                return new StateTransitionResult(false, "Invalid event for PAID state", OrderState.PAID);
        }
    }
    
    private StateTransitionResult handleShippedState(String event, Map<String, Object> context) {
        switch (event) {
            case "DELIVER":
                return new StateTransitionResult(true, "Order delivered", OrderState.DELIVERED);
            case "RETURN":
                return new StateTransitionResult(true, "Order returned during shipping", OrderState.RETURNED);
            default:
                return new StateTransitionResult(false, "Invalid event for SHIPPED state", OrderState.SHIPPED);
        }
    }
    
    private StateTransitionResult handleDeliveredState(String event, Map<String, Object> context) {
        if ("RETURN".equals(event)) {
            if (context != null && context.get("returnReason") != null) {
                return new StateTransitionResult(true, "Return initiated", OrderState.RETURNED);
            } else {
                return new StateTransitionResult(false, "Return reason required", OrderState.DELIVERED);
            }
        }
        return new StateTransitionResult(false, "Invalid event for DELIVERED state", OrderState.DELIVERED);
    }
    
    private StateTransitionResult handleCancelledState(String event, Map<String, Object> context) {
        // ã‚­ãƒ£ãƒ³ã‚»ãƒ«çŠ¶æ…‹ã‹ã‚‰ã¯é·ç§»ãªã—
        return new StateTransitionResult(false, "No transitions allowed from CANCELLED state", OrderState.CANCELLED);
    }
    
    private StateTransitionResult handleReturnedState(String event, Map<String, Object> context) {
        // è¿”å“çŠ¶æ…‹ã‹ã‚‰ã¯é·ç§»ãªã—
        return new StateTransitionResult(false, "No transitions allowed from RETURNED state", OrderState.RETURNED);
    }
}
```

### âœ… è§£ç­”ï¼šçŠ¶æ…‹æ©Ÿæ¢°ã®å®Œå…¨åˆ†å²ç¶²ç¾…ãƒ†ã‚¹ãƒˆ

```java
@Test
public void testOrderStateMachine_CompleteBranchCoverage() {
    OrderStateMachine stateMachine = new OrderStateMachine();
    
    // === å…¥åŠ›æ¤œè¨¼ãƒ†ã‚¹ãƒˆ ===
    
    // TC1: null state
    StateTransitionResult result1 = stateMachine.processEvent(null, "PAY", null);
    assertFalse(result1.isSuccess());
    assertEquals("Invalid input", result1.getMessage());
    
    // TC2: null event
    StateTransitionResult result2 = stateMachine.processEvent(OrderState.CREATED, null, null);
    assertFalse(result2.isSuccess());
    assertEquals("Invalid input", result2.getMessage());
    
    // === CREATEDçŠ¶æ…‹ã®ãƒ†ã‚¹ãƒˆ ===
    
    // TC3: CREATED -> PAY (æˆåŠŸ)
    Map<String, Object> validPayment = Map.of("paymentValid", true);
    StateTransitionResult result3 = stateMachine.processEvent(OrderState.CREATED, "pay", validPayment);
    assertTrue(result3.isSuccess());
    assertEquals(OrderState.PAID, result3.getNewState());
    assertEquals("Payment processed", result3.getMessage());
    
    // TC4: CREATED -> PAY (å¤±æ•—)
    Map<String, Object> invalidPayment = Map.of("paymentValid", false);
    StateTransitionResult result4 = stateMachine.processEvent(OrderState.CREATED, "PAY", invalidPayment);
    assertFalse(result4.isSuccess());
    assertEquals(OrderState.CREATED, result4.getNewState());
    assertEquals("Payment failed", result4.getMessage());
    
    // TC5: CREATED -> PAY (context null)
    StateTransitionResult result5 = stateMachine.processEvent(OrderState.CREATED, "PAY", null);
    assertFalse(result5.isSuccess());
    assertEquals(OrderState.CREATED, result5.getNewState());
    
    // TC6: CREATED -> CANCEL
    StateTransitionResult result6 = stateMachine.processEvent(OrderState.CREATED, "CANCEL", null);
    assertTrue(result6.isSuccess());
    assertEquals(OrderState.CANCELLED, result6.getNewState());
    
    // TC7: CREATED -> ç„¡åŠ¹ã‚¤ãƒ™ãƒ³ãƒˆ
    StateTransitionResult result7 = stateMachine.processEvent(OrderState.CREATED, "SHIP", null);
    assertFalse(result7.isSuccess());
    assertEquals(OrderState.CREATED, result7.getNewState());
    assertTrue(result7.getMessage().contains("Invalid event"));
    
    // === PAIDçŠ¶æ…‹ã®ãƒ†ã‚¹ãƒˆ ===
    
    // TC8: PAID -> SHIP (æˆåŠŸ)
    Map<String, Object> availableInventory = Map.of("inventory", 10);
    StateTransitionResult result8 = stateMachine.processEvent(OrderState.PAID, "SHIP", availableInventory);
    assertTrue(result8.isSuccess());
    assertEquals(OrderState.SHIPPED, result8.getNewState());
    
    // TC9: PAID -> SHIP (åœ¨åº«ãªã—)
    Map<String, Object> noInventory = Map.of("inventory", 0);
    StateTransitionResult result9 = stateMachine.processEvent(OrderState.PAID, "SHIP", noInventory);
    assertFalse(result9.isSuccess());
    assertEquals(OrderState.PAID, result9.getNewState());
    assertEquals("Out of stock", result9.getMessage());
    
    // TC10: PAID -> SHIP (åœ¨åº«æƒ…å ±ãªã—)
    StateTransitionResult result10 = stateMachine.processEvent(OrderState.PAID, "SHIP", null);
    assertFalse(result10.isSuccess());
    assertEquals("Inventory not available", result10.getMessage());
    
    // TC11: PAID -> CANCEL (è¿”é‡‘æˆåŠŸ)
    Map<String, Object> refundSuccess = Map.of("refundProcessed", true);
    StateTransitionResult result11 = stateMachine.processEvent(OrderState.PAID, "CANCEL", refundSuccess);
    assertTrue(result11.isSuccess());
    assertEquals(OrderState.CANCELLED, result11.getNewState());
    
    // TC12: PAID -> CANCEL (è¿”é‡‘å¤±æ•—)
    Map<String, Object> refundFailed = Map.of("refundProcessed", false);
    StateTransitionResult result12 = stateMachine.processEvent(OrderState.PAID, "CANCEL", refundFailed);
    assertFalse(result12.isSuccess());
    assertEquals(OrderState.PAID, result12.getNewState());
    
    // TC13: PAID -> CANCEL (context null)
    StateTransitionResult result13 = stateMachine.processEvent(OrderState.PAID, "CANCEL", null);
    assertFalse(result13.isSuccess());
    assertEquals("Refund processing failed", result13.getMessage());
    
    // === SHIPPEDçŠ¶æ…‹ã®ãƒ†ã‚¹ãƒˆ ===
    
    // TC14: SHIPPED -> DELIVER
    StateTransitionResult result14 = stateMachine.processEvent(OrderState.SHIPPED, "DELIVER", null);
    assertTrue(result14.isSuccess());
    assertEquals(OrderState.DELIVERED, result14.getNewState());
    
    // TC15: SHIPPED -> RETURN
    StateTransitionResult result15 = stateMachine.processEvent(OrderState.SHIPPED, "RETURN", null);
    assertTrue(result15.isSuccess());
    assertEquals(OrderState.RETURNED, result15.getNewState());
    
    // TC16: SHIPPED -> ç„¡åŠ¹ã‚¤ãƒ™ãƒ³ãƒˆ
    StateTransitionResult result16 = stateMachine.processEvent(OrderState.SHIPPED, "PAY", null);
    assertFalse(result16.isSuccess());
    assertEquals(OrderState.SHIPPED, result16.getNewState());
    
    // === DELIVEREDçŠ¶æ…‹ã®ãƒ†ã‚¹ãƒˆ ===
    
    // TC17: DELIVERED -> RETURN (ç†ç”±ã‚ã‚Š)
    Map<String, Object> returnReason = Map.of("returnReason", "Defective product");
    StateTransitionResult result17 = stateMachine.processEvent(OrderState.DELIVERED, "RETURN", returnReason);
    assertTrue(result17.isSuccess());
    assertEquals(OrderState.RETURNED, result17.getNewState());
    
    // TC18: DELIVERED -> RETURN (ç†ç”±ãªã—)
    StateTransitionResult result18 = stateMachine.processEvent(OrderState.DELIVERED, "RETURN", null);
    assertFalse(result18.isSuccess());
    assertEquals(OrderState.DELIVERED, result18.getNewState());
    assertEquals("Return reason required", result18.getMessage());
    
    // TC19: DELIVERED -> ç„¡åŠ¹ã‚¤ãƒ™ãƒ³ãƒˆ
    StateTransitionResult result19 = stateMachine.processEvent(OrderState.DELIVERED, "SHIP", null);
    assertFalse(result19.isSuccess());
    assertEquals(OrderState.DELIVERED, result19.getNewState());
    
    // === çµ‚äº†çŠ¶æ…‹ã®ãƒ†ã‚¹ãƒˆ ===
    
    // TC20: CANCELLEDçŠ¶æ…‹ï¼ˆé·ç§»ãªã—ï¼‰
    StateTransitionResult result20 = stateMachine.processEvent(OrderState.CANCELLED, "ANY_EVENT", null);
    assertFalse(result20.isSuccess());
    assertEquals(OrderState.CANCELLED, result20.getNewState());
    assertTrue(result20.getMessage().contains("No transitions allowed"));
    
    // TC21: RETURNEDçŠ¶æ…‹ï¼ˆé·ç§»ãªã—ï¼‰
    StateTransitionResult result21 = stateMachine.processEvent(OrderState.RETURNED, "ANY_EVENT", null);
    assertFalse(result21.isSuccess());
    assertEquals(OrderState.RETURNED, result21.getNewState());
    assertTrue(result21.getMessage().contains("No transitions allowed"));
    
    // === ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ ===
    
    // TC22: ã‚¤ãƒ™ãƒ³ãƒˆåã®å¤§æ–‡å­—å°æ–‡å­—ãƒ»ç©ºç™½å‡¦ç†
    StateTransitionResult result22 = stateMachine.processEvent(OrderState.CREATED, " pay ", validPayment);
    assertTrue(result22.isSuccess());
    assertEquals(OrderState.PAID, result22.getNewState());
    
    // TC23: å­˜åœ¨ã—ãªã„çŠ¶æ…‹ï¼ˆdefault caseï¼‰
    // æ³¨ï¼šã“ã‚Œã¯å®Ÿéš›ã®enumã§ã¯ç™ºç”Ÿã—ãªã„ãŒã€å°†æ¥ã®æ‹¡å¼µæ€§ã®ãŸã‚ã®ãƒ†ã‚¹ãƒˆ
    // å®Ÿéš›ã®ãƒ†ã‚¹ãƒˆã§ã¯ã€ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚„ãƒ¢ãƒƒã‚¯ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚‚å¯èƒ½
}
```

---

## ğŸ’ª è£œå¼·æ¼”ç¿’ 3ï¼šä¸¦è¡Œå‡¦ç†ã¨åˆ†å²ç¶²ç¾…

### ğŸ“ å•é¡Œ
ä»¥ä¸‹ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ãªã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ã§åˆ†å²ç¶²ç¾…ã‚’é”æˆã—ã¦ãã ã•ã„ã€‚

```java
public class ThreadSafeCounter {
    private volatile int count = 0;
    private volatile boolean isActive = true;
    private final int maxCount;
    private final Object lock = new Object();
    private final List<CounterListener> listeners = new ArrayList<>();
    
    public ThreadSafeCounter(int maxCount) {
        this.maxCount = maxCount;
    }
    
    public boolean increment() {
        if (!isActive) {
            return false;
        }
        
        synchronized (lock) {
            if (!isActive) { // ãƒ€ãƒ–ãƒ«ãƒã‚§ãƒƒã‚¯
                return false;
            }
            
            if (count >= maxCount) {
                notifyListeners("MAX_REACHED", count);
                return false;
            }
            
            count++;
            
            if (count == maxCount) {
                isActive = false;
                notifyListeners("LIMIT_REACHED", count);
            } else if (count % 10 == 0) {
                notifyListeners("MILESTONE", count);
            }
            
            return true;
        }
    }
    
    public boolean decrement() {
        if (!isActive) {
            return false;
        }
        
        synchronized (lock) {
            if (count <= 0) {
                notifyListeners("MIN_REACHED", count);
                return false;
            }
            
            count--;
            notifyListeners("DECREMENTED", count);
            return true;
        }
    }
    
    public void reset() {
        synchronized (lock) {
            count = 0;
            isActive = true;
            notifyListeners("RESET", count);
        }
    }
    
    private void notifyListeners(String event, int value) {
        if (listeners.isEmpty()) {
            return;
        }
        
        for (CounterListener listener : listeners) {
            try {
                listener.onCounterEvent(event, value);
            } catch (Exception e) {
                // ãƒªã‚¹ãƒŠãƒ¼ã§ã®ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ï¼ˆãƒ­ã‚°å‡ºåŠ›ç­‰ã¯çœç•¥ï¼‰
            }
        }
    }
    
    public void addListener(CounterListener listener) {
        if (listener != null) {
            synchronized (lock) {
                listeners.add(listener);
            }
        }
    }
    
    public int getCount() {
        return count;
    }
    
    public boolean isActive() {
        return isActive;
    }
    
    interface CounterListener {
        void onCounterEvent(String event, int value);
    }
}
```

### âœ… è§£ç­”ï¼šä¸¦è¡Œå‡¦ç†ã®åˆ†å²ç¶²ç¾…ãƒ†ã‚¹ãƒˆ

```java
@Test
public void testThreadSafeCounter_BranchCoverage() throws InterruptedException {
    // === åŸºæœ¬æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ ===
    
    // TC1: é€šå¸¸ã®ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
    ThreadSafeCounter counter = new ThreadSafeCounter(5);
    assertTrue(counter.increment());
    assertEquals(1, counter.getCount());
    
    // TC2: æœ€å¤§å€¤åˆ°é”
    for (int i = 0; i < 4; i++) {
        assertTrue(counter.increment());
    }
    assertEquals(5, counter.getCount());
    assertFalse(counter.isActive());
    
    // TC3: éã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚ã®ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆï¼ˆå¤–å´ãƒã‚§ãƒƒã‚¯ï¼‰
    assertFalse(counter.increment());
    assertEquals(5, counter.getCount());
    
    // TC4: ãƒªã‚»ãƒƒãƒˆå¾Œã®ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
    counter.reset();
    assertTrue(counter.isActive());
    assertEquals(0, counter.getCount());
    assertTrue(counter.increment());
    
    // === ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆãƒ†ã‚¹ãƒˆ ===
    
    // TC5: é€šå¸¸ã®ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
    ThreadSafeCounter counter2 = new ThreadSafeCounter(10);
    counter2.increment();
    counter2.increment();
    assertTrue(counter2.decrement());
    assertEquals(1, counter2.getCount());
    
    // TC6: æœ€å°å€¤ã§ã®ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
    counter2.decrement();
    assertEquals(0, counter2.getCount());
    assertFalse(counter2.decrement()); // count <= 0
    
    // TC7: éã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚ã®ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
    ThreadSafeCounter counter3 = new ThreadSafeCounter(1);
    counter3.increment(); // æœ€å¤§å€¤åˆ°é”ã§isActive = false
    assertFalse(counter3.decrement());
    
    // === ãƒªã‚¹ãƒŠãƒ¼ãƒ†ã‚¹ãƒˆ ===
    
    // TC8: ãƒªã‚¹ãƒŠãƒ¼ãªã—ï¼ˆnotifyListenerså†…ã®early returnï¼‰
    ThreadSafeCounter counter4 = new ThreadSafeCounter(10);
    counter4.increment(); // ãƒªã‚¹ãƒŠãƒ¼ãŒãªã„ã®ã§ä½•ã‚‚é€šçŸ¥ã•ã‚Œãªã„
    
    // TC9: æ­£å¸¸ãªãƒªã‚¹ãƒŠãƒ¼
    ThreadSafeCounter counter5 = new ThreadSafeCounter(20);
    MockCounterListener listener = new MockCounterListener();
    counter5.addListener(listener);
    
    counter5.increment();
    assertTrue(listener.getEvents().contains("MILESTONE")); // count % 10 == 0ã§ãªã„ã®ã§å‘¼ã°ã‚Œãªã„... å¾…ã£ã¦
    
    // TC10: ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆ10ã®å€æ•°ï¼‰
    for (int i = 0; i < 9; i++) {
        counter5.increment(); // count = 10ã«ãªã‚‹
    }
    assertTrue(listener.getEvents().contains("MILESTONE"));
    
    // TC11: æœ€å¤§å€¤åˆ°é”ã‚¤ãƒ™ãƒ³ãƒˆ
    ThreadSafeCounter counter6 = new ThreadSafeCounter(2);
    MockCounterListener listener2 = new MockCounterListener();
    counter6.addListener(listener2);
    
    counter6.increment(); // count = 1
    counter6.increment(); // count = 2, LIMIT_REACHED
    assertTrue(listener2.getEvents().contains("LIMIT_REACHED"));
    
    // TC12: æœ€å¤§å€¤è¶…éã‚¤ãƒ™ãƒ³ãƒˆ
    assertFalse(counter6.increment()); // MAX_REACHED
    assertTrue(listener2.getEvents().contains("MAX_REACHED"));
    
    // TC13: ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã‚¤ãƒ™ãƒ³ãƒˆ
    ThreadSafeCounter counter7 = new ThreadSafeCounter(10);
    MockCounterListener listener3 = new MockCounterListener();
    counter7.addListener(listener3);
    
    counter7.increment();
    counter7.decrement();
    assertTrue(listener3.getEvents().contains("DECREMENTED"));
    
    // TC14: æœ€å°å€¤åˆ°é”ã‚¤ãƒ™ãƒ³ãƒˆ
    counter7.decrement(); // count = 0
    assertFalse(counter7.decrement()); // MIN_REACHED
    assertTrue(listener3.getEvents().contains("MIN_REACHED"));
    
    // TC15: ãƒªã‚»ãƒƒãƒˆã‚¤ãƒ™ãƒ³ãƒˆ
    counter7.reset();
    assertTrue(listener3.getEvents().contains("RESET"));
    
    // TC16: nullãƒªã‚¹ãƒŠãƒ¼è¿½åŠ 
    counter7.addListener(null); // ä½•ã‚‚èµ·ã“ã‚‰ãªã„
    
    // TC17: ãƒªã‚¹ãƒŠãƒ¼ã§ã®ä¾‹å¤–
    ThreadSafeCounter counter8 = new ThreadSafeCounter(10);
    CounterListener faultyListener = (event, value) -> {
        throw new RuntimeException("Listener error");
    };
    counter8.addListener(faultyListener);
    
    // ä¾‹å¤–ãŒç™ºç”Ÿã—ã¦ã‚‚ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã¯æ­£å¸¸ã«å‹•ä½œ
    assertTrue(counter8.increment());
    assertEquals(1, counter8.getCount());
    
    // === ä¸¦è¡Œå‡¦ç†ãƒ†ã‚¹ãƒˆ ===
    
    // TC18: è¤‡æ•°ã‚¹ãƒ¬ãƒƒãƒ‰ã§ã®ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
    ThreadSafeCounter concurrentCounter = new ThreadSafeCounter(1000);
    int numThreads = 10;
    int incrementsPerThread = 50;
    CountDownLatch latch = new CountDownLatch(numThreads);
    
    for (int i = 0; i < numThreads; i++) {
        new Thread(() -> {
            for (int j = 0; j < incrementsPerThread; j++) {
                concurrentCounter.increment();
            }
            latch.countDown();
        }).start();
    }
    
    latch.await(5, TimeUnit.SECONDS);
    assertEquals(500, concurrentCounter.getCount()); // 10 * 50 = 500
    
    // TC19: ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã¨ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã®ä¸¦è¡Œå®Ÿè¡Œ
    ThreadSafeCounter mixedCounter = new ThreadSafeCounter(100);
    CountDownLatch mixedLatch = new CountDownLatch(2);
    AtomicInteger incrementCount = new AtomicInteger(0);
    AtomicInteger decrementCount = new AtomicInteger(0);
    
    // ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰
    new Thread(() -> {
        for (int i = 0; i < 50; i++) {
            if (mixedCounter.increment()) {
                incrementCount.incrementAndGet();
            }
        }
        mixedLatch.countDown();
    }).start();
    
    // ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ï¼ˆå°‘ã—é…å»¶ã‚’å…¥ã‚Œã¦é–‹å§‹ï¼‰
    new Thread(() -> {
        try {
            Thread.sleep(10); // ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆãŒå…ˆã«å®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã«
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        for (int i = 0; i < 30; i++) {
            if (mixedCounter.decrement()) {
                decrementCount.incrementAndGet();
            }
        }
        mixedLatch.countDown();
    }).start();
    
    mixedLatch.await(5, TimeUnit.SECONDS);
    
    // æœ€çµ‚çš„ãªã‚«ã‚¦ãƒ³ãƒˆã¯æ­£ã®å€¤ã«ãªã‚‹ã¯ãšï¼ˆã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ > ãƒ‡ã‚¯ãƒªãƒ¡ãƒ³ãƒˆï¼‰
    assertTrue(mixedCounter.getCount() >= 0);
    assertTrue(incrementCount.get() > 0);
    assertTrue(decrementCount.get() > 0);
    
    // TC20: éã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚ã®ä¸¦è¡Œã‚¢ã‚¯ã‚»ã‚¹ï¼ˆãƒ€ãƒ–ãƒ«ãƒã‚§ãƒƒã‚¯ãƒ†ã‚¹ãƒˆï¼‰
    ThreadSafeCounter doubleCheckCounter = new ThreadSafeCounter(1);
    CountDownLatch doubleCheckLatch = new CountDownLatch(3);
    AtomicInteger successCount = new AtomicInteger(0);
    
    for (int i = 0; i < 3; i++) {
        new Thread(() -> {
            if (doubleCheckCounter.increment()) {
                successCount.incrementAndGet();
            }
            doubleCheckLatch.countDown();
        }).start();
    }
    
    doubleCheckLatch.await(5, TimeUnit.SECONDS);
    
    // æœ€å¤§å€¤ãŒ1ãªã®ã§ã€æˆåŠŸã™ã‚‹ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã¯1å›ã®ã¿
    assertEquals(1, successCount.get());
    assertEquals(1, doubleCheckCounter.getCount());
    assertFalse(doubleCheckCounter.isActive());
}

// ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ¢ãƒƒã‚¯ãƒªã‚¹ãƒŠãƒ¼
class MockCounterListener implements ThreadSafeCounter.CounterListener {
    private final List<String> events = new ArrayList<>();
    
    @Override
    public void onCounterEvent(String event, int value) {
        synchronized (events) {
            events.add(event);
        }
    }
    
    public List<String> getEvents() {
        synchronized (events) {
            return new ArrayList<>(events);
        }
    }
}
```

---

## ğŸ” è£œå¼·æ¼”ç¿’ã§ã®é‡è¦å­¦ç¿’ãƒã‚¤ãƒ³ãƒˆ

### ğŸ’¡ 1. è¤‡é›‘ãªåˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ã®åˆ†å²ç¶²ç¾…
- **å†å¸°å‡¦ç†**: æ·±åº¦åˆ¶é™ã€çµ‚äº†æ¡ä»¶ã®åˆ†å²
- **çŠ¶æ…‹æ©Ÿæ¢°**: çŠ¶æ…‹Ã—ã‚¤ãƒ™ãƒ³ãƒˆã®çµ„ã¿åˆã‚ã›åˆ†å²
- **ä¸¦è¡Œå‡¦ç†**: åŒæœŸåŒ–ãƒ–ãƒ­ãƒƒã‚¯å†…å¤–ã®åˆ†å²

### ğŸ’¡ 2. å®Ÿå‹™çš„ãªãƒ†ã‚¹ãƒˆè¨­è¨ˆ
- **å¢ƒç•Œå€¤ã¨ã®çµ„ã¿åˆã‚ã›**: åˆ†å²æ¡ä»¶ã®å¢ƒç•Œå€¤ãƒ†ã‚¹ãƒˆ
- **ç•°å¸¸ç³»ã®ç¶²ç¾…**: ä¾‹å¤–å‡¦ç†ã€ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ã®åˆ†å²
- **ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†**: ãƒ•ã‚¡ã‚¤ãƒ«ã€ã‚¹ãƒ¬ãƒƒãƒ‰ç­‰ã®ãƒªã‚½ãƒ¼ã‚¹é–¢é€£åˆ†å²

### ğŸ’¡ 3. ãƒ†ã‚¹ãƒˆåŠ¹ç‡ã®æœ€é©åŒ–
- **ä¸¦è¡Œãƒ†ã‚¹ãƒˆ**: è¤‡æ•°ã‚¹ãƒ¬ãƒƒãƒ‰ã§ã®åˆ†å²å®Ÿè¡Œç¢ºèª
- **ãƒ¢ãƒƒã‚¯ãƒ»ã‚¹ã‚¿ãƒ–**: å¤–éƒ¨ä¾å­˜ã®åˆ†å²ã‚’åˆ¶å¾¡ã—ãŸãƒ†ã‚¹ãƒˆ
- **ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–**: é¡ä¼¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã®åŠ¹ç‡çš„ãƒ†ã‚¹ãƒˆ

---

## ğŸ¯ è£œå¼·ç·´ç¿’å®Œäº†å¾Œã®ç¢ºèªãƒã‚¤ãƒ³ãƒˆ

### âœ… ç¿’å¾—ç¢ºèªé …ç›®
- [ ] å†å¸°å‡¦ç†ã§ã®åˆ†å²ç‰¹å®šãŒã§ãã‚‹
- [ ] çŠ¶æ…‹æ©Ÿæ¢°ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å…¨åˆ†å²ã‚’ç¶²ç¾…ã§ãã‚‹
- [ ] ä¸¦è¡Œå‡¦ç†ã®åŒæœŸãƒã‚¤ãƒ³ãƒˆã§ã®åˆ†å²ã‚’ç†è§£ã—ã¦ã„ã‚‹
- [ ] è¤‡é›‘ãªæ¡ä»¶åˆ†å²ã‚’åŠ¹ç‡çš„ã«ãƒ†ã‚¹ãƒˆã§ãã‚‹
- [ ] å®Ÿå‹™ãƒ¬ãƒ™ãƒ«ã®ç•°å¸¸ç³»åˆ†å²ã‚’ã‚«ãƒãƒ¼ã§ãã‚‹

### ğŸ“ˆ æ¬¡ã®ãƒ¬ãƒ™ãƒ«ã¸ã®æº–å‚™
ã“ã‚Œã‚‰ã®è£œå¼·æ¼”ç¿’ã‚’å®Œäº†ã—ãŸã‚‰ã€ã€Œ06_å®Ÿå‹™é©ç”¨ã‚¬ã‚¤ãƒ‰.mdã€ã§å®Ÿéš›ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã®åˆ†å²ç¶²ç¾…æ´»ç”¨æ–¹æ³•ã‚’å­¦ç¿’ã—ã€ã•ã‚‰ã«é«˜åº¦ãªæŠ€æ³•ï¼ˆæ¡ä»¶ç¶²ç¾…ã€MC/DCç­‰ï¼‰ã¸ã®æŒ‘æˆ¦æº–å‚™ã‚‚æ•´ã„ã¾ã™ã€‚

å®Ÿå‹™ã§ã®è¤‡é›‘ãªã‚³ãƒ¼ãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¯¾ã™ã‚‹åˆ†å²ç¶²ç¾…é©ç”¨ã‚¹ã‚­ãƒ«ã‚’èº«ã«ã¤ã‘ã¾ã—ã‚‡ã†ï¼
