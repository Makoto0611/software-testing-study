# 💪 命令網羅 上級演習・実務レベル

## 📚 学習目標設定

### 🎯 **この段階で目指すゴール**
実務で遭遇する複雑なコード構造に対しても適切な命令網羅分析を実行し、プロジェクトの品質向上に貢献できるレベルに到達する

### 📋 **具体的な学習成果物**
- [ ] 大規模・複雑なコードでの命令網羅分析の実行能力
- [ ] オブジェクト指向・関数型プログラミングでの適用
- [ ] 非同期処理・並行処理を含むコード分析
- [ ] 継承・ポリモーフィズムを考慮した命令網羅
- [ ] 実務プロジェクトでの適用戦略の策定能力

### ⏰ **推奨学習時間**
約120分（理論40分 + 演習80分）

### 👥 **対象者**
- 基本的な命令網羅を習得済みの方
- 実務でより高度なコード分析を求められる方
- チーム内でテスト品質向上を推進する方

---

## 🎯 上級命令網羅の概念

### 🔧 **実務での複雑性**

#### **複雑性の要因**
1. **大規模コードベース**: 多数のクラス・関数が相互依存
2. **設計パターンの使用**: 抽象クラス・インターフェースの活用
3. **非同期・並行処理**: Promise・async/await・マルチスレッド
4. **動的な振る舞い**: リフレクション・動的ロード・プラグイン
5. **外部依存**: データベース・API・ファイルシステム

#### **上級技法が必要な場面**
```
❌ 単純: 単一クラスの単純なメソッド
✅ 複雑: 複数クラスが連携する業務ロジック
       非同期処理を含むWebアプリケーション
       継承階層を持つオブジェクト指向システム
       プラグインアーキテクチャのフレームワーク
```

### 📊 **上級命令網羅のアプローチ**

#### **1. 階層化分析**
複雑なシステムを階層に分けて分析

```
システム階層:
├── プレゼンテーション層
│   ├── コントローラー
│   └── ビューロジック
├── ビジネス層
│   ├── サービスクラス
│   └── ドメインモデル
└── データアクセス層
    ├── リポジトリ
    └── データマッパー
```

#### **2. 統合的カバレッジ分析**
複数コンポーネントの統合時の命令網羅

```
統合レベル:
単体レベル: 各クラス・関数の命令網羅
統合レベル: モジュール間連携での命令網羅
システムレベル: エンドツーエンドでの命令網羅
```

#### **3. 動的分析**
実行時に決定される処理パスの命令網羅

```
動的要素:
- 設定ファイルによる振る舞い変更
- ユーザー権限による機能制限
- 環境変数による処理分岐
- プラグインの有無による機能差
```

---

## 🎯 上級演習

### 📝 **演習1: オブジェクト指向システムの分析**

#### **仕様: 図書館管理システム**
```java
// 基底クラス
abstract class LibraryItem {
    protected String id;
    protected String title;
    protected boolean isAvailable;
    
    public LibraryItem(String id, String title) {  // 命令1
        this.id = id;                               // 命令2
        this.title = title;                         // 命令3
        this.isAvailable = true;                    // 命令4
    }
    
    public abstract double calculateFee(int days); // 抽象メソッド
    
    public boolean checkout() {                     // 命令5
        if (isAvailable) {                          // 命令6
            isAvailable = false;                    // 命令7
            return true;                            // 命令8
        }
        return false;                               // 命令9
    }
}

// 具象クラス1
class Book extends LibraryItem {
    private String author;
    
    public Book(String id, String title, String author) {  // 命令10
        super(id, title);                                   // 命令11 (基底クラス1-4)
        this.author = author;                               // 命令12
    }
    
    @Override
    public double calculateFee(int days) {          // 命令13
        if (days <= 14) {                           // 命令14
            return 0.0;                             // 命令15
        } else {
            return (days - 14) * 0.5;               // 命令16
        }
    }
}

// 具象クラス2
class DVD extends LibraryItem {
    private int duration;
    
    public DVD(String id, String title, int duration) {    // 命令17
        super(id, title);                                   // 命令18 (基底クラス1-4)
        this.duration = duration;                           // 命令19
    }
    
    @Override
    public double calculateFee(int days) {          // 命令20
        return days * 1.0;                          // 命令21
    }
}

// サービスクラス
class LibraryService {
    public void processCheckout(LibraryItem item, int expectedDays) {
        boolean success = item.checkout();          // 命令22 (基底クラス5-9)
        
        if (success) {                              // 命令23
            double fee = item.calculateFee(expectedDays);   // 命令24 (子クラスの実装)
            System.out.println("貸出成功。料金: " + fee);     // 命令25
        } else {
            System.out.println("貸出失敗");           // 命令26
        }
    }
}
```

#### **課題**
1. 各クラスでの命令網羅分析を実行
2. ポリモーフィズムを考慮したテストケース設計
3. 統合テスト時の命令網羅戦略

#### **解答記入欄**

**1. クラス別命令分析**
| クラス | 命令数 | 主要なテストポイント |
|--------|--------|---------------------|
| LibraryItem | 個 | |
| Book | 個 | |
| DVD | 個 | |
| LibraryService | 個 | |

**2. ポリモーフィズムテストケース**
| テストケース | オブジェクト型 | メソッド呼び出し | 実行される命令 | 期待結果 |
|-------------|---------------|-----------------|----------------|----------|
| TC1 | Book | processCheckout | | |
| TC2 | DVD | processCheckout | | |
| TC3 | Book(貸出済) | processCheckout | | |

**3. 統合テスト戦略**
```
統合レベルでの命令網羅方針: [記入]
テスト効率化のアプローチ: [記入]
```

### 📝 **演習2: 非同期処理の命令網羅**

#### **仕様: 非同期データ処理システム**
```javascript
class DataProcessor {
    constructor() {
        this.cache = new Map();                     // 命令1
        this.isProcessing = false;                  // 命令2
    }
    
    async processData(data) {
        if (this.isProcessing) {                    // 命令3
            throw new Error("Already processing");  // 命令4
        }
        
        this.isProcessing = true;                   // 命令5
        
        try {
            // キャッシュチェック
            if (this.cache.has(data.id)) {          // 命令6
                const cached = this.cache.get(data.id);  // 命令7
                this.isProcessing = false;          // 命令8
                return cached;                      // 命令9
            }
            
            // 非同期処理
            const result = await this.fetchRemoteData(data.url);  // 命令10
            
            if (result.success) {                   // 命令11
                const processed = await this.transformData(result.data);  // 命令12
                this.cache.set(data.id, processed); // 命令13
                return processed;                   // 命令14
            } else {
                throw new Error("Remote fetch failed");  // 命令15
            }
            
        } catch (error) {
            console.error("Processing error:", error);  // 命令16
            throw error;                            // 命令17
        } finally {
            this.isProcessing = false;              // 命令18
        }
    }
    
    async fetchRemoteData(url) {
        // シミュレーション：50%の確率で成功
        return new Promise((resolve) => {           // 命令19
            setTimeout(() => {                      // 命令20
                if (Math.random() > 0.5) {          // 命令21
                    resolve({ success: true, data: { value: 42 } });  // 命令22
                } else {
                    resolve({ success: false });    // 命令23
                }
            }, 100);                               // 命令24
        });
    }
    
    async transformData(data) {
        return new Promise((resolve) => {           // 命令25
            setTimeout(() => {                      // 命令26
                resolve({ transformed: data.value * 2 });  // 命令27
            }, 50);                                // 命令28
        });
    }
}
```

#### **課題**
1. 非同期処理での実行パスを分析
2. 成功・失敗・例外の各シナリオでのテストケース設計
3. 非同期テストでの命令網羅測定方法

#### **解答記入欄**

**1. 非同期実行パス分析**
```
成功パス（キャッシュなし）: [記入]
成功パス（キャッシュあり）: [記入]
失敗パス（fetch失敗）: [記入]
例外パス（並行実行）: [記入]
```

**2. 非同期テストケース設計**
| テストケース | 初期状態 | 入力データ | モック設定 | 実行される命令 | 期待結果 |
|-------------|----------|------------|-----------|----------------|----------|
| TC1 | 初期状態 | 新データ | 成功 | | |
| TC2 | キャッシュあり | 既存データ | - | | |
| TC3 | 初期状態 | 新データ | 失敗 | | |
| TC4 | 処理中 | 任意 | - | | |

**3. 非同期カバレッジ測定**
```
測定方法: [記入]
注意点: [記入]
ツール設定: [記入]
```

### 📝 **演習3: 設計パターンと命令網羅**

#### **仕様: Factory + Strategy パターンシステム**
```python
from abc import ABC, abstractmethod
from enum import Enum

class PaymentType(Enum):
    CREDIT_CARD = "credit_card"     # 命令1
    BANK_TRANSFER = "bank_transfer" # 命令2
    DIGITAL_WALLET = "digital_wallet" # 命令3

# Strategy Pattern
class PaymentStrategy(ABC):
    @abstractmethod
    def process_payment(self, amount: float) -> dict:
        pass                                # 抽象メソッド

class CreditCardPayment(PaymentStrategy):
    def __init__(self, card_number: str):   # 命令4
        self.card_number = card_number      # 命令5
    
    def process_payment(self, amount: float) -> dict:  # 命令6
        if amount <= 0:                     # 命令7
            return {"success": False, "error": "Invalid amount"}  # 命令8
        
        if amount > 10000:                  # 命令9
            return {"success": False, "error": "Amount too large"}  # 命令10
        
        # クレジットカード処理シミュレーション
        fee = amount * 0.03                 # 命令11
        return {                            # 命令12
            "success": True,
            "transaction_id": f"cc_{self.card_number[-4:]}",
            "fee": fee
        }

class BankTransferPayment(PaymentStrategy):
    def __init__(self, account_number: str):  # 命令13
        self.account_number = account_number  # 命令14
    
    def process_payment(self, amount: float) -> dict:  # 命令15
        if amount <= 0:                     # 命令16
            return {"success": False, "error": "Invalid amount"}  # 命令17
        
        # 銀行振込は高額でも可能
        fee = 500 if amount < 50000 else 1000  # 命令18
        return {                            # 命令19
            "success": True,
            "transaction_id": f"bt_{self.account_number[-4:]}",
            "fee": fee
        }

class DigitalWalletPayment(PaymentStrategy):
    def __init__(self, wallet_id: str):     # 命令20
        self.wallet_id = wallet_id          # 命令21
    
    def process_payment(self, amount: float) -> dict:  # 命令22
        if amount <= 0:                     # 命令23
            return {"success": False, "error": "Invalid amount"}  # 命令24
        
        if amount > 5000:                   # 命令25
            return {"success": False, "error": "Wallet limit exceeded"}  # 命令26
        
        fee = amount * 0.01                 # 命令27
        return {                            # 命令28
            "success": True,
            "transaction_id": f"dw_{self.wallet_id}",
            "fee": fee
        }

# Factory Pattern
class PaymentFactory:
    @staticmethod
    def create_payment(payment_type: PaymentType, credentials: str) -> PaymentStrategy:
        if payment_type == PaymentType.CREDIT_CARD:      # 命令29
            return CreditCardPayment(credentials)        # 命令30 (+ 4,5)
        elif payment_type == PaymentType.BANK_TRANSFER:  # 命令31
            return BankTransferPayment(credentials)      # 命令32 (+ 13,14)
        elif payment_type == PaymentType.DIGITAL_WALLET: # 命令33
            return DigitalWalletPayment(credentials)     # 命令34 (+ 20,21)
        else:
            raise ValueError(f"Unsupported payment type: {payment_type}")  # 命令35

# Context
class PaymentProcessor:
    def __init__(self):
        self.transaction_log = []           # 命令36
    
    def process_payment(self, payment_type: PaymentType, credentials: str, amount: float) -> dict:
        try:
            strategy = PaymentFactory.create_payment(payment_type, credentials)  # 命令37 (+ Factory)
            result = strategy.process_payment(amount)  # 命令38 (+ Strategy実装)
            
            self.transaction_log.append({    # 命令39
                "type": payment_type.value,
                "amount": amount,
                "result": result
            })
            
            return result                   # 命令40
            
        except Exception as e:
            error_result = {"success": False, "error": str(e)}  # 命令41
            self.transaction_log.append({   # 命令42
                "type": "error",
                "amount": amount,
                "result": error_result
            })
            return error_result             # 命令43
```

#### **課題**
1. 設計パターンを考慮した命令網羅戦略
2. Factory + Strategy パターンでの統合テスト設計
3. 全ての組み合わせを効率的にカバーするテストケース

#### **解答記入欄**

**1. パターン別命令分析**
| パターン要素 | 命令数 | テスト戦略 |
|-------------|--------|------------|
| Factory | 個 | |
| Strategy基底 | 個 | |
| CreditCard戦略 | 個 | |
| BankTransfer戦略 | 個 | |
| DigitalWallet戦略 | 個 | |
| Context | 個 | |

**2. 統合テストケース設計**
| TC | 支払い種別 | 金額 | 期待する戦略 | 実行命令 | 期待結果 |
|----|-----------|------|-------------|----------|----------|
| TC1 | CREDIT_CARD | 1000 | CreditCard | | |
| TC2 | BANK_TRANSFER | 100000 | BankTransfer | | |
| TC3 | DIGITAL_WALLET | 3000 | DigitalWallet | | |
| TC4 | CREDIT_CARD | 20000 | CreditCard | | |
| TC5 | 無効な種別 | 1000 | 例外 | | |

**3. 効率化戦略**
```
最小テストケースでの最大網羅方針: [記入]
パターン固有の考慮事項: [記入]
```

---

## 🔧 実務レベルでの考慮事項

### 📊 **大規模システムでの命令網羅**

#### **分割統治アプローチ**
```
レベル1: 単体クラス・関数レベル
- 個々のメソッドでの命令網羅
- 分岐・ループ・例外処理の確認

レベル2: モジュール・パッケージレベル  
- 関連クラス群での統合命令網羅
- インターフェース・境界での分析

レベル3: システム・アプリケーションレベル
- エンドツーエンドでの命令網羅
- ユーザーシナリオベースでの分析
```

#### **優先度ベースの戦略**
```
最高優先度: ビジネスクリティカルな処理
高優先度: ユーザー影響の大きな機能
中優先度: 内部処理・バッチ処理
低優先度: ログ出力・デバッグ機能
```

### 🛠️ **CI/CDパイプラインでの命令網羅**

#### **継続的品質管理**
```yaml
# GitHub Actions例
name: Code Coverage
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Setup Java
      uses: actions/setup-java@v2
      with:
        java-version: '11'
    - name: Run tests with coverage
      run: mvn clean test jacoco:report
    - name: Check coverage threshold
      run: |
        COVERAGE=$(grep -o 'line-rate="[^"]*"' target/site/jacoco/jacoco.xml | head -1 | cut -d'"' -f2)
        PERCENTAGE=$(echo "$COVERAGE * 100" | bc)
        if (( $(echo "$PERCENTAGE < 80" | bc -l) )); then
          echo "Coverage $PERCENTAGE% is below threshold 80%"
          exit 1
        fi
```

#### **品質ゲートの設定**
```
リリース基準:
- 新規コード: 90%以上の命令網羅
- 既存コード: 80%以上の命令網羅  
- クリティカル機能: 100%の命令網羅

継続的監視:
- 命令網羅率の推移トラッキング
- カバレッジ低下時のアラート
- 定期的なカバレッジレポート
```

---

## 📊 この段階の学習成果確認

### ✅ **上級スキルチェックリスト**

#### **複雑性対応力**
- [ ] オブジェクト指向システムでの命令網羅を実行できる
- [ ] 非同期・並行処理での分析ができる
- [ ] 設計パターンを考慮した戦略を立てられる

#### **実務適用力**
- [ ] 大規模システムでの分割統治アプローチができる
- [ ] CI/CDパイプラインでの命令網羅を設計できる
- [ ] チーム内での命令網羅推進ができる

#### **品質管理力**
- [ ] 命令網羅の効果を測定・評価できる
- [ ] 継続的改善のサイクルを構築できる
- [ ] パフォーマンス・保守性を考慮した設計ができる

### 📝 **学習成果の記録**

#### **習得できた上級スキル**
```
[記入例]
- オブジェクト指向での階層的命令網羅分析
- 非同期処理でのカバレッジ測定手法
- 設計パターンでの統合テスト戦略
```

#### **実務適用の具体的イメージ**
```
[記入例]
- 次のプロジェクトで試したい命令網羅手法
- チーム内での品質向上推進方法
- CI/CDパイプラインでの自動化方針
```

#### **さらに向上したい領域**
```
[記入例]
- マイクロサービスでの分散システム分析
- 大規模レガシーシステムでの段階的改善
- パフォーマンステストとの統合
```

---

## 🚀 次のステップ

### ✅ **この段階完了の判断基準**
- 複雑な実務レベルのコード分析ができる
- オブジェクト指向・非同期処理に対応できる
- 実際のプロジェクトでの適用戦略を策定できる

### 📖 **次の学習内容**
`05_追加演習・補強練習.md` で、特定分野の深掘りや弱点補強を行います。

### 🎯 **実務での活用準備**
- 学習内容を実際のプロジェクトで試用
- チームメンバーとの知識共有
- 継続的な品質改善の実践

**💪 実務レベルスキル確認**
複雑なコード構造に対しても適切な命令網羅分析を実行し、プロジェクトの品質向上に貢献できるレベルに到達しましたか？

次の段階では、理解不足の補強や特定分野での深掘り学習により、より安定したスキルの習得を目指します！