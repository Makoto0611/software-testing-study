# 🚀 分岐網羅（Branch Coverage）- 実務適用ガイド

## 🎯 実務プロジェクトでの分岐網羅活用戦略

### 📊 プロジェクト規模・特性別の適用方針

#### 🏢 エンタープライズ系システム
- **目標分岐網羅率**: 85-90%
- **重点領域**: ビジネスロジック、認証・認可、データ変換処理
- **除外対象**: ログ出力、設定読み込み、単純なGetter/Setter
- **測定頻度**: 毎日のCI/CD、週次レポート

```java
// エンタープライズ系での典型的な分岐網羅対象
public class OrderProcessingService {
    public OrderResult processOrder(OrderRequest request) {
        // ビジネスルール検証 → 重点的に分岐網羅
        if (!validateBusinessRules(request)) {
            return OrderResult.failure("Business rule violation");
        }
        
        // 在庫チェック → 重点的に分岐網羅
        if (!checkInventory(request.getItems())) {
            return OrderResult.failure("Insufficient inventory");
        }
        
        // 決済処理 → 重点的に分岐網羅
        PaymentResult payment = processPayment(request.getPayment());
        if (!payment.isSuccess()) {
            return OrderResult.failure("Payment failed");
        }
        
        return OrderResult.success();
    }
}
```

#### 🌐 Webアプリケーション
- **目標分岐網羅率**: 80-85%
- **重点領域**: コントローラー、サービスレイヤー、バリデーション
- **除外対象**: ビュー関連、静的リソース処理
- **測定頻度**: プルリクエスト毎、リリース前

#### 📱 組み込み・IoTシステム
- **目標分岐網羅率**: 90-95%
- **重点領域**: 制御ロジック、エラーハンドリング、状態管理
- **除外対象**: ハードウェア依存部分（モック化）
- **測定頻度**: 継続的、ハードウェアテスト前必須

#### 🏥 高信頼性システム（医療・金融・航空）
- **目標分岐網羅率**: 95-100%
- **重点領域**: 全モジュール（例外なし）
- **除外対象**: 極力なし（正当化が必要）
- **測定頻度**: 変更毎、認証プロセス組み込み

---

## 🔗 他テスト技法との効果的な組み合わせ

### 🎯 ブラックボックス技法との統合

#### 💡 同値分割 + 分岐網羅
```java
public class CreditScoreCalculator {
    public String getCreditRating(int score, int income) {
        // 同値分割によるスコア分類
        if (score >= 800) {          // 分岐1: 優良顧客
            if (income >= 5000000) {  // 分岐2: 高所得
                return "PREMIUM";
            } else {
                return "STANDARD_PLUS";
            }
        } else if (score >= 700) {   // 分岐3: 標準顧客
            return "STANDARD";
        } else if (score >= 600) {   // 分岐4: 注意顧客
            return "CAUTION";
        } else {                     // 分岐5: 要注意顧客
            return "HIGH_RISK";
        }
    }
}

// 統合テスト戦略
@Test
public void testCreditRating_IntegratedApproach() {
    CreditScoreCalculator calc = new CreditScoreCalculator();
    
    // 同値分割の代表値で分岐網羅を達成
    assertEquals("PREMIUM", calc.getCreditRating(850, 6000000));     // 分岐1-T, 分岐2-T
    assertEquals("STANDARD_PLUS", calc.getCreditRating(810, 4000000)); // 分岐1-T, 分岐2-F
    assertEquals("STANDARD", calc.getCreditRating(750, 3000000));     // 分岐3-T
    assertEquals("CAUTION", calc.getCreditRating(650, 2000000));      // 分岐4-T
    assertEquals("HIGH_RISK", calc.getCreditRating(550, 1000000));    // 分岐5実行
    
    // 境界値分析も組み合わせ
    assertEquals("PREMIUM", calc.getCreditRating(800, 5000000));      // 境界値での分岐確認
    assertEquals("STANDARD", calc.getCreditRating(700, 3000000));     // 境界値での分岐確認
}
```

#### 💡 デシジョンテーブル + 分岐網羅
```java
public class InsuranceEligibilityChecker {
    public EligibilityResult checkEligibility(int age, boolean hasLicense, 
                                            boolean hasAccidents, int yearsExperience) {
        // 複雑な条件の組み合わせ
        if (age < 18) {                              // 分岐1
            return EligibilityResult.rejected("Too young");
        }
        
        if (!hasLicense) {                           // 分岐2
            return EligibilityResult.rejected("No license");
        }
        
        if (age >= 18 && age <= 25) {                // 分岐3: 若年層
            if (hasAccidents) {                      // 分岐4
                return EligibilityResult.highRisk("Young with accidents");
            } else if (yearsExperience < 2) {        // 分岐5
                return EligibilityResult.mediumRisk("Inexperienced");
            } else {
                return EligibilityResult.accepted("Young experienced");
            }
        } else if (age > 65) {                       // 分岐6: 高齢層
            if (hasAccidents) {                      // 分岐7
                return EligibilityResult.highRisk("Senior with accidents");
            } else {
                return EligibilityResult.accepted("Senior clean record");
            }
        } else {                                     // 分岐8: 中年層
            return hasAccidents ? 
                EligibilityResult.mediumRisk("Middle-aged with accidents") :  // 分岐9-T
                EligibilityResult.accepted("Standard");                       // 分岐9-F
        }
    }
}

// デシジョンテーブルで整理された分岐網羅テスト
@Test
public void testInsuranceEligibility_DecisionTableBranchCoverage() {
    InsuranceEligibilityChecker checker = new InsuranceEligibilityChecker();
    
    // デシジョンテーブルの各行が分岐網羅の要求を満たす
    
    // 年齢条件の分岐
    assertEquals("REJECTED", checker.checkEligibility(17, true, false, 0).getStatus());  // 分岐1-T
    
    // ライセンス条件の分岐
    assertEquals("REJECTED", checker.checkEligibility(25, false, false, 3).getStatus()); // 分岐2-T
    
    // 若年層の分岐パターン
    assertEquals("HIGH_RISK", checker.checkEligibility(20, true, true, 3).getStatus());    // 分岐3-T, 分岐4-T
    assertEquals("MEDIUM_RISK", checker.checkEligibility(22, true, false, 1).getStatus()); // 分岐3-T, 分岐4-F, 分岐5-T
    assertEquals("ACCEPTED", checker.checkEligibility(24, true, false, 5).getStatus());    // 分岐3-T, 分岐4-F, 分岐5-F
    
    // 高齢層の分岐パターン
    assertEquals("HIGH_RISK", checker.checkEligibility(70, true, true, 20).getStatus());   // 分岐6-T, 分岐7-T
    assertEquals("ACCEPTED", checker.checkEligibility(68, true, false, 30).getStatus());   // 分岐6-T, 分岐7-F
    
    // 中年層の分岐パターン
    assertEquals("MEDIUM_RISK", checker.checkEligibility(40, true, true, 10).getStatus()); // 分岐8, 分岐9-T
    assertEquals("ACCEPTED", checker.checkEligibility(45, true, false, 15).getStatus());   // 分岐8, 分岐9-F
}
```

### 🎯 ホワイトボックス技法との連携

#### 💡 分岐網羅 → 条件網羅への発展
```java
public class AccessControlValidator {
    public boolean validateAccess(User user, Resource resource, String operation) {
        // 複合条件での分岐網羅から条件網羅への発展例
        if (user != null && user.isActive() && 
            resource != null && resource.isAccessible()) {  // 複合条件
            
            if (user.hasRole("ADMIN") || 
                (user.hasPermission(operation) && resource.isPublic())) {  // ネストした複合条件
                return true;
            }
        }
        
        return false;
    }
}

// 分岐網羅レベルのテスト
@Test
public void testValidateAccess_BranchCoverage() {
    AccessControlValidator validator = new AccessControlValidator();
    
    // 分岐1の True/False
    assertTrue(validator.validateAccess(activeUser, publicResource, "READ"));   // 全条件True
    assertFalse(validator.validateAccess(null, publicResource, "READ"));       // 最初の条件False
    
    // 分岐2の True/False  
    assertTrue(validator.validateAccess(adminUser, privateResource, "WRITE"));  // ADMIN権限でTrue
    assertFalse(validator.validateAccess(normalUser, privateResource, "WRITE")); // 権限不足でFalse
}

// 条件網羅レベルのテスト（より詳細）
@Test
public void testValidateAccess_ConditionCoverage() {
    // user != null の True/False
    assertFalse(validator.validateAccess(null, publicResource, "READ"));
    assertTrue(validator.validateAccess(activeUser, publicResource, "READ"));
    
    // user.isActive() の True/False
    assertFalse(validator.validateAccess(inactiveUser, publicResource, "READ"));
    assertTrue(validator.validateAccess(activeUser, publicResource, "READ"));
    
    // resource != null の True/False
    assertFalse(validator.validateAccess(activeUser, null, "READ"));
    assertTrue(validator.validateAccess(activeUser, publicResource, "READ"));
    
    // resource.isAccessible() の True/False
    assertFalse(validator.validateAccess(activeUser, inaccessibleResource, "READ"));
    assertTrue(validator.validateAccess(activeUser, publicResource, "READ"));
    
    // 以下、内部条件も同様に詳細テスト...
}
```

---

## 🛠️ 実務でのツール活用戦略

### 📊 CI/CDパイプライン統合

#### 💡 Jenkins Pipeline での分岐網羅管理
```groovy
pipeline {
    agent any
    
    stages {
        stage('Build & Test') {
            steps {
                sh 'mvn clean compile test'
            }
        }
        
        stage('Coverage Analysis') {
            steps {
                sh 'mvn jacoco:report'
                
                script {
                    // 分岐網羅率の取得と評価
                    def coverage = readFile('target/site/jacoco/index.html')
                    def branchCoverage = extractBranchCoverage(coverage)
                    
                    echo "Branch Coverage: ${branchCoverage}%"
                    
                    // 品質ゲートの設定
                    if (branchCoverage < 85) {
                        error("Branch coverage ${branchCoverage}% is below minimum threshold of 85%")
                    }
                    
                    if (branchCoverage < 90) {
                        echo "WARNING: Branch coverage ${branchCoverage}% is below recommended threshold of 90%"
                    }
                }
            }
        }
        
        stage('Coverage Reporting') {
            steps {
                publishHTML([
                    allowMissing: false,
                    alwaysLinkToLastBuild: true,
                    keepAll: true,
                    reportDir: 'target/site/jacoco',
                    reportFiles: 'index.html',
                    reportName: 'JaCoCo Coverage Report'
                ])
                
                // SonarQubeへの分析結果送信
                withSonarQubeEnv('SonarQube') {
                    sh 'mvn sonar:sonar'
                }
            }
        }
    }
    
    post {
        always {
            archiveArtifacts artifacts: 'target/site/jacoco/**', allowEmptyArchive: true
        }
        
        failure {
            emailext (
                subject: "Build Failed: Branch Coverage Below Threshold",
                body: "The build failed due to insufficient branch coverage. Please review and add necessary test cases.",
                to: "${env.CHANGE_AUTHOR_EMAIL}"
            )
        }
    }
}

def extractBranchCoverage(htmlContent) {
    // HTML から分岐網羅率を抽出するロジック
    def pattern = /Branch.*?(\d+)%/
    def matcher = htmlContent =~ pattern
    return matcher ? matcher[0][1] as Integer : 0
}
```

#### 💡 GitHub Actions での分岐網羅品質ゲート
```yaml
name: Quality Gate with Branch Coverage

on:
  pull_request:
    branches: [ main, develop ]
  push:
    branches: [ main ]

jobs:
  test-coverage:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 11
      uses: actions/setup-java@v3
      with:
        java-version: '11'
        distribution: 'temurin'
    
    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
    
    - name: Run tests with coverage
      run: mvn clean test jacoco:report
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./target/site/jacoco/jacoco.xml
        
    - name: Branch Coverage Check
      run: |
        BRANCH_COVERAGE=$(grep -Po 'branch-rate="\K[^"]*' target/site/jacoco/jacoco.xml | head -1)
        BRANCH_PERCENTAGE=$(echo "$BRANCH_COVERAGE * 100" | bc -l | cut -d. -f1)
        
        echo "Branch Coverage: $BRANCH_PERCENTAGE%"
        
        if [ $BRANCH_PERCENTAGE -lt 85 ]; then
          echo "❌ Branch coverage $BRANCH_PERCENTAGE% is below minimum threshold of 85%"
          exit 1
        elif [ $BRANCH_PERCENTAGE -lt 90 ]; then
          echo "⚠️ Branch coverage $BRANCH_PERCENTAGE% is below recommended threshold of 90%"
        else
          echo "✅ Branch coverage $BRANCH_PERCENTAGE% meets quality standards"
        fi
    
    - name: Comment PR with coverage
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          const path = 'target/site/jacoco/index.html';
          
          if (fs.existsSync(path)) {
            const coverage = fs.readFileSync(path, 'utf8');
            const branchMatch = coverage.match(/Branch.*?(\d+)%/);
            const branchCoverage = branchMatch ? branchMatch[1] : 'Unknown';
            
            const body = `## 📊 Test Coverage Report
            
            | Metric | Coverage |
            |--------|----------|
            | Branch Coverage | ${branchCoverage}% |
            
            ${branchCoverage >= 90 ? '✅' : branchCoverage >= 85 ? '⚠️' : '❌'} Branch coverage: ${branchCoverage}%
            
            [View detailed coverage report](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID})`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
          }
```

### 📈 継続的品質改善

#### 💡 週次品質レビュープロセス
```markdown
## 週次分岐網羅レビュー テンプレート

### 📊 今週の分岐網羅状況
- 全体分岐網羅率: XX%
- 前週比: ±X%
- 目標達成率: XX/XX モジュール

### 📈 改善トレンド
- 新規追加コード分岐網羅率: XX%
- 既存コード改善: XX ブランチ追加カバー
- 未カバー分岐数: XX → XX（ΔXX）

### 🎯 重点改善エリア
1. **モジュール名**: 現在XX% → 目標XX%
   - 未カバー分岐: エラーハンドリング系
   - 改善計画: 異常系テスト追加
   - 担当者: XXX
   - 期限: YYYY/MM/DD

2. **モジュール名**: 現在XX% → 目標XX%
   - 未カバー分岐: 条件分岐の片側
   - 改善計画: 境界値テスト追加
   - 担当者: XXX
   - 期限: YYYY/MM/DD

### 🚨 品質リスク
- 分岐網羅率低下モジュール: XXX（XX% → XX%）
- 新規未テストコード: XX行
- 技術的負債: XX箇所

### 📋 来週のアクションプラン
- [ ] XX モジュールの異常系テスト追加
- [ ] XX 機能の境界値テスト強化
- [ ] 分岐網羅ツール設定見直し
- [ ] チーム内分岐網羅勉強会実施
```

---

## 🎯 プロジェクト段階別の適用戦略

### 🚀 プロジェクト開始期
```markdown
## 分岐網羅導入チェックリスト

### 📋 事前準備
- [ ] プロジェクト特性に応じた目標網羅率設定
- [ ] 除外対象の明確化と文書化
- [ ] 使用ツールの選定と環境構築
- [ ] チームメンバーの技法習得

### 🛠️ 環境設定
- [ ] カバレッジツールの導入（JaCoCo, OpenCover等）
- [ ] CI/CDパイプラインへの統合
- [ ] 品質ゲートの設定
- [ ] レポート自動生成の設定

### 📚 チーム教育
- [ ] 分岐網羅の基本概念説明
- [ ] ツールの使用方法研修
- [ ] 効果的なテスト設計手法共有
- [ ] 実践演習の実施
```

### 🏗️ 開発期
```markdown
## 開発フェーズでの分岐網羅活動

### 💻 日常的な活動
1. **コード作成時**
   - 分岐を意識した実装
   - テスト容易性を考慮した設計
   - 複雑な分岐の文書化

2. **テスト作成時**
   - 分岐網羅を基準としたテスト設計
   - カバレッジ測定とギャップ分析
   - 未カバー分岐の意図的な判断

3. **レビュー時**
   - 分岐網羅状況の確認
   - テストケースの妥当性検証
   - 除外判断の妥当性確認

### 📊 定期的な測定
- 日次: CI/CDでの自動測定
- 週次: 詳細分析とトレンド確認
- 月次: プロジェクト全体の評価
```

### 🔍 テスト期
```markdown
## テストフェーズでの分岐網羅強化

### 🎯 統合テストでの活用
- 機能間の分岐パスの確認
- システム全体での分岐網羅測定
- 性能テストでの分岐実行確認

### 🔧 品質改善活動
1. **未カバー分岐の分析**
   - 到達困難な分岐の特定
   - テスト追加の優先順位付け
   - 除外判断の最終確認

2. **テストケースの最適化**
   - 冗長なテストケースの削除
   - 効率的な分岐カバーの実現
   - 保守性の向上

### 📈 品質評価
- 目標網羅率の達成状況
- 品質指標との相関分析
- 次期プロジェクトへの改善提案
```

---

## 💡 実務での成功パターンとアンチパターン

### ✅ 成功パターン

#### 🎯 段階的導入アプローチ
```java
// Phase 1: 主要ビジネスロジックから開始
@Test
public void testCoreBusinessLogic_BranchCoverage() {
    // 最重要な業務処理の分岐網羅から開始
    // 80%目標で開始し、徐々に向上
}

// Phase 2: サービス層全体に拡大
@Test  
public void testServiceLayer_BranchCoverage() {
    // サービス層全体の分岐網羅
    // 85%目標に向上
}

// Phase 3: システム全体に展開
@Test
public void testSystemWide_BranchCoverage() {
    // システム全体の分岐網羅
    // 90%目標を設定
}
```

#### 💪 チーム内での知識共有
```markdown
## 分岐網羅ベストプラクティス共有会

### 📚 定期勉強会
- 月1回の技法共有セッション
- 実際のコード例での演習
- 困ったケースの相談タイム

### 💬 日常的な知識共有
- コードレビューでの分岐網羅観点追加
- ペアプログラミングでの技法適用
- チーム内Wikiでのノウハウ蓄積
```

### ❌ アンチパターン

#### 💣 網羅率至上主義
```java
// 悪い例: 意味のない分岐カバーのためのテスト
@Test
public void testJustForCoverage() {
    // カバレッジのためだけのテスト
    method.process(null); // 例外発生するだけ
    // アサーションなし、ビジネス価値なし
}

// 良い例: 意味のある分岐テスト
@Test
public void testNullInput_ReturnsErrorResult() {
    ProcessResult result = processor.process(null);
    
    assertFalse(result.isSuccess());
    assertEquals("Invalid input", result.getErrorMessage());
    assertEquals(ErrorCode.INVALID_INPUT, result.getErrorCode());
}
```

#### 💣 過度な複雑性
```java
// 悪い例: 複雑すぎる分岐構造
public String complexMethod(int a, int b, int c, boolean flag1, boolean flag2) {
    if (a > 0) {
        if (b > 0) {
            if (c > 0) {
                if (flag1) {
                    if (flag2) {
                        // 5重ネスト → テストが困難
                        return "case1";
                    } else {
                        return "case2";
                    }
                } else {
                    return "case3";
                }
            } else {
                return "case4";
            }
        } else {
            return "case5";
        }
    } else {
        return "case6";
    }
}

// 良い例: 早期リターンでの簡素化
public String simplifiedMethod(int a, int b, int c, boolean flag1, boolean flag2) {
    if (a <= 0) return "case6";
    if (b <= 0) return "case5";
    if (c <= 0) return "case4";
    if (!flag1) return "case3";
    
    return flag2 ? "case1" : "case2";
}
```

---

## 🎯 実務適用の成功指標

### 📊 定量的指標
- **分岐網羅率**: プロジェクト目標の達成
- **バグ検出率**: 分岐網羅導入前後の比較
- **テスト効率**: テスト作成時間 vs カバレッジ向上
- **保守性**: テストコードの保守コスト

### 📈 定性的指標
- **チームスキル**: 分岐網羅技法の習熟度
- **品質意識**: 品質に対するチーム意識向上
- **プロセス改善**: 継続的な改善活動の定着
- **顧客満足**: システム品質向上による顧客評価

---

## 🚀 次のステップ：より高度な技法への発展

### 🔄 分岐網羅から条件網羅へ
分岐網羅をマスターしたら、次は**条件網羅（Condition Coverage）**に挑戦しましょう：

1. **条件網羅の理論学習**: より詳細な条件式のテスト
2. **MC/DC**: 航空宇宙等の高信頼性要求対応
3. **パス網羅**: 実行可能な全経路のテスト

### 💼 実務での継続的活用
- プロジェクトでの継続的な分岐網羅活用
- チームメンバーへの技法指導
- 組織の品質基準への組み込み提案

分岐網羅は**ホワイトボックステストの重要な基盤技法**です。実務で継続的に活用し、より高品質なソフトウェア開発を実現してください！
