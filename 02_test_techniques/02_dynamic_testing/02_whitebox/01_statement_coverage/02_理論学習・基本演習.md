# 🔬 命令網羅 理論学習・基本演習

## 📚 学習目標設定

### 🎓 **この段階で目指すゴール**
命令網羅の具体的な理論と手順を習得し、基本的なコード分析とテストケース設計ができるようになる

### 📋 **具体的な学習成果物**
- [ ] ソースコード分析の体系的手順の習得
- [ ] 命令網羅テストケース設計の実行能力
- [ ] カバレッジ測定の基本的なスキル
- [ ] 様々なプログラミング構造での応用能力
- [ ] 実践演習による基本スキルの定着

### ⏰ **推奨学習時間**
約90分（理論45分 + 演習45分）

---

## 🎯 命令網羅の理論

### 📖 **命令網羅の基本原理**

#### **命令（Statement）の定義**
```
命令とは:
- 実行可能な最小単位のコード
- 代入文、関数呼び出し、return文など
- 条件判定自体も命令として扱う場合がある
```

#### **命令網羅の目標**
```
目標: すべての実行可能な命令を少なくとも1回実行する

効果:
- デッドコード（未使用コード）の発見
- 実装されているがテストされていない機能の特定
- コード品質の定量的評価
```

### 🔍 **命令の種類と分析ポイント**

#### **基本的な命令タイプ**

**1. 代入文・計算文**
```java
int x = 10;              // 代入命令
int y = x + 5;           // 計算命令
String msg = "Hello";    // 文字列代入命令
```

**2. 条件分岐**
```java
if (x > 0) {            // 条件判定命令
    y = x * 2;          // 条件内の命令
} else {
    y = 0;              // else内の命令
}
```

**3. ループ**
```java
for (int i = 0; i < 10; i++) {  // ループ制御命令
    sum += i;                   // ループ内の命令
}
```

**4. 関数呼び出し・return文**
```java
result = calculate(x, y);  // 関数呼び出し命令
return result;             // return命令
```

---

## 🔧 命令網羅分析の手順

### 📋 **Step 1: ソースコード構造の把握**

#### **制御フローグラフの作成**
実際のコードから制御の流れを図示化

```java
public int calculateGrade(int score) {
    int grade;                    // 命令1
    
    if (score >= 90) {           // 命令2
        grade = 5;               // 命令3
    } else if (score >= 80) {    // 命令4
        grade = 4;               // 命令5
    } else if (score >= 70) {    // 命令6
        grade = 3;               // 命令7
    } else if (score >= 60) {    // 命令8
        grade = 2;               // 命令9
    } else {
        grade = 1;               // 命令10
    }
    
    return grade;                // 命令11
}
```

**制御フローの整理**
```
命令1 → 命令2 → [条件により分岐]
         ↓ true:  命令3 → 命令11
         ↓ false: 命令4 → [再び分岐]
                   ↓ true:  命令5 → 命令11
                   ↓ false: 命令6 → [再び分岐]
                            ↓ true:  命令7 → 命令11
                            ↓ false: 命令8 → [再び分岐]
                                     ↓ true:  命令9 → 命令11
                                     ↓ false: 命令10 → 命令11
```

### 📋 **Step 2: 実行パスの特定**

#### **全ての可能な実行パスの列挙**
```
パス1: 命令1 → 2 → 3 → 11     (score >= 90)
パス2: 命令1 → 2 → 4 → 5 → 11 (80 <= score < 90)
パス3: 命令1 → 2 → 4 → 6 → 7 → 11 (70 <= score < 80)
パス4: 命令1 → 2 → 4 → 6 → 8 → 9 → 11 (60 <= score < 70)
パス5: 命令1 → 2 → 4 → 6 → 8 → 10 → 11 (score < 60)
```

### 📋 **Step 3: テストケース設計**

#### **命令網羅のためのテストケース**
```
テストケース1: score = 95  → パス1実行 → 命令1,2,3,11
テストケース2: score = 85  → パス2実行 → 命令1,2,4,5,11
テストケース3: score = 75  → パス3実行 → 命令1,2,4,6,7,11
テストケース4: score = 65  → パス4実行 → 命令1,2,4,6,8,9,11
テストケース5: score = 50  → パス5実行 → 命令1,2,4,6,8,10,11

結果: 全命令1-11が実行される → 100%命令網羅達成
```

### 📋 **Step 4: カバレッジ測定**

#### **カバレッジ率の計算**
```
命令網羅率 = 実行された命令数 / 全命令数

例: テストケース1のみ実行した場合
実行命令: 1, 2, 3, 11 (4個)
全命令: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 (11個)
命令網羅率 = 4/11 = 36.4%
```

---

## 🎯 基本演習

### 📝 **演習1: 単純な条件分岐の分析**

#### **対象コード（Java）**
```java
public String checkPassword(String password) {
    if (password == null) {           // 命令1
        return "パスワードが未入力です";     // 命令2
    }
    
    if (password.length() < 8) {      // 命令3
        return "パスワードが短すぎます";     // 命令4
    }
    
    return "パスワードは有効です";          // 命令5
}
```

#### **課題**
1. 制御フローを分析してください
2. 100%命令網羅のためのテストケースを設計してください
3. 各テストケースで実行される命令を特定してください

#### **解答記入欄**

**1. 制御フロー分析**
```
[ここに制御フローを記入]
```

**2. テストケース設計**
| テストケース | 入力値 | 期待出力 | 実行される命令 |
|-------------|--------|----------|----------------|
| TC1 | | | |
| TC2 | | | |
| TC3 | | | |

**3. 命令網羅率計算**
```
全命令数: [記入]
各テストケースでの実行命令数: [記入]
すべてのテストケース実行後の命令網羅率: [記入]%
```

#### **解答例**

**1. 制御フロー分析**
```
命令1 → [null判定]
         ↓ true:  命令2 (return)
         ↓ false: 命令3 → [長さ判定]
                           ↓ true:  命令4 (return)
                           ↓ false: 命令5 (return)
```

**2. テストケース設計**
| テストケース | 入力値 | 期待出力 | 実行される命令 |
|-------------|--------|----------|----------------|
| TC1 | null | "パスワードが未入力です" | 1, 2 |
| TC2 | "123" | "パスワードが短すぎます" | 1, 3, 4 |
| TC3 | "12345678" | "パスワードは有効です" | 1, 3, 5 |

**3. 命令網羅率計算**
```
全命令数: 5
すべてのテストケース実行後の命令網羅率: 100%
(命令1,2,3,4,5すべてが実行される)
```

### 📝 **演習2: ループを含む分析**

#### **対象コード（Python）**
```python
def find_max(numbers):
    if not numbers:               # 命令1
        return None               # 命令2
    
    max_value = numbers[0]        # 命令3
    
    for num in numbers[1:]:       # 命令4
        if num > max_value:       # 命令5
            max_value = num       # 命令6
    
    return max_value              # 命令7
```

#### **課題**
1. 実行パスを分析してください
2. 100%命令網羅のためのテストケースを設計してください
3. ループが0回、1回、複数回実行される場合を考慮してください

#### **解答記入欄**

**1. 実行パス分析**
```
[ここに実行パスを記入]
```

**2. テストケース設計**
| テストケース | 入力値 | ループ実行 | 実行される命令 | 期待出力 |
|-------------|--------|------------|----------------|----------|
| TC1 | | 回 | | |
| TC2 | | 回 | | |
| TC3 | | 回 | | |
| TC4 | | 回 | | |

#### **解答例**

**1. 実行パス分析**
```
命令1 → [空リスト判定]
         ↓ true:  命令2 (return None)
         ↓ false: 命令3 → 命令4 → [ループ]
                                   ↓ ループ内: 命令5 → [比較判定]
                                                      ↓ true:  命令6
                                                      ↓ false: 次の要素へ
                                   ↓ ループ終了: 命令7 (return)
```

**2. テストケース設計**
| テストケース | 入力値 | ループ実行 | 実行される命令 | 期待出力 |
|-------------|--------|------------|----------------|----------|
| TC1 | [] | 0回 | 1, 2 | None |
| TC2 | [5] | 0回 | 1, 3, 4, 7 | 5 |
| TC3 | [3, 8] | 1回 | 1, 3, 4, 5, 6, 7 | 8 |
| TC4 | [8, 3] | 1回 | 1, 3, 4, 5, 7 | 8 |

**命令網羅率**: TC1+TC2+TC3で100%達成（全命令1-7が実行）

### 📝 **演習3: 例外処理を含む分析**

#### **対象コード（JavaScript）**
```javascript
function divide(a, b) {
    try {
        if (b === 0) {                    // 命令1
            throw new Error("ゼロ除算");   // 命令2
        }
        
        const result = a / b;             // 命令3
        return result;                    // 命令4
        
    } catch (error) {
        console.log("エラー:", error.message);  // 命令5
        return null;                      // 命令6
    }
}
```

#### **課題**
1. 正常系と例外系の実行パスを分析してください
2. 100%命令網羅のためのテストケースを設計してください

#### **解答記入欄**

**1. 実行パス分析**
```
正常系: [記入]
例外系: [記入]
```

**2. テストケース設計**
| テストケース | 入力値(a,b) | 実行パス | 実行される命令 | 期待出力 |
|-------------|-------------|----------|----------------|----------|
| TC1 | | 正常系 | | |
| TC2 | | 例外系 | | |

#### **解答例**

**1. 実行パス分析**
```
正常系: 命令1 → [b !== 0] → 命令3 → 命令4 (return)
例外系: 命令1 → [b === 0] → 命令2 (throw) → 命令5 → 命令6 (return)
```

**2. テストケース設計**
| テストケース | 入力値(a,b) | 実行パス | 実行される命令 | 期待出力 |
|-------------|-------------|----------|----------------|----------|
| TC1 | (10, 2) | 正常系 | 1, 3, 4 | 5 |
| TC2 | (10, 0) | 例外系 | 1, 2, 5, 6 | null |

**命令網羅率**: TC1+TC2で100%達成（全命令1-6が実行）

---

## 🔧 プログラミング言語別の考慮事項

### ☕ **Java特有の注意点**

#### **例外処理とfinally**
```java
public void processFile(String filename) {
    FileReader file = null;           // 命令1
    try {
        file = new FileReader(filename);  // 命令2
        // ファイル処理                    // 命令3
    } catch (IOException e) {
        System.out.println("エラー");      // 命令4
    } finally {
        if (file != null) {              // 命令5
            file.close();                // 命令6
        }
    }
}
```

**注意点**：finally句の命令5,6も網羅対象

#### **テストケース**
- TC1: 正常ケース（ファイル存在） → 命令1,2,3,5,6
- TC2: 例外ケース（ファイル不存在） → 命令1,2,4,5
- TC3: ファイルがnullの場合の対応

### 🐍 **Python特有の注意点**

#### **リスト内包表記**
```python
def filter_even(numbers):
    if not numbers:                           # 命令1
        return []                             # 命令2
    
    result = [n for n in numbers if n % 2 == 0]  # 命令3
    return result                             # 命令4
```

**注意点**：リスト内包表記内の条件も実行パスに影響

#### **テストケース**
- TC1: 空リスト → 命令1,2
- TC2: 偶数のみ → 命令1,3,4
- TC3: 奇数のみ → 命令1,3,4
- TC4: 混在 → 命令1,3,4

### 💎 **JavaScript特有の注意点**

#### **非同期処理**
```javascript
async function fetchData(url) {
    try {
        const response = await fetch(url);    // 命令1
        if (!response.ok) {                   // 命令2
            throw new Error('Network error'); // 命令3
        }
        const data = await response.json();   // 命令4
        return data;                          // 命令5
    } catch (error) {
        console.error(error);                 // 命令6
        return null;                          // 命令7
    }
}
```

**注意点**：非同期処理の成功・失敗パスを考慮

---

## 🛠️ カバレッジ測定ツールの活用

### 📊 **実践的なツール使用**

#### **JaCoCo（Java）の基本使用**
```xml
<!-- Maven設定例 -->
<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.7</version>
    <executions>
        <execution>
            <goals>
                <goal>prepare-agent</goal>
            </goals>
        </execution>
        <execution>
            <id>report</id>
            <phase>test</phase>
            <goals>
                <goal>report</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

#### **coverage.py（Python）の基本使用**
```bash
# インストール
pip install coverage

# テスト実行とカバレッジ測定
coverage run -m pytest test_module.py

# レポート表示
coverage report
coverage html
```

#### **Jest（JavaScript）の基本使用**
```json
{
  "scripts": {
    "test": "jest",
    "test:coverage": "jest --coverage"
  },
  "jest": {
    "collectCoverageFrom": [
      "src/**/*.js"
    ]
  }
}
```

### 📈 **カバレッジレポートの読み方**

#### **典型的なレポート例**
```
Name               Stmts   Miss  Cover
--------------------------------------
calculator.py         15      3    80%
validator.py          20      0   100%
utils.py              10      7    30%
--------------------------------------
TOTAL                 45     10    78%
```

**読み方**
- **Stmts**: 総命令数
- **Miss**: 未実行命令数
- **Cover**: 命令網羅率

---

## 📊 この段階の学習成果確認

### ✅ **理解度チェックリスト**

#### **理論理解**
- [ ] 命令網羅の基本原理を説明できる
- [ ] 制御フローグラフを作成できる
- [ ] 実行パスを正確に特定できる

#### **実践スキル**
- [ ] 基本的なコードから必要なテストケースを設計できる
- [ ] カバレッジ率を正確に計算できる
- [ ] 例外処理やループを含むコードも分析できる

### 📝 **学習記録**

#### **習得できたスキル**
```
[記入例]
- 制御フローグラフの作成方法
- テストケース設計の体系的手順
- カバレッジ測定ツールの基本使用方法
```

#### **疑問点・課題**
```
[記入例]
- 複雑なループでの分析方法
- 非同期処理でのカバレッジ測定
- 実務での効率的な適用方法
```

#### **次回重点学習したい内容**
```
[記入例]
- より複雑なコード構造での演習
- 実務レベルでの適用方法
- 他のカバレッジ技法との組み合わせ
```

---

## 🚀 次のステップ

### ✅ **この段階完了の判断基準**
- 基本的な命令網羅分析が実行できる
- 演習問題の80%以上を正解できる
- カバレッジツールの基本操作ができる

### 📖 **次の学習内容**
`03_習得レベル確認.md` で、この段階で学習した内容の定着度を詳細に確認します。

### 🎯 **次回の準備**
- 今回の演習結果を振り返り
- 理解不足の部分を特定
- 客観的な自己評価の準備

**💪 基本スキル習得確認**
命令網羅の基本的な理論と手順を理解し、実際にコード分析を実行できるようになりましたか？

次の段階では、習得したスキルの定着度を客観的に評価し、弱点があれば補強していきます！