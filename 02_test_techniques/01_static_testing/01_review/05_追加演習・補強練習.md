# 🎯 レビュー技法 追加演習・補強練習

## 🔧 理解不足領域の補強

### 📊 技法別集中演習

## 🔍 インスペクション強化演習

### 💡 演習A1: チェックリスト詳細化
**課題**: 以下の分野別に具体的なチェックリストを作成してください

#### 📋 要件定義書用チェックリスト
**機能要件**:
```
□ ________________________________
□ ________________________________
□ ________________________________
□ ________________________________
□ ________________________________
```

**非機能要件**:
```
□ ________________________________
□ ________________________________
□ ________________________________
□ ________________________________
□ ________________________________
```

<details>
<summary>解答例</summary>

**機能要件チェックリスト**:
- □ 各機能の目的・価値が明確に記述されているか
- □ 入力・出力の仕様が具体的に定義されているか
- □ 処理フローが論理的に整合しているか
- □ 例外ケース・エラーケースが網羅されているか
- □ 他システムとの連携仕様が明確か

**非機能要件チェックリスト**:
- □ パフォーマンス要件が定量的に定義されているか
- □ セキュリティ要件が業界標準に準拠しているか
- □ 可用性・信頼性の要件が明確か
- □ ユーザビリティ基準が設定されているか
- □ 保守性・拡張性が考慮されているか
</details>

### 💻 演習A2: インスペクション会議の問題対応

#### 🎯 問題シナリオ
```
インスペクション会議中に以下の問題が発生：
1. 参加者の準備不足（事前レビュー未実施）
2. 議論が感情的になり建設的でない
3. 時間超過により最後まで確認できない
4. 重要な指摘が軽視される
```

**演習課題**: 各問題への対処法を具体的に記述してください

<details>
<summary>解答例</summary>

**対処法**:

**1. 準備不足への対応**:
- 会議開始時に準備状況を確認、不十分な場合は延期
- 準備時間を会議前に設定（30分のサイレントレビュー）
- 準備チェックリストの配布と確認義務化

**2. 感情的議論への対応**:
- 進行役（モデレーター）の明確な設定
- 「事実ベース」「建設的」のルール徹底
- 個人攻撃の即座な制止、議論の方向修正

**3. 時間管理**:
- タイムボックス設定（項目毎に時間制限）
- 重要度による優先順位付け
- 詳細議論が必要な項目は別途セッション設定

**4. 重要指摘の見落とし防止**:
- 指摘事項の重要度分類（Critical/Major/Minor）
- 重要度高い項目の優先議論
- 決定事項の明確な記録と確認
</details>

## 🚶 ウォークスルー強化演習

### 💡 演習B1: 効果的な説明スキル

#### 📋 説明対象
```
システム設計: マイクロサービスアーキテクチャ

サービス構成:
- ユーザー管理サービス
- 商品管理サービス  
- 注文処理サービス
- 決済サービス
- 通知サービス

技術的特徴:
- API Gateway使用
- 非同期メッセージング（RabbitMQ）
- 分散データベース（各サービス独立）
```

**演習課題**: 30分のウォークスルーでの説明プランを作成してください

<details>
<summary>解答例</summary>

**30分説明プラン**:

**導入（5分）**:
- 背景・目的：なぜマイクロサービスを選択したか
- 全体アーキテクチャの俯瞰
- 今日の説明範囲の明確化

**アーキテクチャ説明（15分）**:
- サービス分割の考え方（3分）
- 各サービスの責務と境界（5分）
- サービス間通信の設計（4分）
- データ管理戦略（3分）

**技術的検討事項（7分）**:
- パフォーマンス考慮事項
- 障害対応・監視戦略
- セキュリティ設計

**質疑応答・議論（3分）**:
- 代替案の検討
- 実装上の課題
- 運用面の考慮事項
</details>

### 💻 演習B2: 質問・フィードバックスキル

**演習課題**: 上記アーキテクチャ説明に対する効果的な質問を5つ作成してください

<details>
<summary>解答例</summary>

**効果的な質問例**:
1. **スケーラビリティ**: 「各サービスの負荷増加時のスケールアウト戦略は？」
2. **データ整合性**: 「分散トランザクションが必要な場合の整合性保証方法は？」
3. **障害対応**: 「1つのサービスが停止した場合の他サービスへの影響は？」
4. **運用**: 「デプロイメント戦略と各サービスのバージョン管理は？」
5. **監視**: 「分散環境でのログ収集・トレーシング方法は？」
</details>

## 👥 ピアレビュー強化演習

### 💡 演習C1: 多様なコードパターンレビュー

#### 🔧 パターン1: 例外処理
```java
public class UserService {
    public User getUserById(String userId) {
        if (userId == null || userId.isEmpty()) {
            return null;
        }
        
        User user = userRepository.findById(userId);
        if (user == null) {
            return new User(); // 空のユーザーオブジェクトを返す
        }
        
        return user;
    }
}
```

**レビュー課題**: 例外処理の観点からレビューコメントを作成してください

<details>
<summary>解答例</summary>

**レビューコメント**:
1. **例外処理の一貫性**: nullの代わりに適切な例外をthrowすべき
2. **エラー情報の不足**: ユーザーが見つからない理由が不明
3. **空オブジェクトの問題**: 新しいUserオブジェクト返却は誤解を招く

**改善提案**:
```java
public User getUserById(String userId) {
    if (userId == null || userId.isEmpty()) {
        throw new IllegalArgumentException("User ID cannot be null or empty");
    }
    
    return userRepository.findById(userId)
        .orElseThrow(() -> new UserNotFoundException("User not found: " + userId));
}
```
</details>

#### 🔧 パターン2: 性能問題
```python
def get_user_reports(user_ids):
    reports = []
    for user_id in user_ids:
        user = db.query("SELECT * FROM users WHERE id = %s", user_id)
        orders = db.query("SELECT * FROM orders WHERE user_id = %s", user_id)
        reports.append({
            'user': user,
            'order_count': len(orders),
            'total_amount': sum(order['amount'] for order in orders)
        })
    return reports
```

**レビュー課題**: 性能とデータベース効率の観点からレビューしてください

<details>
<summary>解答例</summary>

**性能上の問題**:
1. **N+1問題**: ユーザー数分のDBクエリが発生
2. **不要なデータ取得**: SELECT *で全カラム取得
3. **メモリ効率**: 大量データ時のメモリ使用量

**改善提案**:
```python
def get_user_reports(user_ids):
    # 一括クエリでN+1問題を解決
    users = db.query("""
        SELECT id, name FROM users 
        WHERE id IN (%s)
    """, user_ids)
    
    orders_summary = db.query("""
        SELECT user_id, COUNT(*) as order_count, SUM(amount) as total_amount
        FROM orders 
        WHERE user_id IN (%s)
        GROUP BY user_id
    """, user_ids)
    
    # メモリ効率的な結合処理
    return merge_user_order_data(users, orders_summary)
```
</details>

### 🔒 演習C2: セキュリティレビュー

#### 🔧 セキュリティリスクコード
```javascript
app.post('/login', (req, res) => {
    const { username, password } = req.body;
    
    const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;
    db.query(query, (err, result) => {
        if (result.length > 0) {
            req.session.user = result[0];
            res.json({ success: true, user: result[0] });
        } else {
            res.json({ success: false, message: 'Invalid credentials' });
        }
    });
});
```

**レビュー課題**: セキュリティリスクを特定し、対策を提案してください

<details>
<summary>解答例</summary>

**セキュリティリスク**:
1. **SQLインジェクション**: 直接的なSQL文字列結合
2. **平文パスワード**: パスワードがハッシュ化されていない
3. **情報漏洩**: ユーザー情報がそのままレスポンスに含まれる
4. **ブルートフォース**: ログイン試行制限なし

**改善提案**:
```javascript
app.post('/login', async (req, res) => {
    const { username, password } = req.body;
    
    // 入力検証
    if (!validateInput(username, password)) {
        return res.status(400).json({ success: false, message: 'Invalid input' });
    }
    
    // パラメータ化クエリでSQLインジェクション対策
    const query = 'SELECT id, username, password_hash FROM users WHERE username = ?';
    
    try {
        const result = await db.query(query, [username]);
        
        if (result.length > 0) {
            // パスワードハッシュ検証
            const isValid = await bcrypt.compare(password, result[0].password_hash);
            
            if (isValid) {
                req.session.user = { 
                    id: result[0].id, 
                    username: result[0].username 
                };
                res.json({ success: true, username: result[0].username });
            } else {
                res.status(401).json({ success: false, message: 'Invalid credentials' });
            }
        } else {
            res.status(401).json({ success: false, message: 'Invalid credentials' });
        }
    } catch (error) {
        logger.error('Login error:', error);
        res.status(500).json({ success: false, message: 'Server error' });
    }
});
```
</details>

## 🔄 パターン別演習集

### 📊 演習パターンA: 設計書レビュー

#### 🎯 対象文書タイプ
- [ ] 要件定義書
- [ ] システム設計書
- [ ] API仕様書
- [ ] DB設計書
- [ ] セキュリティ設計書

**各パターンで10分間のレビュー演習を実施**

### 💻 演習パターンB: コードレビュー

#### 🎯 対象技術スタック
- [ ] JavaScript/TypeScript
- [ ] Python
- [ ] Java/C#
- [ ] SQL
- [ ] HTML/CSS

**各言語で15分間のレビュー演習を実施**

### 🏢 演習パターンC: プロセスレビュー

#### 🎯 対象プロセス
- [ ] 開発プロセス
- [ ] テストプロセス
- [ ] リリースプロセス
- [ ] 運用プロセス
- [ ] セキュリティプロセス

**各プロセスで20分間のレビュー演習を実施**

## 📈 継続的スキル向上

### 🎯 日常練習プラン

#### 📅 週次練習メニュー
**月曜日**: インスペクション（チェックリスト作成）
**火曜日**: ウォークスルー（説明スキル）
**水曜日**: ピアレビュー（コードレビュー）
**木曜日**: 複合演習（技法組み合わせ）
**金曜日**: 振り返り（改善点整理）

#### 📊 進捗管理

**習熟度チェック（月次）**:
```
技法習熟度（5段階評価）:
- インスペクション: □1 □2 □3 □4 □5
- ウォークスルー: □1 □2 □3 □4 □5
- ピアレビュー: □1 □2 □3 □4 □5

スキル習熟度（5段階評価）:
- チェックリスト作成: □1 □2 □3 □4 □5
- 会議進行: □1 □2 □3 □4 □5
- フィードバック: □1 □2 □3 □4 □5
- 問題解決: □1 □2 □3 □4 □5
```

### 🚀 実践機会の創出

#### 💡 実践アイデア
1. **社内勉強会**: チーム内でのレビュー技法共有
2. **レビュー会議**: 実際のプロジェクトでの実践
3. **メンタリング**: 後輩への技法指導
4. **プロセス改善**: 組織のレビュープロセス改善提案

#### 📋 実践記録テンプレート
```
実践日: ___________
技法: ___________  
対象: ___________
参加者: ___________
時間: ___________
成果: ___________
改善点: ___________
次回への改善: ___________
```

---
*継続的な練習により、レビュー技法は確実に身につき、プロジェクトでの価値創出につながります*