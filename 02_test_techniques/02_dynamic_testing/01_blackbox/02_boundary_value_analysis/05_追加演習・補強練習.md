# 🔧 境界値分析 追加演習・補強練習

## 📚 この段階の目的

**さまざまなパターンで境界値分析を練習し、スキルを安定化させる**
- [ ] 多様なデータ型での境界値を扱える
- [ ] 特殊なケースにも対応できる
- [ ] 素早く正確に境界値を特定できる

**⏰ 推奨時間**: 約60分

---

## 🎯 補強練習の方針

```
基本演習との違い:
✅ より多様なパターン
✅ 特殊なケース・例外処理
✅ 実務で遭遇しやすい事例
✅ スピード重視の演習
```

**すぐに演習を開始しましょう！ 🚀**

---

## 🎯 演習1: 日時の境界値【難易度: ★★☆】

### 📝 課題
```
イベント予約システム
- 予約可能期間: 本日から90日後まで
- 予約時間: 営業時間 9:00-21:00（1時間単位）
- 休業日: 毎週月曜日は予約不可
```

### 課題
**Q1. 日付の境界値を特定してください**
```
開始日境界: [                    ]
終了日境界: [                    ]
```

**Q2. 時間の境界値を特定してください**
```
開始時刻境界: [                ]
終了時刻境界: [                ]
```

**Q3. PHPUnitで実装してください**

```php
class ReservationValidator
{
    // [実装]
}

class ReservationValidatorTest extends TestCase
{
    // [テスト実装]
}
```

<details>
<summary>💡 解答</summary>

```php
class ReservationValidator
{
    public function canReserve(\DateTime $date, int $hour): array
    {
        $today = new \DateTime('today');
        $maxDate = (clone $today)->modify('+90 days');
        
        // 日付チェック
        if ($date < $today) {
            return ['valid' => false, 'reason' => '過去の日付は予約できません'];
        }
        
        if ($date > $maxDate) {
            return ['valid' => false, 'reason' => '90日以降は予約できません'];
        }
        
        // 月曜日チェック
        if ($date->format('w') == 1) {
            return ['valid' => false, 'reason' => '月曜日は休業日です'];
        }
        
        // 時間チェック
        if ($hour < 9 || $hour > 21) {
            return ['valid' => false, 'reason' => '営業時間外です'];
        }
        
        return ['valid' => true, 'reason' => ''];
    }
}

class ReservationValidatorTest extends TestCase
{
    private ReservationValidator $validator;

    protected function setUp(): void
    {
        $this->validator = new ReservationValidator();
    }

    /** @test 日付境界値 - 開始 */
    public function 昨日_予約不可()
    {
        $yesterday = new \DateTime('yesterday');
        $result = $this->validator->canReserve($yesterday, 10);
        $this->assertFalse($result['valid']);
    }

    /** @test */
    public function 今日_予約可能()
    {
        $today = new \DateTime('today');
        // 月曜日でない日にちを選択
        while ($today->format('w') == 1) {
            $today->modify('+1 day');
        }
        $result = $this->validator->canReserve($today, 10);
        $this->assertTrue($result['valid']);
    }

    /** @test 日付境界値 - 終了 */
    public function 90日後_予約可能()
    {
        $date = new \DateTime('+90 days');
        while ($date->format('w') == 1) {
            $date->modify('+1 day');
        }
        $result = $this->validator->canReserve($date, 10);
        $this->assertTrue($result['valid']);
    }

    /** @test */
    public function 91日後_予約不可()
    {
        $date = new \DateTime('+91 days');
        $result = $this->validator->canReserve($date, 10);
        $this->assertFalse($result['valid']);
    }

    /** @test 時間境界値 */
    public function 8時_営業時間外()
    {
        $date = new \DateTime('+1 day');
        while ($date->format('w') == 1) {
            $date->modify('+1 day');
        }
        $result = $this->validator->canReserve($date, 8);
        $this->assertFalse($result['valid']);
    }

    /** @test */
    public function 9時_予約可能()
    {
        $date = new \DateTime('+1 day');
        while ($date->format('w') == 1) {
            $date->modify('+1 day');
        }
        $result = $this->validator->canReserve($date, 9);
        $this->assertTrue($result['valid']);
    }

    /** @test */
    public function 21時_予約可能()
    {
        $date = new \DateTime('+1 day');
        while ($date->format('w') == 1) {
            $date->modify('+1 day');
        }
        $result = $this->validator->canReserve($date, 21);
        $this->assertTrue($result['valid']);
    }

    /** @test */
    public function 22時_営業時間外()
    {
        $date = new \DateTime('+1 day');
        while ($date->format('w') == 1) {
            $date->modify('+1 day');
        }
        $result = $this->validator->canReserve($date, 22);
        $this->assertFalse($result['valid']);
    }

    /** @test 月曜日チェック */
    public function 月曜日_予約不可()
    {
        $date = new \DateTime('next Monday');
        $result = $this->validator->canReserve($date, 10);
        $this->assertFalse($result['valid']);
        $this->assertStringContainsString('月曜日', $result['reason']);
    }
}
```
</details>

---

## 🎯 演習2: 配列・コレクションの境界値【難易度: ★★☆】

### 📝 課題
```
タグ管理システム
- 最小タグ数: 1個
- 最大タグ数: 10個
- タグ文字数: 1-20文字
- 重複タグ: 不可
```

### 課題
**完全な実装を書いてください**

<details>
<summary>💡 解答例</summary>

```php
class TagValidator
{
    private const MIN_TAGS = 1;
    private const MAX_TAGS = 10;
    private const MIN_TAG_LENGTH = 1;
    private const MAX_TAG_LENGTH = 20;

    public function validate(array $tags): array
    {
        // 個数チェック
        if (count($tags) < self::MIN_TAGS) {
            return ['valid' => false, 'reason' => 'タグは最低1個必要です'];
        }
        
        if (count($tags) > self::MAX_TAGS) {
            return ['valid' => false, 'reason' => 'タグは最大10個までです'];
        }
        
        // 重複チェック
        if (count($tags) !== count(array_unique($tags))) {
            return ['valid' => false, 'reason' => 'タグが重複しています'];
        }
        
        // 各タグの文字数チェック
        foreach ($tags as $tag) {
            $length = mb_strlen($tag);
            if ($length < self::MIN_TAG_LENGTH || $length > self::MAX_TAG_LENGTH) {
                return ['valid' => false, 'reason' => 'タグは1-20文字である必要があります'];
            }
        }
        
        return ['valid' => true, 'reason' => ''];
    }
}

class TagValidatorTest extends TestCase
{
    private TagValidator $validator;

    protected function setUp(): void
    {
        $this->validator = new TagValidator();
    }

    /** @test タグ個数境界値 */
    public function タグ0個_無効()
    {
        $result = $this->validator->validate([]);
        $this->assertFalse($result['valid']);
    }

    /** @test */
    public function タグ1個_有効()
    {
        $result = $this->validator->validate(['tag1']);
        $this->assertTrue($result['valid']);
    }

    /** @test */
    public function タグ10個_有効()
    {
        $tags = array_map(fn($i) => "tag$i", range(1, 10));
        $result = $this->validator->validate($tags);
        $this->assertTrue($result['valid']);
    }

    /** @test */
    public function タグ11個_無効()
    {
        $tags = array_map(fn($i) => "tag$i", range(1, 11));
        $result = $this->validator->validate($tags);
        $this->assertFalse($result['valid']);
    }

    /** @test タグ文字数境界値 */
    public function タグ0文字_無効()
    {
        $result = $this->validator->validate(['']);
        $this->assertFalse($result['valid']);
    }

    /** @test */
    public function タグ1文字_有効()
    {
        $result = $this->validator->validate(['a']);
        $this->assertTrue($result['valid']);
    }

    /** @test */
    public function タグ20文字_有効()
    {
        $tag = str_repeat('a', 20);
        $result = $this->validator->validate([$tag]);
        $this->assertTrue($result['valid']);
    }

    /** @test */
    public function タグ21文字_無効()
    {
        $tag = str_repeat('a', 21);
        $result = $this->validator->validate([$tag]);
        $this->assertFalse($result['valid']);
    }

    /** @test 重複チェック */
    public function タグ重複_無効()
    {
        $result = $this->validator->validate(['tag1', 'tag2', 'tag1']);
        $this->assertFalse($result['valid']);
        $this->assertStringContainsString('重複', $result['reason']);
    }

    /** @test */
    public function タグ重複なし_有効()
    {
        $result = $this->validator->validate(['tag1', 'tag2', 'tag3']);
        $this->assertTrue($result['valid']);
    }

    /** @test 境界の組み合わせ */
    public function 10個で各20文字_有効()
    {
        $tags = array_map(fn($i) => str_repeat('a', 20), range(1, 10));
        // 重複を避けるために各タグを微妙に変える
        $tags = array_map(fn($i) => str_repeat('a', 19) . $i, range(1, 10));
        $result = $this->validator->validate($tags);
        $this->assertTrue($result['valid']);
    }
}
```
</details>

---

## 🎯 演習3: 金額計算の境界値【難易度: ★★★】

### 📝 課題
```
割引計算システム
- 購入金額: 1円以上1,000,000円以下
- 5,000円以上で100円割引
- 10,000円以上で500円割引
- 50,000円以上で3,000円割引
- 100,000円以上で10,000円割引
- 消費税: 10%（小数点切り捨て）
```

### 課題
**完全な実装を書いてください**

<details>
<summary>💡 解答例</summary>

```php
class PriceCalculator
{
    private const MIN_PRICE = 1;
    private const MAX_PRICE = 1000000;
    private const TAX_RATE = 0.10;

    private const DISCOUNTS = [
        100000 => 10000,
        50000 => 3000,
        10000 => 500,
        5000 => 100,
    ];

    public function calculate(int $price): array
    {
        if ($price < self::MIN_PRICE || $price > self::MAX_PRICE) {
            throw new InvalidArgumentException('価格は1円以上1,000,000円以下である必要があります');
        }

        $discount = $this->getDiscount($price);
        $priceAfterDiscount = $price - $discount;
        $tax = (int) ($priceAfterDiscount * self::TAX_RATE);
        $total = $priceAfterDiscount + $tax;

        return [
            'original_price' => $price,
            'discount' => $discount,
            'price_after_discount' => $priceAfterDiscount,
            'tax' => $tax,
            'total' => $total,
        ];
    }

    private function getDiscount(int $price): int
    {
        foreach (self::DISCOUNTS as $threshold => $discount) {
            if ($price >= $threshold) {
                return $discount;
            }
        }
        return 0;
    }
}

class PriceCalculatorTest extends TestCase
{
    private PriceCalculator $calculator;

    protected function setUp(): void
    {
        $this->calculator = new PriceCalculator();
    }

    /** @test 価格範囲境界値 */
    public function 0円_例外()
    {
        $this->expectException(InvalidArgumentException::class);
        $this->calculator->calculate(0);
    }

    /** @test */
    public function 1円_計算成功()
    {
        $result = $this->calculator->calculate(1);
        $this->assertEquals(1, $result['total']);
    }

    /** @test */
    public function 1000000円_計算成功()
    {
        $result = $this->calculator->calculate(1000000);
        $this->assertArrayHasKey('total', $result);
    }

    /** @test */
    public function 1000001円_例外()
    {
        $this->expectException(InvalidArgumentException::class);
        $this->calculator->calculate(1000001);
    }

    /** @test 割引境界値 - 100円割引 */
    public function 4999円_割引なし()
    {
        $result = $this->calculator->calculate(4999);
        $this->assertEquals(0, $result['discount']);
        $this->assertEquals(4999, $result['price_after_discount']);
    }

    /** @test */
    public function 5000円_100円割引()
    {
        $result = $this->calculator->calculate(5000);
        $this->assertEquals(100, $result['discount']);
        $this->assertEquals(4900, $result['price_after_discount']);
    }

    /** @test 割引境界値 - 500円割引 */
    public function 9999円_100円割引()
    {
        $result = $this->calculator->calculate(9999);
        $this->assertEquals(100, $result['discount']);
    }

    /** @test */
    public function 10000円_500円割引()
    {
        $result = $this->calculator->calculate(10000);
        $this->assertEquals(500, $result['discount']);
        $this->assertEquals(9500, $result['price_after_discount']);
    }

    /** @test 割引境界値 - 3000円割引 */
    public function 49999円_500円割引()
    {
        $result = $this->calculator->calculate(49999);
        $this->assertEquals(500, $result['discount']);
    }

    /** @test */
    public function 50000円_3000円割引()
    {
        $result = $this->calculator->calculate(50000);
        $this->assertEquals(3000, $result['discount']);
        $this->assertEquals(47000, $result['price_after_discount']);
    }

    /** @test 割引境界値 - 10000円割引 */
    public function 99999円_3000円割引()
    {
        $result = $this->calculator->calculate(99999);
        $this->assertEquals(3000, $result['discount']);
    }

    /** @test */
    public function 100000円_10000円割引()
    {
        $result = $this->calculator->calculate(100000);
        $this->assertEquals(10000, $result['discount']);
        $this->assertEquals(90000, $result['price_after_discount']);
    }

    /** @test 消費税計算 */
    public function 消費税の切り捨て確認()
    {
        // 4999円の場合、割引なし、税 = 499.9 → 499円
        $result = $this->calculator->calculate(4999);
        $this->assertEquals(499, $result['tax']);
        $this->assertEquals(5498, $result['total']); // 4999 + 499
    }
}
```
</details>

---

## 🎯 演習4: エラーハンドリングの境界値【難易度: ★★★】

### 📝 課題
```
ログイン試行制限
- 連続失敗: 5回まで許可
- 6回目で30分ロック
- ロック中の試行: エラーメッセージ表示
- 30分経過後: カウントリセット
```

### 課題
**完全な実装を書いてください**

<details>
<summary>💡 解答例</summary>

```php
class LoginAttemptManager
{
    private const MAX_ATTEMPTS = 5;
    private const LOCK_DURATION_MINUTES = 30;

    private array $attempts = [];
    private array $lockUntil = [];

    public function canAttempt(string $userId): array
    {
        // ロック確認
        if (isset($this->lockUntil[$userId])) {
            $lockUntil = $this->lockUntil[$userId];
            if ($lockUntil > time()) {
                $remainingMinutes = ceil(($lockUntil - time()) / 60);
                return [
                    'can_attempt' => false,
                    'reason' => "アカウントがロックされています。残り{$remainingMinutes}分",
                ];
            }
            // ロック期限切れ
            unset($this->lockUntil[$userId]);
            $this->attempts[$userId] = 0;
        }

        $attempts = $this->attempts[$userId] ?? 0;
        
        if ($attempts >= self::MAX_ATTEMPTS) {
            return [
                'can_attempt' => false,
                'reason' => '試行回数の上限に達しました',
            ];
        }

        return [
            'can_attempt' => true,
            'remaining_attempts' => self::MAX_ATTEMPTS - $attempts,
        ];
    }

    public function recordFailure(string $userId): void
    {
        $this->attempts[$userId] = ($this->attempts[$userId] ?? 0) + 1;

        if ($this->attempts[$userId] >= self::MAX_ATTEMPTS) {
            $this->lockUntil[$userId] = time() + (self::LOCK_DURATION_MINUTES * 60);
        }
    }

    public function recordSuccess(string $userId): void
    {
        unset($this->attempts[$userId]);
        unset($this->lockUntil[$userId]);
    }
}

class LoginAttemptManagerTest extends TestCase
{
    private LoginAttemptManager $manager;

    protected function setUp(): void
    {
        $this->manager = new LoginAttemptManager();
    }

    /** @test 試行回数境界値 */
    public function 初回試行_許可()
    {
        $result = $this->manager->canAttempt('user1');
        $this->assertTrue($result['can_attempt']);
        $this->assertEquals(5, $result['remaining_attempts']);
    }

    /** @test */
    public function 4回失敗後_5回目許可()
    {
        for ($i = 0; $i < 4; $i++) {
            $this->manager->recordFailure('user1');
        }

        $result = $this->manager->canAttempt('user1');
        $this->assertTrue($result['can_attempt']);
        $this->assertEquals(1, $result['remaining_attempts']);
    }

    /** @test */
    public function 5回失敗後_6回目拒否()
    {
        for ($i = 0; $i < 5; $i++) {
            $this->manager->recordFailure('user1');
        }

        $result = $this->manager->canAttempt('user1');
        $this->assertFalse($result['can_attempt']);
    }

    /** @test */
    public function 6回目試行_ロックメッセージ表示()
    {
        for ($i = 0; $i < 5; $i++) {
            $this->manager->recordFailure('user1');
        }
        $this->manager->recordFailure('user1'); // 6回目でロック

        $result = $this->manager->canAttempt('user1');
        $this->assertFalse($result['can_attempt']);
        $this->assertStringContainsString('ロック', $result['reason']);
    }

    /** @test ロック時間境界値 */
    public function ロック29分59秒後_まだロック中()
    {
        // モックなしの簡易テスト
        // 実際のプロジェクトではCarbon等を使用してテスト可能に
        $this->markTestSkipped('時間経過のテストにはモックが必要');
    }

    /** @test */
    public function 成功後_カウントリセット()
    {
        for ($i = 0; $i < 4; $i++) {
            $this->manager->recordFailure('user1');
        }

        $this->manager->recordSuccess('user1');

        $result = $this->manager->canAttempt('user1');
        $this->assertTrue($result['can_attempt']);
        $this->assertEquals(5, $result['remaining_attempts']);
    }

    /** @test 複数ユーザーの独立性 */
    public function 複数ユーザーの試行は独立()
    {
        for ($i = 0; $i < 5; $i++) {
            $this->manager->recordFailure('user1');
        }

        $result = $this->manager->canAttempt('user2');
        $this->assertTrue($result['can_attempt']);
        $this->assertEquals(5, $result['remaining_attempts']);
    }
}
```
</details>

---

## 🎯 演習5: 特殊文字・Unicode の境界値【難易度: ★★★】

### 📝 課題
```
ユーザー名バリデーション
- 長さ: 3-20文字
- 使用可能: 英数字、日本語、一部記号（_-.）
- 禁止: スペース、特殊記号、絵文字
- Unicodeサロゲートペア考慮
```

### 課題
**完全な実装を書いてください**

<details>
<summary>💡 解答例</summary>

```php
class UsernameValidator
{
    private const MIN_LENGTH = 3;
    private const MAX_LENGTH = 20;

    public function validate(string $username): array
    {
        // 長さチェック（マルチバイト対応）
        $length = mb_strlen($username);
        if ($length < self::MIN_LENGTH) {
            return ['valid' => false, 'reason' => '3文字以上必要です'];
        }

        if ($length > self::MAX_LENGTH) {
            return ['valid' => false, 'reason' => '20文字以下である必要があります'];
        }

        // 使用可能文字チェック
        // 英数字、日本語（ひらがな、カタカナ、漢字）、記号（_-.）
        if (!preg_match('/^[a-zA-Z0-9\p{Hiragana}\p{Katakana}\p{Han}_\-.]+$/u', $username)) {
            return ['valid' => false, 'reason' => '使用できない文字が含まれています'];
        }

        // 絵文字チェック（簡易版）
        if (preg_match('/[\x{1F600}-\x{1F64F}]/u', $username)) {
            return ['valid' => false, 'reason' => '絵文字は使用できません'];
        }

        return ['valid' => true, 'reason' => ''];
    }
}

class UsernameValidatorTest extends TestCase
{
    private UsernameValidator $validator;

    protected function setUp(): void
    {
        $this->validator = new UsernameValidator();
    }

    /** @test 文字数境界値 - 半角 */
    public function 半角2文字_無効()
    {
        $result = $this->validator->validate('ab');
        $this->assertFalse($result['valid']);
    }

    /** @test */
    public function 半角3文字_有効()
    {
        $result = $this->validator->validate('abc');
        $this->assertTrue($result['valid']);
    }

    /** @test */
    public function 半角20文字_有効()
    {
        $result = $this->validator->validate(str_repeat('a', 20));
        $this->assertTrue($result['valid']);
    }

    /** @test */
    public function 半角21文字_無効()
    {
        $result = $this->validator->validate(str_repeat('a', 21));
        $this->assertFalse($result['valid']);
    }

    /** @test 文字数境界値 - 全角 */
    public function 全角2文字_無効()
    {
        $result = $this->validator->validate('あい');
        $this->assertFalse($result['valid']);
    }

    /** @test */
    public function 全角3文字_有効()
    {
        $result = $this->validator->validate('あいう');
        $this->assertTrue($result['valid']);
    }

    /** @test */
    public function 全角20文字_有効()
    {
        $result = $this->validator->validate(str_repeat('あ', 20));
        $this->assertTrue($result['valid']);
    }

    /** @test */
    public function 全角21文字_無効()
    {
        $result = $this->validator->validate(str_repeat('あ', 21));
        $this->assertFalse($result['valid']);
    }

    /** @test 使用可能文字 */
    public function 英数字とアンダースコア_有効()
    {
        $result = $this->validator->validate('user_123');
        $this->assertTrue($result['valid']);
    }

    /** @test */
    public function ひらがな_有効()
    {
        $result = $this->validator->validate('ゆーざー');
        $this->assertTrue($result['valid']);
    }

    /** @test */
    public function カタカナ_有効()
    {
        $result = $this->validator->validate('ユーザー');
        $this->assertTrue($result['valid']);
    }

    /** @test */
    public function 漢字_有効()
    {
        $result = $this->validator->validate('利用者');
        $this->assertTrue($result['valid']);
    }

    /** @test */
    public function 混在_有効()
    {
        $result = $this->validator->validate('user太郎_123');
        $this->assertTrue($result['valid']);
    }

    /** @test 禁止文字 */
    public function スペース_無効()
    {
        $result = $this->validator->validate('user name');
        $this->assertFalse($result['valid']);
    }

    /** @test */
    public function 記号アットマーク_無効()
    {
        $result = $this->validator->validate('user@name');
        $this->assertFalse($result['valid']);
    }

    /** @test */
    public function 絵文字_無効()
    {
        $result = $this->validator->validate('user😀');
        $this->assertFalse($result['valid']);
    }

    /** @test 許可記号 */
    public function ハイフン_有効()
    {
        $result = $this->validator->validate('user-name');
        $this->assertTrue($result['valid']);
    }

    /** @test */
    public function ドット_有効()
    {
        $result = $this->validator->validate('user.name');
        $this->assertTrue($result['valid']);
    }

    /** @test */
    public function アンダースコア_有効()
    {
        $result = $this->validator->validate('user_name');
        $this->assertTrue($result['valid']);
    }
}
```
</details>

---

## 📊 学習成果の確認

### ✅ **補強練習チェックリスト**

- [ ] 日時の境界値を扱えた（演習1）
- [ ] 配列・コレクションの境界値を扱えた（演習2）
- [ ] 金額計算の境界値を扱えた（演習3）
- [ ] エラーハンドリングの境界値を扱えた（演習4）
- [ ] 特殊文字・Unicodeの境界値を扱えた（演習5）

### 📝 **振り返り**

**得意になったパターン**
```
例:
- 日時計算
- 配列サイズ
- 金額・割引計算
```

**もう少し練習したいパターン**
```
例:
- Unicode対応
- エラーハンドリング
- 複雑な条件の組み合わせ
```

**実務で注意すること**
```
例:
- マルチバイト文字の扱い
- 日付の境界（月末、うるう年）
- 小数点の丸め処理
```

---

## 🚀 次のステップ

**到達基準**:
- 演習5問中4問以上実装完了
- さまざまなパターンに対応できる自信

**次は**: `06_実務適用ガイド.md` で実践的な活用方法

**💪 多様なパターンを習得！実務での応用準備完了 🎉**