# 🚀 分岐網羅（Branch Coverage）- 上級演習・実務レベル

## 🎯 上級演習の目的
- 複雑な実務コードでの分岐網羅適用
- パフォーマンスを考慮した効率的なテスト設計
- 実際のプロジェクトシナリオでの問題解決

---

## 💪 上級演習 1：複雑な業務ロジック

### 📝 問題：保険料計算システム
以下の保険料計算メソッドで**100%分岐網羅**を達成し、かつ**実務で有効**なテストケースを設計してください。

```java
public class InsurancePremiumCalculator {
    
    public PremiumResult calculatePremium(Customer customer, Policy policy) {
        // 入力検証
        if (customer == null || policy == null) {
            return new PremiumResult(0, "Invalid input", false);
        }
        
        if (customer.getAge() < 18 || customer.getAge() > 100) {
            return new PremiumResult(0, "Age out of range", false);
        }
        
        // 基本保険料計算
        double basePremium = policy.getBasePremium();
        double finalPremium = basePremium;
        
        // 年齢による係数
        if (customer.getAge() >= 65) {
            finalPremium *= 1.5;  // 高齢者割増
        } else if (customer.getAge() >= 40) {
            finalPremium *= 1.2;  // 中年割増
        } else if (customer.getAge() >= 25) {
            finalPremium *= 1.0;  // 標準
        } else {
            finalPremium *= 0.8;  // 若年者割引
        }
        
        // リスク要因チェック
        boolean hasRiskFactors = false;
        if (customer.isSmoker()) {
            finalPremium *= 1.3;
            hasRiskFactors = true;
        }
        
        if (customer.hasChronicDisease()) {
            finalPremium *= 1.4;
            hasRiskFactors = true;
        }
        
        // 職業リスク
        if (customer.getOccupation() != null) {
            String occupation = customer.getOccupation().toLowerCase();
            if (occupation.contains("pilot") || occupation.contains("mining")) {
                finalPremium *= 2.0;
                hasRiskFactors = true;
            } else if (occupation.contains("construction") || occupation.contains("firefighter")) {
                finalPremium *= 1.6;
                hasRiskFactors = true;
            }
        }
        
        // 保険期間による調整
        int years = policy.getTermYears();
        if (years >= 30) {
            finalPremium *= 0.9;  // 長期割引
        } else if (years >= 20) {
            finalPremium *= 0.95; // 中期割引
        }
        // 短期（20年未満）は割引なし
        
        // 家族割引
        if (customer.getFamilySize() >= 4) {
            finalPremium *= 0.9;
        } else if (customer.getFamilySize() >= 2) {
            finalPremium *= 0.95;
        }
        
        // 健康ボーナス（リスク要因がない場合）
        if (!hasRiskFactors && customer.hasHealthCertificate()) {
            finalPremium *= 0.85;
        }
        
        // 最低保険料チェック
        double minimumPremium = 1000.0;
        if (finalPremium < minimumPremium) {
            finalPremium = minimumPremium;
        }
        
        return new PremiumResult(finalPremium, "Calculation completed", true);
    }
}
```

### 🤔 分析ステップ

#### ステップ1: 分岐の系統的特定
```java
// 入力検証分岐
if (customer == null || policy == null)           // 分岐1: T/F
if (customer.getAge() < 18 || customer.getAge() > 100)  // 分岐2: T/F

// 年齢分岐（排他的）
if (customer.getAge() >= 65)                      // 分岐3: T/F
else if (customer.getAge() >= 40)                 // 分岐4: T/F
else if (customer.getAge() >= 25)                 // 分岐5: T/F
else                                              // 分岐6: 自動実行

// リスク要因分岐
if (customer.isSmoker())                          // 分岐7: T/F
if (customer.hasChronicDisease())                 // 分岐8: T/F

// 職業分岐
if (customer.getOccupation() != null)             // 分岐9: T/F
  if (occupation.contains("pilot") || occupation.contains("mining"))  // 分岐10: T/F
  else if (occupation.contains("construction") || occupation.contains("firefighter"))  // 分岐11: T/F

// 期間分岐
if (years >= 30)                                  // 分岐12: T/F
else if (years >= 20)                             // 分岐13: T/F

// 家族分岐
if (customer.getFamilySize() >= 4)                // 分岐14: T/F
else if (customer.getFamilySize() >= 2)           // 分岐15: T/F

// 健康ボーナス分岐
if (!hasRiskFactors && customer.hasHealthCertificate())  // 分岐16: T/F

// 最低保険料分岐
if (finalPremium < minimumPremium)                // 分岐17: T/F
```

**総分岐数**: 34分岐（17箇所 × 2（T/F））

#### ステップ2: 実務を考慮したテストケース設計

### ✅ 解答：実務レベルのテストケース

```java
@Test
public void testCalculatePremium_ComprehensiveBranchCoverage() {
    InsurancePremiumCalculator calculator = new InsurancePremiumCalculator();
    
    // === 入力検証テスト ===
    
    // TC1: null入力（分岐1-True）
    PremiumResult result1 = calculator.calculatePremium(null, policy);
    assertFalse(result1.isSuccess());
    assertEquals("Invalid input", result1.getMessage());
    
    // TC2: 年齢範囲外（分岐2-True）
    Customer underageCustomer = createCustomer(17, false, false, "office", 2, false);
    PremiumResult result2 = calculator.calculatePremium(underageCustomer, policy);
    assertFalse(result2.isSuccess());
    assertEquals("Age out of range", result2.getMessage());
    
    // === 年齢層別テスト ===
    
    // TC3: 高齢者（65歳以上）- 分岐3-True, 他リスクなし
    Customer elderly = createCustomer(70, false, false, "teacher", 1, true);
    PremiumResult result3 = calculator.calculatePremium(elderly, longTermPolicy);
    assertTrue(result3.isSuccess());
    double expectedElderly = 10000 * 1.5 * 0.9 * 0.85; // 基本*高齢*長期*健康
    assertEquals(expectedElderly, result3.getPremium(), 0.01);
    
    // TC4: 中年（40-64歳）- 分岐4-True, リスク職業
    Customer middleAge = createCustomer(45, true, false, "pilot", 4, false);
    PremiumResult result4 = calculator.calculatePremium(middleAge, mediumTermPolicy);
    assertTrue(result4.isSuccess());
    double expectedMiddle = 10000 * 1.2 * 1.3 * 2.0 * 0.95 * 0.9; // 基本*中年*喫煙*危険職業*中期*家族
    assertEquals(expectedMiddle, result4.getPremium(), 0.01);
    
    // TC5: 若年成人（25-39歳）- 分岐5-True, 標準ケース
    Customer youngAdult = createCustomer(30, false, false, "engineer", 2, false);
    PremiumResult result5 = calculator.calculatePremium(youngAdult, shortTermPolicy);
    assertTrue(result5.isSuccess());
    double expectedYoung = 10000 * 1.0 * 0.95; // 基本*標準*家族2人
    assertEquals(expectedYoung, result5.getPremium(), 0.01);
    
    // TC6: 若年者（18-24歳）- 分岐6実行, 最低保険料適用
    Customer youth = createCustomer(20, false, false, null, 1, true);
    PremiumResult result6 = calculator.calculatePremium(youth, shortTermPolicy);
    assertTrue(result6.isSuccess());
    double expectedYouth = Math.max(10000 * 0.8 * 0.85, 1000); // 最低保険料適用
    assertEquals(1000.0, result6.getPremium(), 0.01); // 最低保険料
    
    // === リスク要因組み合わせテスト ===
    
    // TC7: 全リスク要因（分岐7-T, 8-T, 10-T）
    Customer highRisk = createCustomer(35, true, true, "mining engineer", 1, false);
    PremiumResult result7 = calculator.calculatePremium(highRisk, longTermPolicy);
    assertTrue(result7.isSuccess());
    double expectedHighRisk = 10000 * 1.0 * 1.3 * 1.4 * 2.0 * 0.9; // 全リスク要因
    assertEquals(expectedHighRisk, result7.getPremium(), 0.01);
    
    // TC8: 中リスク職業（分岐11-True）
    Customer mediumRisk = createCustomer(35, false, false, "construction worker", 3, false);
    PremiumResult result8 = calculator.calculatePremium(mediumRisk, mediumTermPolicy);
    assertTrue(result8.isSuccess());
    double expectedMediumRisk = 10000 * 1.0 * 1.6 * 0.95; // 中リスク職業
    assertEquals(expectedMediumRisk, result8.getPremium(), 0.01);
    
    // TC9: 職業null（分岐9-False）
    Customer noOccupation = createCustomer(35, false, false, null, 2, false);
    PremiumResult result9 = calculator.calculatePremium(noOccupation, shortTermPolicy);
    assertTrue(result9.isSuccess());
    double expectedNoOccupation = 10000 * 1.0 * 0.95; // 職業リスクなし
    assertEquals(expectedNoOccupation, result9.getPremium(), 0.01);
    
    // === 境界値・エッジケーステスト ===
    
    // TC10: 年齢境界値（25歳ちょうど）
    Customer boundary25 = createCustomer(25, false, false, "office", 1, false);
    PremiumResult result10 = calculator.calculatePremium(boundary25, shortTermPolicy);
    double expected25 = 10000 * 1.0; // 標準レート適用
    assertEquals(expected25, result10.getPremium(), 0.01);
    
    // TC11: 期間境界値（30年ちょうど）
    Policy boundary30Year = createPolicy(10000, 30);
    Customer standard = createCustomer(35, false, false, "office", 1, false);
    PremiumResult result11 = calculator.calculatePremium(standard, boundary30Year);
    double expected30Year = 10000 * 1.0 * 0.9; // 長期割引
    assertEquals(expected30Year, result11.getPremium(), 0.01);
}

// ヘルパーメソッド
private Customer createCustomer(int age, boolean smoker, boolean chronicDisease, 
                               String occupation, int familySize, boolean healthCert) {
    Customer customer = new Customer();
    customer.setAge(age);
    customer.setSmoker(smoker);
    customer.setChronicDisease(chronicDisease);
    customer.setOccupation(occupation);
    customer.setFamilySize(familySize);
    customer.setHealthCertificate(healthCert);
    return customer;
}

private Policy createPolicy(double basePremium, int termYears) {
    Policy policy = new Policy();
    policy.setBasePremium(basePremium);
    policy.setTermYears(termYears);
    return policy;
}
```

### 📊 実務価値の高いテスト設計のポイント

#### 💡 1. ビジネスロジックの検証
- **年齢層別テスト**: 実際の保険業界の年齢区分に基づく
- **リスク要因の組み合わせ**: 現実的なリスク評価シナリオ
- **職業リスクの段階的テスト**: 高/中/低リスクの代表的職業

#### 💡 2. 境界値の重点テスト
- **年齢境界**: 18歳、25歳、40歳、65歳、100歳
- **期間境界**: 20年、30年
- **家族サイズ境界**: 2人、4人

#### 💡 3. 計算精度の検証
- **複雑な係数計算**: 複数の割増・割引の組み合わせ
- **最低保険料の適用**: 計算結果が最低額を下回る場合
- **小数点計算の精度**: 浮動小数点の丸め誤差対策

---

## 💪 上級演習 2：異常系とエラーハンドリング

### 📝 問題：ファイル処理システム
以下のファイル処理メソッドで分岐網羅を達成し、異常系を含む堅牢なテストを設計してください。

```java
public class FileProcessingService {
    
    public ProcessingResult processDataFile(String filePath, ProcessingOptions options) {
        ProcessingResult result = new ProcessingResult();
        
        // 入力検証
        if (filePath == null || filePath.trim().isEmpty()) {
            result.setSuccess(false);
            result.setMessage("File path is required");
            return result;
        }
        
        if (options == null) {
            options = new ProcessingOptions(); // デフォルト設定
        }
        
        File file = new File(filePath);
        
        // ファイル存在チェック
        if (!file.exists()) {
            result.setSuccess(false);
            result.setMessage("File not found: " + filePath);
            return result;
        }
        
        // ファイルサイズチェック
        long fileSize = file.length();
        if (fileSize == 0) {
            result.setSuccess(false);
            result.setMessage("File is empty");
            return result;
        }
        
        // サイズ制限チェック
        long maxSize = options.getMaxFileSize();
        if (maxSize > 0 && fileSize > maxSize) {
            if (options.isAllowLargeFiles()) {
                // 大きなファイルの警告
                result.addWarning("Large file detected: " + fileSize + " bytes");
            } else {
                result.setSuccess(false);
                result.setMessage("File too large: " + fileSize + " bytes");
                return result;
            }
        }
        
        // ファイル形式チェック
        String fileName = file.getName().toLowerCase();
        boolean isSupportedFormat = false;
        
        if (fileName.endsWith(".csv")) {
            isSupportedFormat = true;
            result.setFileType("CSV");
        } else if (fileName.endsWith(".json")) {
            isSupportedFormat = true;
            result.setFileType("JSON");
        } else if (fileName.endsWith(".xml")) {
            if (options.isXmlSupported()) {
                isSupportedFormat = true;
                result.setFileType("XML");
            } else {
                result.setSuccess(false);
                result.setMessage("XML format not supported");
                return result;
            }
        }
        
        if (!isSupportedFormat) {
            result.setSuccess(false);
            result.setMessage("Unsupported file format");
            return result;
        }
        
        // ファイル読み込み処理
        int processedRecords = 0;
        int errorRecords = 0;
        
        try {
            List<String> lines = Files.readAllLines(file.toPath());
            
            for (String line : lines) {
                if (line == null || line.trim().isEmpty()) {
                    continue; // 空行スキップ
                }
                
                try {
                    // データ処理（仮想）
                    processRecord(line, options);
                    processedRecords++;
                } catch (DataProcessingException e) {
                    errorRecords++;
                    if (options.isStrictMode()) {
                        throw new ProcessingException("Strict mode: " + e.getMessage());
                    } else {
                        result.addWarning("Record processing failed: " + e.getMessage());
                    }
                }
            }
        } catch (IOException e) {
            result.setSuccess(false);
            result.setMessage("File reading failed: " + e.getMessage());
            return result;
        } catch (ProcessingException e) {
            result.setSuccess(false);
            result.setMessage(e.getMessage());
            return result;
        }
        
        // 結果判定
        if (processedRecords == 0) {
            result.setSuccess(false);
            result.setMessage("No valid records processed");
        } else {
            result.setSuccess(true);
            result.setMessage("Processing completed");
            result.setProcessedRecords(processedRecords);
            result.setErrorRecords(errorRecords);
            
            // エラー率チェック
            double errorRate = (double) errorRecords / (processedRecords + errorRecords);
            if (errorRate > 0.1) { // 10%超
                result.addWarning("High error rate: " + String.format("%.2f%%", errorRate * 100));
            }
        }
        
        return result;
    }
    
    private void processRecord(String record, ProcessingOptions options) 
            throws DataProcessingException {
        // データ処理の実装（仮想）
        if (record.contains("ERROR")) {
            throw new DataProcessingException("Invalid record format");
        }
    }
}
```

### ✅ 解答：異常系を含む完全な分岐網羅テスト

```java
@Test
public void testProcessDataFile_CompleteBranchCoverage() throws IOException {
    FileProcessingService service = new FileProcessingService();
    
    // === 入力検証テスト ===
    
    // TC1: null ファイルパス
    ProcessingResult result1 = service.processDataFile(null, null);
    assertFalse(result1.isSuccess());
    assertEquals("File path is required", result1.getMessage());
    
    // TC2: 空ファイルパス
    ProcessingResult result2 = service.processDataFile("  ", null);
    assertFalse(result2.isSuccess());
    assertEquals("File path is required", result2.getMessage());
    
    // TC3: ファイル未存在
    ProcessingResult result3 = service.processDataFile("nonexistent.csv", null);
    assertFalse(result3.isSuccess());
    assertTrue(result3.getMessage().contains("File not found"));
    
    // === ファイルサイズテスト ===
    
    // TC4: 空ファイル
    File emptyFile = createTempFile("empty.csv", "");
    ProcessingResult result4 = service.processDataFile(emptyFile.getPath(), null);
    assertFalse(result4.isSuccess());
    assertEquals("File is empty", result4.getMessage());
    
    // TC5: 大きなファイル（制限超過、許可なし）
    ProcessingOptions restrictiveOptions = new ProcessingOptions();
    restrictiveOptions.setMaxFileSize(100);
    restrictiveOptions.setAllowLargeFiles(false);
    
    File largeFile = createTempFile("large.csv", createLargeContent(200));
    ProcessingResult result5 = service.processDataFile(largeFile.getPath(), restrictiveOptions);
    assertFalse(result5.isSuccess());
    assertTrue(result5.getMessage().contains("File too large"));
    
    // TC6: 大きなファイル（制限超過、許可あり）
    ProcessingOptions permissiveOptions = new ProcessingOptions();
    permissiveOptions.setMaxFileSize(100);
    permissiveOptions.setAllowLargeFiles(true);
    
    ProcessingResult result6 = service.processDataFile(largeFile.getPath(), permissiveOptions);
    assertTrue(result6.isSuccess());
    assertTrue(result6.getWarnings().stream().anyMatch(w -> w.contains("Large file detected")));
    
    // === ファイル形式テスト ===
    
    // TC7: サポート形式（CSV）
    File csvFile = createTempFile("data.csv", "name,age\nJohn,25\nJane,30");
    ProcessingResult result7 = service.processDataFile(csvFile.getPath(), null);
    assertTrue(result7.isSuccess());
    assertEquals("CSV", result7.getFileType());
    assertEquals(2, result7.getProcessedRecords());
    
    // TC8: サポート形式（JSON）
    File jsonFile = createTempFile("data.json", "{\"name\":\"John\",\"age\":25}");
    ProcessingResult result8 = service.processDataFile(jsonFile.getPath(), null);
    assertTrue(result8.isSuccess());
    assertEquals("JSON", result8.getFileType());
    
    // TC9: XML（サポートあり）
    ProcessingOptions xmlEnabledOptions = new ProcessingOptions();
    xmlEnabledOptions.setXmlSupported(true);
    
    File xmlFile = createTempFile("data.xml", "<root><item>test</item></root>");
    ProcessingResult result9 = service.processDataFile(xmlFile.getPath(), xmlEnabledOptions);
    assertTrue(result9.isSuccess());
    assertEquals("XML", result9.getFileType());
    
    // TC10: XML（サポートなし）
    ProcessingOptions xmlDisabledOptions = new ProcessingOptions();
    xmlDisabledOptions.setXmlSupported(false);
    
    ProcessingResult result10 = service.processDataFile(xmlFile.getPath(), xmlDisabledOptions);
    assertFalse(result10.isSuccess());
    assertEquals("XML format not supported", result10.getMessage());
    
    // TC11: 未サポート形式
    File unsupportedFile = createTempFile("data.pdf", "PDF content");
    ProcessingResult result11 = service.processDataFile(unsupportedFile.getPath(), null);
    assertFalse(result11.isSuccess());
    assertEquals("Unsupported file format", result11.getMessage());
    
    // === データ処理テスト ===
    
    // TC12: ストリクトモード（エラー時中断）
    ProcessingOptions strictOptions = new ProcessingOptions();
    strictOptions.setStrictMode(true);
    
    File errorFile = createTempFile("error.csv", "good line\nERROR line\ngood line");
    ProcessingResult result12 = service.processDataFile(errorFile.getPath(), strictOptions);
    assertFalse(result12.isSuccess());
    assertTrue(result12.getMessage().contains("Strict mode"));
    
    // TC13: 非ストリクトモード（エラー時継続）
    ProcessingOptions lenientOptions = new ProcessingOptions();
    lenientOptions.setStrictMode(false);
    
    ProcessingResult result13 = service.processDataFile(errorFile.getPath(), lenientOptions);
    assertTrue(result13.isSuccess());
    assertEquals(2, result13.getProcessedRecords());
    assertEquals(1, result13.getErrorRecords());
    assertTrue(result13.getWarnings().stream().anyMatch(w -> w.contains("Record processing failed")));
    
    // TC14: 高エラー率（10%超）
    File highErrorFile = createTempFile("high_error.csv", 
        "good1\nERROR1\nERROR2\nERROR3\nERROR4\nERROR5\nERROR6\ngood2");
    ProcessingResult result14 = service.processDataFile(highErrorFile.getPath(), lenientOptions);
    assertTrue(result14.isSuccess());
    assertTrue(result14.getWarnings().stream().anyMatch(w -> w.contains("High error rate")));
    
    // TC15: 有効レコードなし
    File noValidFile = createTempFile("no_valid.csv", "\n\nERROR\nERROR\n\n");
    ProcessingResult result15 = service.processDataFile(noValidFile.getPath(), lenientOptions);
    assertFalse(result15.isSuccess());
    assertEquals("No valid records processed", result15.getMessage());
    
    // === IOException テスト ===
    
    // TC16: 読み込み権限なしファイル（IOException）
    File readOnlyFile = createTempFile("readonly.csv", "test data");
    readOnlyFile.setReadable(false);
    
    ProcessingResult result16 = service.processDataFile(readOnlyFile.getPath(), null);
    assertFalse(result16.isSuccess());
    assertTrue(result16.getMessage().contains("File reading failed"));
    
    // クリーンアップ
    readOnlyFile.setReadable(true);
    cleanupTempFiles();
}

// テストヘルパーメソッド
private File createTempFile(String name, String content) throws IOException {
    File tempFile = File.createTempFile("test_", "_" + name);
    tempFile.deleteOnExit();
    Files.write(tempFile.toPath(), content.getBytes());
    return tempFile;
}

private String createLargeContent(int sizeBytes) {
    StringBuilder sb = new StringBuilder();
    while (sb.length() < sizeBytes) {
        sb.append("test data line\n");
    }
    return sb.toString();
}
```

---

## 🎯 実務レベル分岐網羅の成功ポイント

### 💡 1. ビジネスシナリオの優先度付け
- **高頻度パス**: 正常系の主要な業務フロー
- **高リスクパス**: エラー時の影響が大きい分岐
- **境界条件**: 仕様の境界値での動作

### 💡 2. 効率的なテスト設計
- **複数分岐の同時カバー**: 1つのテストケースで複数分岐を実行
- **代表値の選定**: 同値クラス内の適切な代表値選択
- **データドリブンテスト**: パラメータ化による効率化

### 💡 3. 保守性の考慮
- **ヘルパーメソッド**: テストデータ作成の共通化
- **明確な命名**: テストケースの意図が分かる命名
- **適切なアサーション**: 期待値の明確な検証

### 💡 4. 実行効率の最適化
- **テスト分割**: 独立性を保った適切なテスト分割
- **リソース管理**: ファイル・DB接続等の適切なクリーンアップ
- **並列実行**: 並列実行可能なテスト設計

---

## 🚀 次のステップ

上級演習を完了したら、「05_追加演習・補強練習.md」で更なるスキル向上を図り、最終的に「06_実務適用ガイド.md」で実際のプロジェクトでの活用方法を学習しましょう。

実務レベルの分岐網羅スキルが身についたら、条件網羅やMC/DC等のより高度な技法への挑戦も可能です！
