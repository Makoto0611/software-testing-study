# 💪 条件網羅（Condition Coverage）- 追加演習・補強練習

## 🎯 補強練習の目的
- 条件網羅の理解を多様なパターンで深める
- 特殊なケース（言語固有の特徴等）での適用方法習得
- 実務でよくある複雑なパターンの克服

---

## 💪 補強演習 1：言語固有の条件評価

### 📝 問題：Nullable型と条件網羅
以下のC#コードで条件網羅を達成してください。

```csharp
public class NullableConditionProcessor 
{
    public ProcessResult ProcessData(int? value, string data, bool? flag)
    {
        // Nullable型の条件評価
        if (value.HasValue && value.Value > 0 && 
            !string.IsNullOrEmpty(data) && 
            flag == true)
        {
            return ProcessResult.Success($"Processed: {value.Value} with {data}");
        }
        
        // エラーハンドリングの複合条件
        if (!value.HasValue || value.Value <= 0)
        {
            return ProcessResult.Error("Invalid value");
        }
        
        if (string.IsNullOrEmpty(data) && (flag == null || flag == false))
        {
            return ProcessResult.Error("Missing data and flag");
        }
        
        // フォールバック処理
        if (flag == null && !string.IsNullOrEmpty(data))
        {
            return ProcessResult.Warning("Flag not specified, using default");
        }
        
        return ProcessResult.Error("Unhandled condition");
    }
}
```

### 🤔 分析手順

#### ステップ1: Nullable型の条件特定
```csharp
// 第1の複合条件
if (value.HasValue && value.Value > 0 && 
    !string.IsNullOrEmpty(data) && 
    flag == true)

// 個別条件:
// 1. value.HasValue
// 2. value.Value > 0
// 3. !string.IsNullOrEmpty(data) (= string.IsNullOrEmpty(data) のNOT)
// 4. flag == true
```

#### ステップ2: 3値論理の考慮
```csharp
// bool? flag の可能な値: true, false, null
// flag == true → true/false
// flag == false → true/false  
// flag == null → true/false
```

### ✅ 解答：Nullable型対応の条件網羅テスト

```csharp
[TestClass]
public class NullableConditionProcessorTests
{
    private NullableConditionProcessor processor;
    
    [TestInitialize]
    public void Setup()
    {
        processor = new NullableConditionProcessor();
    }
    
    [TestMethod]
    public void TestProcessData_NullableConditionCoverage()
    {
        // === 第1複合条件の条件網羅 ===
        
        // 条件1-True: value.HasValue = true
        ProcessResult result1 = processor.ProcessData(5, "test", true);
        Assert.AreEqual("Success", result1.Status);
        
        // 条件1-False: value.HasValue = false
        ProcessResult result2 = processor.ProcessData(null, "test", true);
        Assert.AreEqual("Error", result2.Status);
        Assert.AreEqual("Invalid value", result2.Message);
        
        // 条件2-True: value.Value > 0 (value.HasValueがtrueの場合)
        ProcessResult result3 = processor.ProcessData(10, "test", true);
        Assert.AreEqual("Success", result3.Status);
        
        // 条件2-False: value.Value <= 0
        ProcessResult result4 = processor.ProcessData(-5, "test", true);
        Assert.AreEqual("Error", result4.Status);
        
        // 条件3-True: !string.IsNullOrEmpty(data) = true (dataが有効)
        ProcessResult result5 = processor.ProcessData(5, "valid", true);
        Assert.AreEqual("Success", result5.Status);
        
        // 条件3-False: string.IsNullOrEmpty(data) = true
        ProcessResult result6 = processor.ProcessData(5, "", true);
        Assert.AreEqual("Error", result6.Status);
        
        ProcessResult result7 = processor.ProcessData(5, null, true);
        Assert.AreEqual("Error", result7.Status);
        
        // 条件4-True: flag == true
        ProcessResult result8 = processor.ProcessData(5, "test", true);
        Assert.AreEqual("Success", result8.Status);
        
        // 条件4-False: flag != true (falseとnullを含む)
        ProcessResult result9 = processor.ProcessData(5, "test", false);
        Assert.AreEqual("Error", result9.Status);
        
        ProcessResult result10 = processor.ProcessData(5, "test", null);
        Assert.AreEqual("Warning", result10.Status);
        
        // === エラーハンドリング条件の網羅 ===
        
        // 第2複合条件: !value.HasValue || value.Value <= 0
        // 条件1-True: !value.HasValue = true
        ProcessResult errorResult1 = processor.ProcessData(null, "test", false);
        Assert.AreEqual("Error", errorResult1.Status);
        Assert.AreEqual("Invalid value", errorResult1.Message);
        
        // 条件2-True: value.Value <= 0
        ProcessResult errorResult2 = processor.ProcessData(0, "test", false);
        Assert.AreEqual("Error", errorResult2.Status);
        
        // 第3複合条件: string.IsNullOrEmpty(data) && (flag == null || flag == false)
        ProcessResult errorResult3 = processor.ProcessData(5, "", null);  // 両条件true
        Assert.AreEqual("Error", errorResult3.Status);
        Assert.AreEqual("Missing data and flag", errorResult3.Message);
        
        ProcessResult errorResult4 = processor.ProcessData(5, "", false); // 両条件true
        Assert.AreEqual("Error", errorResult4.Status);
        
        // 第4複合条件: flag == null && !string.IsNullOrEmpty(data)
        ProcessResult warningResult = processor.ProcessData(5, "test", null);
        Assert.AreEqual("Warning", warningResult.Status);
        Assert.AreEqual("Flag not specified, using default", warningResult.Message);
    }
    
    [TestMethod]
    public void TestNullableSpecificConditions()
    {
        // Nullable型特有の条件パターン
        
        // bool? の3値すべてをテスト
        Assert.AreEqual("Success", processor.ProcessData(1, "test", true).Status);   // true
        Assert.AreEqual("Error", processor.ProcessData(1, "test", false).Status);    // false
        Assert.AreEqual("Warning", processor.ProcessData(1, "test", null).Status);   // null
        
        // int? の2状態をテスト
        Assert.AreEqual("Success", processor.ProcessData(1, "test", true).Status);   // HasValue
        Assert.AreEqual("Error", processor.ProcessData(null, "test", true).Status);  // !HasValue
    }
}
```

---

## 💪 補強演習 2：JavaScript/TypeScriptの条件網羅

### 📝 問題：型強制と短絡評価
以下のJavaScriptコードで条件網羅を達成してください。

```javascript
class DataValidator {
    validateUserInput(user, settings, options) {
        // JavaScript特有の型強制を含む条件
        if (user && user.name && user.name.trim() && 
            settings && settings.enabled && 
            (!options || options.strict !== false)) {
            
            return { valid: true, message: "Validation passed" };
        }
        
        // Falsy値の複合チェック
        if (!user || !user.name || user.name === '' || 
            user.name === null || user.name === undefined) {
            
            return { valid: false, message: "Invalid user name" };
        }
        
        // 型チェックと値チェックの組み合わせ
        if (typeof settings !== 'object' || 
            settings === null || 
            typeof settings.enabled !== 'boolean' ||
            settings.enabled === false) {
            
            return { valid: false, message: "Invalid settings" };
        }
        
        // Optional chaining風の条件チェック
        if (options && 
            options.hasOwnProperty('strict') && 
            options.strict === false &&
            (!options.allowEmpty || options.allowEmpty !== true)) {
            
            return { valid: false, message: "Strict mode disabled but empty not allowed" };
        }
        
        return { valid: false, message: "Unknown validation failure" };
    }
    
    validateNumericRange(value, min, max, config) {
        // 数値変換と範囲チェック
        const numValue = Number(value);
        
        if (isNaN(numValue) || 
            (!config || !config.allowInfinity) && !isFinite(numValue)) {
            
            return { valid: false, error: "Not a valid number" };
        }
        
        // 範囲チェックの複合条件
        const hasMin = min !== null && min !== undefined && !isNaN(min);
        const hasMax = max !== null && max !== undefined && !isNaN(max);
        
        if ((hasMin && numValue < min) || 
            (hasMax && numValue > max) ||
            (hasMin && hasMax && min > max)) {
            
            return { valid: false, error: "Value out of range" };
        }
        
        // 特殊値のハンドリング
        if ((numValue === 0 && config && config.disallowZero) ||
            (numValue < 0 && config && config.positiveOnly) ||
            (Number.isInteger(numValue) && config && config.decimalsOnly)) {
            
            return { valid: false, error: "Value violates constraints" };
        }
        
        return { valid: true, value: numValue };
    }
}
```

### ✅ 解答：JavaScript特有の条件網羅テスト

```javascript
describe('DataValidator Condition Coverage', () => {
    let validator;
    
    beforeEach(() => {
        validator = new DataValidator();
    });
    
    describe('validateUserInput - Condition Coverage', () => {
        
        it('should cover all truthy/falsy conditions', () => {
            // === 第1複合条件の条件網羅 ===
            
            // 条件1-True: user (truthy)
            let result = validator.validateUserInput(
                { name: 'John' },     // user: truthy
                { enabled: true },    // settings: truthy, enabled: true
                undefined             // options: falsy (!options = true)
            );
            expect(result.valid).toBe(true);
            
            // 条件1-False: user (falsy)
            result = validator.validateUserInput(
                null,                 // user: falsy
                { enabled: true },
                undefined
            );
            expect(result.valid).toBe(false);
            expect(result.message).toBe("Invalid user name");
            
            // 条件2-True: user.name (truthy)
            result = validator.validateUserInput(
                { name: 'John' },     // user.name: truthy
                { enabled: true },
                undefined
            );
            expect(result.valid).toBe(true);
            
            // 条件2-False: user.name (falsy)
            result = validator.validateUserInput(
                { name: '' },         // user.name: falsy (空文字)
                { enabled: true },
                undefined
            );
            expect(result.valid).toBe(false);
            
            result = validator.validateUserInput(
                { name: null },       // user.name: falsy (null)
                { enabled: true },
                undefined
            );
            expect(result.valid).toBe(false);
            
            result = validator.validateUserInput(
                {},                   // user.name: undefined (falsy)
                { enabled: true },
                undefined
            );
            expect(result.valid).toBe(false);
            
            // 条件3-True: user.name.trim() (truthy - 空白でない文字列)
            result = validator.validateUserInput(
                { name: '  John  ' }, // trim後: truthy
                { enabled: true },
                undefined
            );
            expect(result.valid).toBe(true);
            
            // 条件3-False: user.name.trim() (falsy - 空白のみ)
            result = validator.validateUserInput(
                { name: '   ' },      // trim後: falsy
                { enabled: true },
                undefined
            );
            expect(result.valid).toBe(false);
            
            // 条件4-True: settings (truthy)
            result = validator.validateUserInput(
                { name: 'John' },
                { enabled: true },    // settings: truthy
                undefined
            );
            expect(result.valid).toBe(true);
            
            // 条件4-False: settings (falsy)
            result = validator.validateUserInput(
                { name: 'John' },
                null,                 // settings: falsy
                undefined
            );
            expect(result.valid).toBe(false);
            expect(result.message).toBe("Invalid settings");
            
            // 条件5-True: settings.enabled (true)
            result = validator.validateUserInput(
                { name: 'John' },
                { enabled: true },    // enabled: true
                undefined
            );
            expect(result.valid).toBe(true);
            
            // 条件5-False: settings.enabled (false)
            result = validator.validateUserInput(
                { name: 'John' },
                { enabled: false },   // enabled: false
                undefined
            );
            expect(result.valid).toBe(false);
            
            // 条件6-True: !options (options is falsy)
            result = validator.validateUserInput(
                { name: 'John' },
                { enabled: true },
                null                  // options: falsy (!options = true)
            );
            expect(result.valid).toBe(true);
            
            // 条件6-False: options.strict !== false (optionsがtruthyでstrict !== false)
            result = validator.validateUserInput(
                { name: 'John' },
                { enabled: true },
                { strict: true }      // options: truthy, strict !== false
            );
            expect(result.valid).toBe(true);
            
            result = validator.validateUserInput(
                { name: 'John' },
                { enabled: true },
                { strict: false }     // options: truthy, strict === false
            );
            expect(result.valid).toBe(false);
        });
        
        it('should test typeof conditions', () => {
            // typeof チェックの条件網羅
            
            // typeof settings !== 'object': true
            let result = validator.validateUserInput(
                { name: 'John' },
                'invalid',            // string (not object)
                undefined
            );
            expect(result.valid).toBe(false);
            expect(result.message).toBe("Invalid settings");
            
            result = validator.validateUserInput(
                { name: 'John' },
                42,                   // number (not object)
                undefined
            );
            expect(result.valid).toBe(false);
            
            // settings === null: true (typeof null === 'object' だが null チェック)
            result = validator.validateUserInput(
                { name: 'John' },
                null,                 // null
                undefined
            );
            expect(result.valid).toBe(false);
            
            // typeof settings.enabled !== 'boolean': true
            result = validator.validateUserInput(
                { name: 'John' },
                { enabled: 'yes' },   // string (not boolean)
                undefined
            );
            expect(result.valid).toBe(false);
        });
    });
    
    describe('validateNumericRange - Condition Coverage', () => {
        
        it('should cover numeric conversion conditions', () => {
            // === 数値変換の条件網羅 ===
            
            // isNaN(numValue): true
            let result = validator.validateNumericRange('abc', 0, 100, {});
            expect(result.valid).toBe(false);
            expect(result.error).toBe("Not a valid number");
            
            // isNaN(numValue): false
            result = validator.validateNumericRange('42', 0, 100, {});
            expect(result.valid).toBe(true);
            
            // !isFinite(numValue): true (config.allowInfinity: false)
            result = validator.validateNumericRange('Infinity', 0, 100, { allowInfinity: false });
            expect(result.valid).toBe(false);
            
            // allowInfinity: true
            result = validator.validateNumericRange('Infinity', 0, 100, { allowInfinity: true });
            expect(result.valid).toBe(true);
            
            // !config: true (config falsy)
            result = validator.validateNumericRange('Infinity', 0, 100, null);
            expect(result.valid).toBe(false);
        });
        
        it('should cover range check conditions', () => {
            // === 範囲チェックの条件網羅 ===
            
            // hasMin: true/false
            let result = validator.validateNumericRange(50, 10, 100, {});   // hasMin: true
            expect(result.valid).toBe(true);
            
            result = validator.validateNumericRange(50, null, 100, {});     // hasMin: false
            expect(result.valid).toBe(true);
            
            result = validator.validateNumericRange(50, undefined, 100, {}); // hasMin: false
            expect(result.valid).toBe(true);
            
            // hasMax: true/false
            result = validator.validateNumericRange(50, 10, 100, {});       // hasMax: true
            expect(result.valid).toBe(true);
            
            result = validator.validateNumericRange(50, 10, null, {});      // hasMax: false
            expect(result.valid).toBe(true);
            
            // numValue < min: true
            result = validator.validateNumericRange(5, 10, 100, {});
            expect(result.valid).toBe(false);
            expect(result.error).toBe("Value out of range");
            
            // numValue > max: true
            result = validator.validateNumericRange(150, 10, 100, {});
            expect(result.valid).toBe(false);
            
            // min > max: true (invalid range)
            result = validator.validateNumericRange(50, 100, 10, {});
            expect(result.valid).toBe(false);
        });
        
        it('should cover special value conditions', () => {
            // === 特殊値の条件網羅 ===
            
            // numValue === 0 && config.disallowZero: true
            let result = validator.validateNumericRange(0, -10, 10, { disallowZero: true });
            expect(result.valid).toBe(false);
            expect(result.error).toBe("Value violates constraints");
            
            // numValue < 0 && config.positiveOnly: true  
            result = validator.validateNumericRange(-5, -10, 10, { positiveOnly: true });
            expect(result.valid).toBe(false);
            
            // Number.isInteger(numValue) && config.decimalsOnly: true
            result = validator.validateNumericRange(42, 0, 100, { decimalsOnly: true });
            expect(result.valid).toBe(false);
            
            // 正常ケース（全条件false）
            result = validator.validateNumericRange(42.5, 0, 100, { 
                disallowZero: false, 
                positiveOnly: false, 
                decimalsOnly: false 
            });
            expect(result.valid).toBe(true);
        });
    });
});
```

---

## 💪 補強演習 3：非同期処理と条件網羅

### 📝 問題：Promise・async/awaitでの条件網羅
以下のTypeScriptコードで条件網羅を達成してください。

```typescript
class AsyncDataProcessor {
    
    async processDataPipeline(
        input: DataInput, 
        config: ProcessingConfig, 
        context: ProcessingContext
    ): Promise<ProcessingResult> {
        
        // 前処理条件チェック
        if (!input || !input.data || input.data.length === 0) {
            return {
                success: false,
                error: "Invalid input data",
                code: "INPUT_ERROR"
            };
        }
        
        if (!config || (!config.enableValidation && !config.enableTransformation)) {
            return {
                success: false,
                error: "Invalid configuration",
                code: "CONFIG_ERROR"
            };
        }
        
        try {
            let processedData = input.data;
            
            // 検証フェーズ
            if (config.enableValidation) {
                const validationResult = await this.validateData(processedData, config.validationRules);
                
                if (!validationResult.isValid && 
                    (!config.continueOnValidationError || validationResult.severity === 'CRITICAL')) {
                    
                    return {
                        success: false,
                        error: `Validation failed: ${validationResult.message}`,
                        code: "VALIDATION_ERROR"
                    };
                }
                
                if (validationResult.isValid && config.filterInvalidData) {
                    processedData = validationResult.validData;
                }
            }
            
            // 変換フェーズ
            if (config.enableTransformation) {
                const transformationResult = await this.transformData(processedData, config.transformationRules);
                
                if (!transformationResult.success) {
                    if (config.rollbackOnTransformationError && 
                        context.transactionId && 
                        context.supportRollback) {
                        
                        await this.rollbackTransaction(context.transactionId);
                        return {
                            success: false,
                            error: "Transformation failed, changes rolled back",
                            code: "TRANSFORMATION_ROLLBACK"
                        };
                    } else {
                        return {
                            success: false,
                            error: `Transformation failed: ${transformationResult.error}`,
                            code: "TRANSFORMATION_ERROR"
                        };
                    }
                }
                
                processedData = transformationResult.data;
            }
            
            // 後処理条件チェック
            if (processedData.length === 0 && !config.allowEmptyResult) {
                return {
                    success: false,
                    error: "Processing resulted in empty data",
                    code: "EMPTY_RESULT"
                };
            }
            
            // 保存処理
            if (config.enablePersistence && 
                (!context.readOnlyMode || context.forceWrite)) {
                
                const persistResult = await this.persistData(processedData, context);
                
                if (!persistResult.success && config.requireSuccessfulPersistence) {
                    return {
                        success: false,
                        error: "Data persistence failed",
                        code: "PERSISTENCE_ERROR"
                    };
                }
            }
            
            return {
                success: true,
                data: processedData,
                metadata: {
                    originalCount: input.data.length,
                    processedCount: processedData.length,
                    validationEnabled: config.enableValidation,
                    transformationEnabled: config.enableTransformation
                }
            };
            
        } catch (error) {
            // 例外ハンドリングの条件分岐
            if (error instanceof ValidationError && config.treatValidationErrorsAsWarnings) {
                return {
                    success: true,
                    data: input.data,
                    warnings: [error.message]
                };
            } else if (error instanceof TimeoutError && config.retryOnTimeout) {
                return await this.processDataPipeline(input, config, context); // 再試行
            } else {
                return {
                    success: false,
                    error: `Unexpected error: ${error.message}`,
                    code: "UNEXPECTED_ERROR"
                };
            }
        }
    }
    
    // ヘルパーメソッド（モック用）
    private async validateData(data: any[], rules: ValidationRules): Promise<ValidationResult> {
        // 実装は省略
        return { isValid: true, validData: data, message: "", severity: "INFO" };
    }
    
    private async transformData(data: any[], rules: TransformationRules): Promise<TransformationResult> {
        // 実装は省略
        return { success: true, data: data };
    }
    
    private async rollbackTransaction(transactionId: string): Promise<void> {
        // 実装は省略
    }
    
    private async persistData(data: any[], context: ProcessingContext): Promise<PersistenceResult> {
        // 実装は省略
        return { success: true };
    }
}
```

### ✅ 解答：非同期処理の条件網羅テスト

```typescript
describe('AsyncDataProcessor Condition Coverage', () => {
    let processor: AsyncDataProcessor;
    let mockValidateData: jest.SpyInstance;
    let mockTransformData: jest.SpyInstance;
    let mockRollbackTransaction: jest.SpyInstance;
    let mockPersistData: jest.SpyInstance;
    
    beforeEach(() => {
        processor = new AsyncDataProcessor();
        
        // プライベートメソッドのモック
        mockValidateData = jest.spyOn(processor as any, 'validateData');
        mockTransformData = jest.spyOn(processor as any, 'transformData');
        mockRollbackTransaction = jest.spyOn(processor as any, 'rollbackTransaction');
        mockPersistData = jest.spyOn(processor as any, 'persistData');
    });
    
    afterEach(() => {
        jest.restoreAllMocks();
    });
    
    describe('Input Validation Conditions', () => {
        
        it('should cover all input validation conditions', async () => {
            // === 入力検証の条件網羅 ===
            
            // 条件1-True: !input
            let result = await processor.processDataPipeline(
                null,
                { enableValidation: true, enableTransformation: false },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(false);
            expect(result.code).toBe("INPUT_ERROR");
            
            // 条件2-True: !input.data
            result = await processor.processDataPipeline(
                { data: null },
                { enableValidation: true, enableTransformation: false },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(false);
            
            // 条件3-True: input.data.length === 0
            result = await processor.processDataPipeline(
                { data: [] },
                { enableValidation: true, enableTransformation: false },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(false);
            
            // 全条件False（正常入力）
            mockValidateData.mockResolvedValue({ isValid: true, validData: [1, 2, 3], message: "", severity: "INFO" });
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },  // 有効な入力
                { enableValidation: true, enableTransformation: false },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(true);
        });
        
        it('should cover configuration validation conditions', async () => {
            // === 設定検証の条件網羅 ===
            
            // 条件1-True: !config
            let result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                null,
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(false);
            expect(result.code).toBe("CONFIG_ERROR");
            
            // 条件2-True: !enableValidation && !enableTransformation
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { enableValidation: false, enableTransformation: false },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(false);
            expect(result.code).toBe("CONFIG_ERROR");
            
            // 条件2-False: enableValidation || enableTransformation
            mockValidateData.mockResolvedValue({ isValid: true, validData: [1, 2, 3], message: "", severity: "INFO" });
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { enableValidation: true, enableTransformation: false }, // validation有効
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(true);
        });
    });
    
    describe('Validation Phase Conditions', () => {
        
        it('should cover validation conditions', async () => {
            // === 検証フェーズの条件網羅 ===
            
            // enableValidation: true
            mockValidateData.mockResolvedValue({ isValid: true, validData: [1, 2, 3], message: "", severity: "INFO" });
            
            let result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { enableValidation: true, enableTransformation: false },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(true);
            expect(mockValidateData).toHaveBeenCalled();
            
            // enableValidation: false
            mockValidateData.mockClear();
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { enableValidation: false, enableTransformation: true }, // validation無効
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(mockValidateData).not.toHaveBeenCalled();
            
            // 検証失敗 + 継続不可
            mockValidateData.mockResolvedValue({ 
                isValid: false, 
                validData: [], 
                message: "Validation failed", 
                severity: "CRITICAL" 
            });
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    continueOnValidationError: false  // 検証エラー時継続しない
                },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(false);
            expect(result.code).toBe("VALIDATION_ERROR");
            
            // 検証失敗 + 継続可能だがCRITICAL
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    continueOnValidationError: true,  // 継続する設定だが
                    // CRITICAL severityなので停止
                },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(false);
            
            // 検証成功 + フィルタリング
            mockValidateData.mockResolvedValue({ 
                isValid: true, 
                validData: [1, 3], // フィルタ後のデータ
                message: "", 
                severity: "INFO" 
            });
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    filterInvalidData: true  // 無効データフィルタリング
                },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(true);
            expect(result.data).toEqual([1, 3]);
        });
    });
    
    describe('Transformation Phase Conditions', () => {
        
        it('should cover transformation and rollback conditions', async () => {
            // === 変換フェーズの条件網羅 ===
            
            mockValidateData.mockResolvedValue({ isValid: true, validData: [1, 2, 3], message: "", severity: "INFO" });
            
            // 変換成功
            mockTransformData.mockResolvedValue({ success: true, data: [2, 4, 6] });
            
            let result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { enableValidation: true, enableTransformation: true },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(true);
            expect(result.data).toEqual([2, 4, 6]);
            
            // 変換失敗 + ロールバック条件すべてTrue
            mockTransformData.mockResolvedValue({ success: false, error: "Transform failed" });
            mockRollbackTransaction.mockResolvedValue(undefined);
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: true,
                    rollbackOnTransformationError: true  // ロールバック有効
                },
                { 
                    transactionId: "test123",  // transactionId有効
                    supportRollback: true,     // ロールバックサポート
                    readOnlyMode: false 
                }
            );
            expect(result.success).toBe(false);
            expect(result.code).toBe("TRANSFORMATION_ROLLBACK");
            expect(mockRollbackTransaction).toHaveBeenCalledWith("test123");
            
            // 変換失敗 + ロールバック条件の一部False
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: true,
                    rollbackOnTransformationError: true
                },
                { 
                    transactionId: null,       // transactionId無効
                    supportRollback: true,
                    readOnlyMode: false 
                }
            );
            expect(result.success).toBe(false);
            expect(result.code).toBe("TRANSFORMATION_ERROR"); // ロールバックされない
        });
    });
    
    describe('Exception Handling Conditions', () => {
        
        it('should cover exception handling conditions', async () => {
            // === 例外ハンドリングの条件網羅 ===
            
            // ValidationError + treatValidationErrorsAsWarnings: true
            const validationError = new ValidationError("Validation issue");
            mockValidateData.mockRejectedValue(validationError);
            
            let result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    treatValidationErrorsAsWarnings: true  // 警告として扱う
                },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(true);
            expect(result.warnings).toContain("Validation issue");
            
            // TimeoutError + retryOnTimeout: true
            const timeoutError = new TimeoutError("Operation timed out");
            mockValidateData
                .mockRejectedValueOnce(timeoutError)  // 1回目はタイムアウト
                .mockResolvedValue({ isValid: true, validData: [1, 2, 3], message: "", severity: "INFO" }); // 2回目は成功
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    retryOnTimeout: true  // タイムアウト時再試行
                },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(true); // 再試行で成功
            
            // その他の例外
            const unexpectedError = new Error("Unexpected issue");
            mockValidateData.mockRejectedValue(unexpectedError);
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    treatValidationErrorsAsWarnings: false
                },
                { transactionId: "test", supportRollback: true, readOnlyMode: false }
            );
            expect(result.success).toBe(false);
            expect(result.code).toBe("UNEXPECTED_ERROR");
        });
    });
    
    describe('Persistence Conditions', () => {
        
        it('should cover persistence conditions', async () => {
            mockValidateData.mockResolvedValue({ isValid: true, validData: [1, 2, 3], message: "", severity: "INFO" });
            mockPersistData.mockResolvedValue({ success: true });
            
            // === 永続化の条件網羅 ===
            
            // enablePersistence: true, readOnlyMode: false
            let result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    enablePersistence: true  // 永続化有効
                },
                { 
                    transactionId: "test", 
                    supportRollback: true, 
                    readOnlyMode: false,  // 読み取り専用でない
                    forceWrite: false
                }
            );
            expect(result.success).toBe(true);
            expect(mockPersistData).toHaveBeenCalled();
            
            // enablePersistence: true, readOnlyMode: true, forceWrite: true
            mockPersistData.mockClear();
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    enablePersistence: true
                },
                { 
                    transactionId: "test", 
                    supportRollback: true, 
                    readOnlyMode: true,   // 読み取り専用だが
                    forceWrite: true      // 強制書き込み
                }
            );
            expect(result.success).toBe(true);
            expect(mockPersistData).toHaveBeenCalled();
            
            // enablePersistence: true, readOnlyMode: true, forceWrite: false
            mockPersistData.mockClear();
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    enablePersistence: true
                },
                { 
                    transactionId: "test", 
                    supportRollback: true, 
                    readOnlyMode: true,   // 読み取り専用
                    forceWrite: false     // 強制書き込みなし
                }
            );
            expect(result.success).toBe(true);
            expect(mockPersistData).not.toHaveBeenCalled(); // 永続化スキップ
            
            // 永続化失敗 + requireSuccessfulPersistence: true
            mockPersistData.mockResolvedValue({ success: false });
            
            result = await processor.processDataPipeline(
                { data: [1, 2, 3] },
                { 
                    enableValidation: true, 
                    enableTransformation: false,
                    enablePersistence: true,
                    requireSuccessfulPersistence: true  // 永続化必須
                },
                { 
                    transactionId: "test", 
                    supportRollback: true, 
                    readOnlyMode: false,
                    forceWrite: false
                }
            );
            expect(result.success).toBe(false);
            expect(result.code).toBe("PERSISTENCE_ERROR");
        });
    });
});

// カスタムエラークラス（テスト用）
class ValidationError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'ValidationError';
    }
}

class TimeoutError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'TimeoutError';
    }
}
```

---

## 🎯 補強練習での重要な学習ポイント

### 💡 1. 言語固有の特徴への対応
- **Nullable型**: null許容型での3値論理の考慮
- **型強制**: JavaScriptの暗黙的型変換を考慮した条件設計
- **短絡評価**: 言語仕様による評価停止の影響

### 💡 2. 非同期処理での条件網羅
- **Promise/async-await**: 非同期条件での例外ハンドリング
- **タイムアウト処理**: 時間制限による条件分岐
- **再試行ロジック**: 失敗時の条件付き再実行

### 💡 3. 実務での複雑性への対応
- **段階的テスト**: フェーズ毎の条件網羅
- **モック戦略**: 外部依存の条件制御
- **エラーシナリオ**: 例外系の網羅的テスト

---

## 🚀 次のステップ

補強練習を完了したら、「06_実務適用ガイド.md」で実際のプロジェクトでの条件網羅活用方法を学習しましょう。

様々な言語や技術スタックでの条件網羅適用スキルを身につけて、どのような環境でも高品質なテストを実現できるエンジニアを目指しましょう！
